{"ast":null,"code":"// Fine Uploader 5.16.2 - MIT licensed. http://fineuploader.com\n(function (global) {\n  var qq = function (element) {\n    \"use strict\";\n\n    return {\n      hide: function () {\n        element.style.display = \"none\";\n        return this;\n      },\n      attach: function (type, fn) {\n        if (element.addEventListener) {\n          element.addEventListener(type, fn, false);\n        } else if (element.attachEvent) {\n          element.attachEvent(\"on\" + type, fn);\n        }\n\n        return function () {\n          qq(element).detach(type, fn);\n        };\n      },\n      detach: function (type, fn) {\n        if (element.removeEventListener) {\n          element.removeEventListener(type, fn, false);\n        } else if (element.attachEvent) {\n          element.detachEvent(\"on\" + type, fn);\n        }\n\n        return this;\n      },\n      contains: function (descendant) {\n        if (!descendant) {\n          return false;\n        }\n\n        if (element === descendant) {\n          return true;\n        }\n\n        if (element.contains) {\n          return element.contains(descendant);\n        } else {\n          return !!(descendant.compareDocumentPosition(element) & 8);\n        }\n      },\n      insertBefore: function (elementB) {\n        elementB.parentNode.insertBefore(element, elementB);\n        return this;\n      },\n      remove: function () {\n        element.parentNode.removeChild(element);\n        return this;\n      },\n      css: function (styles) {\n        if (element.style == null) {\n          throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n        }\n\n        if (styles.opacity != null) {\n          if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n            styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n          }\n        }\n\n        qq.extend(element.style, styles);\n        return this;\n      },\n      hasClass: function (name, considerParent) {\n        var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n        return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n      },\n      addClass: function (name) {\n        if (!qq(element).hasClass(name)) {\n          element.className += \" \" + name;\n        }\n\n        return this;\n      },\n      removeClass: function (name) {\n        var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n        element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n        return this;\n      },\n      getByClass: function (className, first) {\n        var candidates,\n            result = [];\n\n        if (first && element.querySelector) {\n          return element.querySelector(\".\" + className);\n        } else if (element.querySelectorAll) {\n          return element.querySelectorAll(\".\" + className);\n        }\n\n        candidates = element.getElementsByTagName(\"*\");\n        qq.each(candidates, function (idx, val) {\n          if (qq(val).hasClass(className)) {\n            result.push(val);\n          }\n        });\n        return first ? result[0] : result;\n      },\n      getFirstByClass: function (className) {\n        return qq(element).getByClass(className, true);\n      },\n      children: function () {\n        var children = [],\n            child = element.firstChild;\n\n        while (child) {\n          if (child.nodeType === 1) {\n            children.push(child);\n          }\n\n          child = child.nextSibling;\n        }\n\n        return children;\n      },\n      setText: function (text) {\n        element.innerText = text;\n        element.textContent = text;\n        return this;\n      },\n      clearText: function () {\n        return qq(element).setText(\"\");\n      },\n      hasAttribute: function (attrName) {\n        var attrVal;\n\n        if (element.hasAttribute) {\n          if (!element.hasAttribute(attrName)) {\n            return false;\n          }\n\n          return /^false$/i.exec(element.getAttribute(attrName)) == null;\n        } else {\n          attrVal = element[attrName];\n\n          if (attrVal === undefined) {\n            return false;\n          }\n\n          return /^false$/i.exec(attrVal) == null;\n        }\n      }\n    };\n  };\n\n  (function () {\n    \"use strict\";\n\n    qq.canvasToBlob = function (canvas, mime, quality) {\n      return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n    };\n\n    qq.dataUriToBlob = function (dataUri) {\n      var arrayBuffer,\n          byteString,\n          createBlob = function (data, mime) {\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,\n            blobBuilder = BlobBuilder && new BlobBuilder();\n\n        if (blobBuilder) {\n          blobBuilder.append(data);\n          return blobBuilder.getBlob(mime);\n        } else {\n          return new Blob([data], {\n            type: mime\n          });\n        }\n      },\n          intArray,\n          mimeString;\n\n      if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n        byteString = atob(dataUri.split(\",\")[1]);\n      } else {\n        byteString = decodeURI(dataUri.split(\",\")[1]);\n      }\n\n      mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n      arrayBuffer = new ArrayBuffer(byteString.length);\n      intArray = new Uint8Array(arrayBuffer);\n      qq.each(byteString, function (idx, character) {\n        intArray[idx] = character.charCodeAt(0);\n      });\n      return createBlob(arrayBuffer, mimeString);\n    };\n\n    qq.log = function (message, level) {\n      if (window.console) {\n        if (!level || level === \"info\") {\n          window.console.log(message);\n        } else {\n          if (window.console[level]) {\n            window.console[level](message);\n          } else {\n            window.console.log(\"<\" + level + \"> \" + message);\n          }\n        }\n      }\n    };\n\n    qq.isObject = function (variable) {\n      return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n    };\n\n    qq.isFunction = function (variable) {\n      return typeof variable === \"function\";\n    };\n\n    qq.isArray = function (value) {\n      return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n    };\n\n    qq.isItemList = function (maybeItemList) {\n      return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n    };\n\n    qq.isNodeList = function (maybeNodeList) {\n      return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n    };\n\n    qq.isString = function (maybeString) {\n      return Object.prototype.toString.call(maybeString) === \"[object String]\";\n    };\n\n    qq.trimStr = function (string) {\n      if (String.prototype.trim) {\n        return string.trim();\n      }\n\n      return string.replace(/^\\s+|\\s+$/g, \"\");\n    };\n\n    qq.format = function (str) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          newStr = str,\n          nextIdxToReplace = newStr.indexOf(\"{}\");\n      qq.each(args, function (idx, val) {\n        var strBefore = newStr.substring(0, nextIdxToReplace),\n            strAfter = newStr.substring(nextIdxToReplace + 2);\n        newStr = strBefore + val + strAfter;\n        nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n\n        if (nextIdxToReplace < 0) {\n          return false;\n        }\n      });\n      return newStr;\n    };\n\n    qq.isFile = function (maybeFile) {\n      return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n    };\n\n    qq.isFileList = function (maybeFileList) {\n      return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n    };\n\n    qq.isFileOrInput = function (maybeFileOrInput) {\n      return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n    };\n\n    qq.isInput = function (maybeInput, notFile) {\n      var evaluateType = function (type) {\n        var normalizedType = type.toLowerCase();\n\n        if (notFile) {\n          return normalizedType !== \"file\";\n        }\n\n        return normalizedType === \"file\";\n      };\n\n      if (window.HTMLInputElement) {\n        if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n          if (maybeInput.type && evaluateType(maybeInput.type)) {\n            return true;\n          }\n        }\n      }\n\n      if (maybeInput.tagName) {\n        if (maybeInput.tagName.toLowerCase() === \"input\") {\n          if (maybeInput.type && evaluateType(maybeInput.type)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    qq.isBlob = function (maybeBlob) {\n      if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n        return true;\n      }\n    };\n\n    qq.isXhrUploadSupported = function () {\n      var input = document.createElement(\"input\");\n      input.type = \"file\";\n      return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n    };\n\n    qq.createXhrInstance = function () {\n      if (window.XMLHttpRequest) {\n        return new XMLHttpRequest();\n      }\n\n      try {\n        return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n      } catch (error) {\n        qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n        return null;\n      }\n    };\n\n    qq.isFolderDropSupported = function (dataTransfer) {\n      return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n    };\n\n    qq.isFileChunkingSupported = function () {\n      return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n    };\n\n    qq.sliceBlob = function (fileOrBlob, start, end) {\n      var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n      return slicer.call(fileOrBlob, start, end);\n    };\n\n    qq.arrayBufferToHex = function (buffer) {\n      var bytesAsHex = \"\",\n          bytes = new Uint8Array(buffer);\n      qq.each(bytes, function (idx, byt) {\n        var byteAsHexStr = byt.toString(16);\n\n        if (byteAsHexStr.length < 2) {\n          byteAsHexStr = \"0\" + byteAsHexStr;\n        }\n\n        bytesAsHex += byteAsHexStr;\n      });\n      return bytesAsHex;\n    };\n\n    qq.readBlobToHex = function (blob, startOffset, length) {\n      var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length),\n          fileReader = new FileReader(),\n          promise = new qq.Promise();\n\n      fileReader.onload = function () {\n        promise.success(qq.arrayBufferToHex(fileReader.result));\n      };\n\n      fileReader.onerror = promise.failure;\n      fileReader.readAsArrayBuffer(initialBlob);\n      return promise;\n    };\n\n    qq.extend = function (first, second, extendNested) {\n      qq.each(second, function (prop, val) {\n        if (extendNested && qq.isObject(val)) {\n          if (first[prop] === undefined) {\n            first[prop] = {};\n          }\n\n          qq.extend(first[prop], val, true);\n        } else {\n          first[prop] = val;\n        }\n      });\n      return first;\n    };\n\n    qq.override = function (target, sourceFn) {\n      var super_ = {},\n          source = sourceFn(super_);\n      qq.each(source, function (srcPropName, srcPropVal) {\n        if (target[srcPropName] !== undefined) {\n          super_[srcPropName] = target[srcPropName];\n        }\n\n        target[srcPropName] = srcPropVal;\n      });\n      return target;\n    };\n\n    qq.indexOf = function (arr, elt, from) {\n      if (arr.indexOf) {\n        return arr.indexOf(elt, from);\n      }\n\n      from = from || 0;\n      var len = arr.length;\n\n      if (from < 0) {\n        from += len;\n      }\n\n      for (; from < len; from += 1) {\n        if (arr.hasOwnProperty(from) && arr[from] === elt) {\n          return from;\n        }\n      }\n\n      return -1;\n    };\n\n    qq.getUniqueId = function () {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    };\n\n    qq.ie = function () {\n      return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n    };\n\n    qq.ie7 = function () {\n      return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n    };\n\n    qq.ie8 = function () {\n      return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n    };\n\n    qq.ie10 = function () {\n      return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n    };\n\n    qq.ie11 = function () {\n      return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n    };\n\n    qq.edge = function () {\n      return navigator.userAgent.indexOf(\"Edge\") >= 0;\n    };\n\n    qq.safari = function () {\n      return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n    };\n\n    qq.chrome = function () {\n      return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n    };\n\n    qq.opera = function () {\n      return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n    };\n\n    qq.firefox = function () {\n      return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n    };\n\n    qq.windows = function () {\n      return navigator.platform === \"Win32\";\n    };\n\n    qq.android = function () {\n      return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n    };\n\n    qq.androidStock = function () {\n      return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n    };\n\n    qq.ios6 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n    };\n\n    qq.ios7 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n    };\n\n    qq.ios8 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n    };\n\n    qq.ios800 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n    };\n\n    qq.ios = function () {\n      return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n    };\n\n    qq.iosChrome = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n    };\n\n    qq.iosSafari = function () {\n      return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n    };\n\n    qq.iosSafariWebView = function () {\n      return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n    };\n\n    qq.preventDefault = function (e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    };\n\n    qq.toElement = function () {\n      var div = document.createElement(\"div\");\n      return function (html) {\n        div.innerHTML = html;\n        var element = div.firstChild;\n        div.removeChild(element);\n        return element;\n      };\n    }();\n\n    qq.each = function (iterableItem, callback) {\n      var keyOrIndex, retVal;\n\n      if (iterableItem) {\n        if (window.Storage && iterableItem.constructor === window.Storage) {\n          for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n            retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n\n            if (retVal === false) {\n              break;\n            }\n          }\n        } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n          for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n\n            if (retVal === false) {\n              break;\n            }\n          }\n        } else if (qq.isString(iterableItem)) {\n          for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n            retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n\n            if (retVal === false) {\n              break;\n            }\n          }\n        } else {\n          for (keyOrIndex in iterableItem) {\n            if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n              retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n\n              if (retVal === false) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    qq.bind = function (oldFunc, context) {\n      if (qq.isFunction(oldFunc)) {\n        var args = Array.prototype.slice.call(arguments, 2);\n        return function () {\n          var newArgs = qq.extend([], args);\n\n          if (arguments.length) {\n            newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n          }\n\n          return oldFunc.apply(context, newArgs);\n        };\n      }\n\n      throw new Error(\"first parameter must be a function!\");\n    };\n\n    qq.obj2url = function (obj, temp, prefixDone) {\n      var uristrings = [],\n          prefix = \"&\",\n          add = function (nextObj, i) {\n        var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n\n        if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n          uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n        }\n      };\n\n      if (!prefixDone && temp) {\n        prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n        uristrings.push(temp);\n        uristrings.push(qq.obj2url(obj));\n      } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n        qq.each(obj, function (idx, val) {\n          add(val, idx);\n        });\n      } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n        qq.each(obj, function (prop, val) {\n          add(val, prop);\n        });\n      } else {\n        uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n      }\n\n      if (temp) {\n        return uristrings.join(prefix);\n      } else {\n        return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n      }\n    };\n\n    qq.obj2FormData = function (obj, formData, arrayKeyName) {\n      if (!formData) {\n        formData = new FormData();\n      }\n\n      qq.each(obj, function (key, val) {\n        key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n\n        if (qq.isObject(val)) {\n          qq.obj2FormData(val, formData, key);\n        } else if (qq.isFunction(val)) {\n          formData.append(key, val());\n        } else {\n          formData.append(key, val);\n        }\n      });\n      return formData;\n    };\n\n    qq.obj2Inputs = function (obj, form) {\n      var input;\n\n      if (!form) {\n        form = document.createElement(\"form\");\n      }\n\n      qq.obj2FormData(obj, {\n        append: function (key, val) {\n          input = document.createElement(\"input\");\n          input.setAttribute(\"name\", key);\n          input.setAttribute(\"value\", val);\n          form.appendChild(input);\n        }\n      });\n      return form;\n    };\n\n    qq.parseJson = function (json) {\n      if (window.JSON && qq.isFunction(JSON.parse)) {\n        return JSON.parse(json);\n      } else {\n        return eval(\"(\" + json + \")\");\n      }\n    };\n\n    qq.getExtension = function (filename) {\n      var extIdx = filename.lastIndexOf(\".\") + 1;\n\n      if (extIdx > 0) {\n        return filename.substr(extIdx, filename.length - extIdx);\n      }\n    };\n\n    qq.getFilename = function (blobOrFileInput) {\n      if (qq.isInput(blobOrFileInput)) {\n        return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n      } else if (qq.isFile(blobOrFileInput)) {\n        if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n          return blobOrFileInput.fileName;\n        }\n      }\n\n      return blobOrFileInput.name;\n    };\n\n    qq.DisposeSupport = function () {\n      var disposers = [];\n      return {\n        dispose: function () {\n          var disposer;\n\n          do {\n            disposer = disposers.shift();\n\n            if (disposer) {\n              disposer();\n            }\n          } while (disposer);\n        },\n        attach: function () {\n          var args = arguments;\n          this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n        },\n        addDisposer: function (disposeFunction) {\n          disposers.push(disposeFunction);\n        }\n      };\n    };\n  })();\n\n  (function () {\n    \"use strict\";\n\n    if (typeof define === \"function\" && define.amd) {\n      define(function () {\n        return qq;\n      });\n    } else if (typeof module !== \"undefined\" && module.exports) {\n      module.exports = qq;\n    } else {\n      global.qq = qq;\n    }\n  })();\n\n  (function () {\n    \"use strict\";\n\n    qq.Error = function (message) {\n      this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n    };\n\n    qq.Error.prototype = new Error();\n  })();\n\n  qq.version = \"5.16.2\";\n\n  qq.supportedFeatures = function () {\n    \"use strict\";\n\n    var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n\n    function testSupportsFileInputElement() {\n      var supported = true,\n          tempInput;\n\n      try {\n        tempInput = document.createElement(\"input\");\n        tempInput.type = \"file\";\n        qq(tempInput).hide();\n\n        if (tempInput.disabled) {\n          supported = false;\n        }\n      } catch (ex) {\n        supported = false;\n      }\n\n      return supported;\n    }\n\n    function isChrome14OrHigher() {\n      return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n    }\n\n    function isCrossOriginXhrSupported() {\n      if (window.XMLHttpRequest) {\n        var xhr = qq.createXhrInstance();\n        return xhr.withCredentials !== undefined;\n      }\n\n      return false;\n    }\n\n    function isXdrSupported() {\n      return window.XDomainRequest !== undefined;\n    }\n\n    function isCrossOriginAjaxSupported() {\n      if (isCrossOriginXhrSupported()) {\n        return true;\n      }\n\n      return isXdrSupported();\n    }\n\n    function isFolderSelectionSupported() {\n      return document.createElement(\"input\").webkitdirectory !== undefined;\n    }\n\n    function isLocalStorageSupported() {\n      try {\n        return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n      } catch (error) {\n        return false;\n      }\n    }\n\n    function isDragAndDropSupported() {\n      var span = document.createElement(\"span\");\n      return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n    }\n\n    supportsUploading = testSupportsFileInputElement();\n    supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n    supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n    supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n\n    supportsFolderDrop = supportsFileDrop && function () {\n      var input = document.createElement(\"input\");\n      input.type = \"file\";\n      return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n    }();\n\n    supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n    supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n    supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n    supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n    supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n    supportsDeleteFileXdr = isXdrSupported();\n    supportsDeleteFileCors = isCrossOriginAjaxSupported();\n    supportsFolderSelection = isFolderSelectionSupported();\n    supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n\n    supportsUploadProgress = function () {\n      if (supportsAjaxFileUploading) {\n        return !qq.androidStock() && !qq.iosChrome();\n      }\n\n      return false;\n    }();\n\n    return {\n      ajaxUploading: supportsAjaxFileUploading,\n      blobUploading: supportsUploadingBlobs,\n      canDetermineSize: supportsAjaxFileUploading,\n      chunking: supportsChunking,\n      deleteFileCors: supportsDeleteFileCors,\n      deleteFileCorsXdr: supportsDeleteFileXdr,\n      deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n      dialogElement: !!window.HTMLDialogElement,\n      fileDrop: supportsFileDrop,\n      folderDrop: supportsFolderDrop,\n      folderSelection: supportsFolderSelection,\n      imagePreviews: supportsImagePreviews,\n      imageValidation: supportsImagePreviews,\n      itemSizeValidation: supportsAjaxFileUploading,\n      pause: supportsChunking,\n      progressBar: supportsUploadProgress,\n      resume: supportsResume,\n      scaling: supportsImagePreviews && supportsUploadingBlobs,\n      tiffPreviews: qq.safari(),\n      unlimitedScaledImageSize: !qq.ios(),\n      uploading: supportsUploading,\n      uploadCors: supportsUploadCors,\n      uploadCustomHeaders: supportsAjaxFileUploading,\n      uploadNonMultipart: supportsAjaxFileUploading,\n      uploadViaPaste: supportsUploadViaPaste\n    };\n  }();\n\n  qq.isGenericPromise = function (maybePromise) {\n    \"use strict\";\n\n    return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n  };\n\n  qq.Promise = function () {\n    \"use strict\";\n\n    var successArgs,\n        failureArgs,\n        successCallbacks = [],\n        failureCallbacks = [],\n        doneCallbacks = [],\n        state = 0;\n    qq.extend(this, {\n      then: function (onSuccess, onFailure) {\n        if (state === 0) {\n          if (onSuccess) {\n            successCallbacks.push(onSuccess);\n          }\n\n          if (onFailure) {\n            failureCallbacks.push(onFailure);\n          }\n        } else if (state === -1) {\n          onFailure && onFailure.apply(null, failureArgs);\n        } else if (onSuccess) {\n          onSuccess.apply(null, successArgs);\n        }\n\n        return this;\n      },\n      done: function (callback) {\n        if (state === 0) {\n          doneCallbacks.push(callback);\n        } else {\n          callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n        }\n\n        return this;\n      },\n      success: function () {\n        state = 1;\n        successArgs = arguments;\n\n        if (successCallbacks.length) {\n          qq.each(successCallbacks, function (idx, callback) {\n            callback.apply(null, successArgs);\n          });\n        }\n\n        if (doneCallbacks.length) {\n          qq.each(doneCallbacks, function (idx, callback) {\n            callback.apply(null, successArgs);\n          });\n        }\n\n        return this;\n      },\n      failure: function () {\n        state = -1;\n        failureArgs = arguments;\n\n        if (failureCallbacks.length) {\n          qq.each(failureCallbacks, function (idx, callback) {\n            callback.apply(null, failureArgs);\n          });\n        }\n\n        if (doneCallbacks.length) {\n          qq.each(doneCallbacks, function (idx, callback) {\n            callback.apply(null, failureArgs);\n          });\n        }\n\n        return this;\n      }\n    });\n  };\n\n  qq.BlobProxy = function (referenceBlob, onCreate) {\n    \"use strict\";\n\n    qq.extend(this, {\n      referenceBlob: referenceBlob,\n      create: function () {\n        return onCreate(referenceBlob);\n      }\n    });\n  };\n\n  qq.UploadButton = function (o) {\n    \"use strict\";\n\n    var self = this,\n        disposeSupport = new qq.DisposeSupport(),\n        options = {\n      acceptFiles: null,\n      element: null,\n      focusClass: \"qq-upload-button-focus\",\n      folders: false,\n      hoverClass: \"qq-upload-button-hover\",\n      ios8BrowserCrashWorkaround: false,\n      multiple: false,\n      name: \"qqfile\",\n      onChange: function (input) {},\n      title: null\n    },\n        input,\n        buttonId;\n    qq.extend(options, o);\n    buttonId = qq.getUniqueId();\n\n    function createInput() {\n      var input = document.createElement(\"input\");\n      input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n      input.setAttribute(\"title\", options.title);\n      self.setMultiple(options.multiple, input);\n\n      if (options.folders && qq.supportedFeatures.folderSelection) {\n        input.setAttribute(\"webkitdirectory\", \"\");\n      }\n\n      if (options.acceptFiles) {\n        input.setAttribute(\"accept\", options.acceptFiles);\n      }\n\n      input.setAttribute(\"type\", \"file\");\n      input.setAttribute(\"name\", options.name);\n      qq(input).css({\n        position: \"absolute\",\n        right: 0,\n        top: 0,\n        fontFamily: \"Arial\",\n        fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n        margin: 0,\n        padding: 0,\n        cursor: \"pointer\",\n        opacity: 0\n      });\n      !qq.ie7() && qq(input).css({\n        height: \"100%\"\n      });\n      options.element.appendChild(input);\n      disposeSupport.attach(input, \"change\", function () {\n        options.onChange(input);\n      });\n      disposeSupport.attach(input, \"mouseover\", function () {\n        qq(options.element).addClass(options.hoverClass);\n      });\n      disposeSupport.attach(input, \"mouseout\", function () {\n        qq(options.element).removeClass(options.hoverClass);\n      });\n      disposeSupport.attach(input, \"focus\", function () {\n        qq(options.element).addClass(options.focusClass);\n      });\n      disposeSupport.attach(input, \"blur\", function () {\n        qq(options.element).removeClass(options.focusClass);\n      });\n      return input;\n    }\n\n    qq(options.element).css({\n      position: \"relative\",\n      overflow: \"hidden\",\n      direction: \"ltr\"\n    });\n    qq.extend(this, {\n      getInput: function () {\n        return input;\n      },\n      getButtonId: function () {\n        return buttonId;\n      },\n      setMultiple: function (isMultiple, optInput) {\n        var input = optInput || this.getInput();\n\n        if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n          input.setAttribute(\"multiple\", \"\");\n        } else {\n          if (isMultiple) {\n            input.setAttribute(\"multiple\", \"\");\n          } else {\n            input.removeAttribute(\"multiple\");\n          }\n        }\n      },\n      setAcceptFiles: function (acceptFiles) {\n        if (acceptFiles !== options.acceptFiles) {\n          input.setAttribute(\"accept\", acceptFiles);\n        }\n      },\n      reset: function () {\n        if (input.parentNode) {\n          qq(input).remove();\n        }\n\n        qq(options.element).removeClass(options.focusClass);\n        input = null;\n        input = createInput();\n      }\n    });\n    input = createInput();\n  };\n\n  qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n\n  qq.UploadData = function (uploaderProxy) {\n    \"use strict\";\n\n    var data = [],\n        byUuid = {},\n        byStatus = {},\n        byProxyGroupId = {},\n        byBatchId = {};\n\n    function getDataByIds(idOrIds) {\n      if (qq.isArray(idOrIds)) {\n        var entries = [];\n        qq.each(idOrIds, function (idx, id) {\n          entries.push(data[id]);\n        });\n        return entries;\n      }\n\n      return data[idOrIds];\n    }\n\n    function getDataByUuids(uuids) {\n      if (qq.isArray(uuids)) {\n        var entries = [];\n        qq.each(uuids, function (idx, uuid) {\n          entries.push(data[byUuid[uuid]]);\n        });\n        return entries;\n      }\n\n      return data[byUuid[uuids]];\n    }\n\n    function getDataByStatus(status) {\n      var statusResults = [],\n          statuses = [].concat(status);\n      qq.each(statuses, function (index, statusEnum) {\n        var statusResultIndexes = byStatus[statusEnum];\n\n        if (statusResultIndexes !== undefined) {\n          qq.each(statusResultIndexes, function (i, dataIndex) {\n            statusResults.push(data[dataIndex]);\n          });\n        }\n      });\n      return statusResults;\n    }\n\n    qq.extend(this, {\n      addFile: function (spec) {\n        var status = spec.status || qq.status.SUBMITTING,\n            id = data.push({\n          name: spec.name,\n          originalName: spec.name,\n          uuid: spec.uuid,\n          size: spec.size == null ? -1 : spec.size,\n          status: status,\n          file: spec.file\n        }) - 1;\n\n        if (spec.batchId) {\n          data[id].batchId = spec.batchId;\n\n          if (byBatchId[spec.batchId] === undefined) {\n            byBatchId[spec.batchId] = [];\n          }\n\n          byBatchId[spec.batchId].push(id);\n        }\n\n        if (spec.proxyGroupId) {\n          data[id].proxyGroupId = spec.proxyGroupId;\n\n          if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n            byProxyGroupId[spec.proxyGroupId] = [];\n          }\n\n          byProxyGroupId[spec.proxyGroupId].push(id);\n        }\n\n        data[id].id = id;\n        byUuid[spec.uuid] = id;\n\n        if (byStatus[status] === undefined) {\n          byStatus[status] = [];\n        }\n\n        byStatus[status].push(id);\n        spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n        uploaderProxy.onStatusChange(id, null, status);\n        return id;\n      },\n      retrieve: function (optionalFilter) {\n        if (qq.isObject(optionalFilter) && data.length) {\n          if (optionalFilter.id !== undefined) {\n            return getDataByIds(optionalFilter.id);\n          } else if (optionalFilter.uuid !== undefined) {\n            return getDataByUuids(optionalFilter.uuid);\n          } else if (optionalFilter.status) {\n            return getDataByStatus(optionalFilter.status);\n          }\n        } else {\n          return qq.extend([], data, true);\n        }\n      },\n      removeFileRef: function (id) {\n        var record = getDataByIds(id);\n\n        if (record) {\n          delete record.file;\n        }\n      },\n      reset: function () {\n        data = [];\n        byUuid = {};\n        byStatus = {};\n        byBatchId = {};\n      },\n      setStatus: function (id, newStatus) {\n        var oldStatus = data[id].status,\n            byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n        byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n        data[id].status = newStatus;\n\n        if (byStatus[newStatus] === undefined) {\n          byStatus[newStatus] = [];\n        }\n\n        byStatus[newStatus].push(id);\n        uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n      },\n      uuidChanged: function (id, newUuid) {\n        var oldUuid = data[id].uuid;\n        data[id].uuid = newUuid;\n        byUuid[newUuid] = id;\n        delete byUuid[oldUuid];\n      },\n      updateName: function (id, newName) {\n        data[id].name = newName;\n      },\n      updateSize: function (id, newSize) {\n        data[id].size = newSize;\n      },\n      setParentId: function (targetId, parentId) {\n        data[targetId].parentId = parentId;\n      },\n      getIdsInProxyGroup: function (id) {\n        var proxyGroupId = data[id].proxyGroupId;\n\n        if (proxyGroupId) {\n          return byProxyGroupId[proxyGroupId];\n        }\n\n        return [];\n      },\n      getIdsInBatch: function (id) {\n        var batchId = data[id].batchId;\n        return byBatchId[batchId];\n      }\n    });\n  };\n\n  qq.status = {\n    SUBMITTING: \"submitting\",\n    SUBMITTED: \"submitted\",\n    REJECTED: \"rejected\",\n    QUEUED: \"queued\",\n    CANCELED: \"canceled\",\n    PAUSED: \"paused\",\n    UPLOADING: \"uploading\",\n    UPLOAD_FINALIZING: \"upload finalizing\",\n    UPLOAD_RETRYING: \"retrying upload\",\n    UPLOAD_SUCCESSFUL: \"upload successful\",\n    UPLOAD_FAILED: \"upload failed\",\n    DELETE_FAILED: \"delete failed\",\n    DELETING: \"deleting\",\n    DELETED: \"deleted\"\n  };\n\n  (function () {\n    \"use strict\";\n\n    qq.basePublicApi = {\n      addBlobs: function (blobDataOrArray, params, endpoint) {\n        this.addFiles(blobDataOrArray, params, endpoint);\n      },\n      addInitialFiles: function (cannedFileList) {\n        var self = this;\n        qq.each(cannedFileList, function (index, cannedFile) {\n          self._addCannedFile(cannedFile);\n        });\n      },\n      addFiles: function (data, params, endpoint) {\n        this._maybeHandleIos8SafariWorkaround();\n\n        var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId,\n            processBlob = qq.bind(function (blob) {\n          this._handleNewFile({\n            blob: blob,\n            name: this._options.blobs.defaultName\n          }, batchId, verifiedFiles);\n        }, this),\n            processBlobData = qq.bind(function (blobData) {\n          this._handleNewFile(blobData, batchId, verifiedFiles);\n        }, this),\n            processCanvas = qq.bind(function (canvas) {\n          var blob = qq.canvasToBlob(canvas);\n\n          this._handleNewFile({\n            blob: blob,\n            name: this._options.blobs.defaultName + \".png\"\n          }, batchId, verifiedFiles);\n        }, this),\n            processCanvasData = qq.bind(function (canvasData) {\n          var normalizedQuality = canvasData.quality && canvasData.quality / 100,\n              blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n\n          this._handleNewFile({\n            blob: blob,\n            name: canvasData.name\n          }, batchId, verifiedFiles);\n        }, this),\n            processFileOrInput = qq.bind(function (fileOrInput) {\n          if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n            var files = Array.prototype.slice.call(fileOrInput.files),\n                self = this;\n            qq.each(files, function (idx, file) {\n              self._handleNewFile(file, batchId, verifiedFiles);\n            });\n          } else {\n            this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n          }\n        }, this),\n            normalizeData = function () {\n          if (qq.isFileList(data)) {\n            data = Array.prototype.slice.call(data);\n          }\n\n          data = [].concat(data);\n        },\n            self = this,\n            verifiedFiles = [];\n\n        this._currentBatchId = batchId;\n\n        if (data) {\n          normalizeData();\n          qq.each(data, function (idx, fileContainer) {\n            if (qq.isFileOrInput(fileContainer)) {\n              processFileOrInput(fileContainer);\n            } else if (qq.isBlob(fileContainer)) {\n              processBlob(fileContainer);\n            } else if (qq.isObject(fileContainer)) {\n              if (fileContainer.blob && fileContainer.name) {\n                processBlobData(fileContainer);\n              } else if (fileContainer.canvas && fileContainer.name) {\n                processCanvasData(fileContainer);\n              }\n            } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n              processCanvas(fileContainer);\n            } else {\n              self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n            }\n          });\n          this.log(\"Received \" + verifiedFiles.length + \" files.\");\n\n          this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n        }\n      },\n      cancel: function (id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n\n        if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n          this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n        } else {\n          this._handler.cancel(id);\n        }\n      },\n      cancelAll: function () {\n        var storedIdsCopy = [],\n            self = this;\n        qq.extend(storedIdsCopy, this._storedIds);\n        qq.each(storedIdsCopy, function (idx, storedFileId) {\n          self.cancel(storedFileId);\n        });\n\n        this._handler.cancelAll();\n      },\n      clearStoredFiles: function () {\n        this._storedIds = [];\n      },\n      continueUpload: function (id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n\n        if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n          return false;\n        }\n\n        if (uploadData.status === qq.status.PAUSED) {\n          this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n\n          this._uploadFile(id);\n\n          return true;\n        } else {\n          this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n        }\n\n        return false;\n      },\n      deleteFile: function (id) {\n        return this._onSubmitDelete(id);\n      },\n      doesExist: function (fileOrBlobId) {\n        return this._handler.isValid(fileOrBlobId);\n      },\n      drawThumbnail: function (fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n        var promiseToReturn = new qq.Promise(),\n            fileOrUrl,\n            options;\n\n        if (this._imageGenerator) {\n          fileOrUrl = this._thumbnailUrls[fileId];\n          options = {\n            customResizeFunction: customResizeFunction,\n            maxSize: maxSize > 0 ? maxSize : null,\n            scale: maxSize > 0\n          };\n\n          if (!fromServer && qq.supportedFeatures.imagePreviews) {\n            fileOrUrl = this.getFile(fileId);\n          }\n\n          if (fileOrUrl == null) {\n            promiseToReturn.failure({\n              container: imgOrCanvas,\n              error: \"File or URL not found.\"\n            });\n          } else {\n            this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n              promiseToReturn.success(modifiedContainer);\n            }, function failure(container, reason) {\n              promiseToReturn.failure({\n                container: container,\n                error: reason || \"Problem generating thumbnail\"\n              });\n            });\n          }\n        } else {\n          promiseToReturn.failure({\n            container: imgOrCanvas,\n            error: \"Missing image generator module\"\n          });\n        }\n\n        return promiseToReturn;\n      },\n      getButton: function (fileId) {\n        return this._getButton(this._buttonIdsForFileIds[fileId]);\n      },\n      getEndpoint: function (fileId) {\n        return this._endpointStore.get(fileId);\n      },\n      getFile: function (fileOrBlobId) {\n        var file = this._handler.getFile(fileOrBlobId);\n\n        var uploadDataRecord;\n\n        if (!file) {\n          uploadDataRecord = this._uploadData.retrieve({\n            id: fileOrBlobId\n          });\n\n          if (uploadDataRecord) {\n            file = uploadDataRecord.file;\n          }\n        }\n\n        return file || null;\n      },\n      getInProgress: function () {\n        return this._uploadData.retrieve({\n          status: [qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED]\n        }).length;\n      },\n      getName: function (id) {\n        return this._uploadData.retrieve({\n          id: id\n        }).name;\n      },\n      getParentId: function (id) {\n        var uploadDataEntry = this.getUploads({\n          id: id\n        }),\n            parentId = null;\n\n        if (uploadDataEntry) {\n          if (uploadDataEntry.parentId !== undefined) {\n            parentId = uploadDataEntry.parentId;\n          }\n        }\n\n        return parentId;\n      },\n      getResumableFilesData: function () {\n        return this._handler.getResumableFilesData();\n      },\n      getSize: function (id) {\n        return this._uploadData.retrieve({\n          id: id\n        }).size;\n      },\n      getNetUploads: function () {\n        return this._netUploaded;\n      },\n      getRemainingAllowedItems: function () {\n        var allowedItems = this._currentItemLimit;\n\n        if (allowedItems > 0) {\n          return allowedItems - this._netUploadedOrQueued;\n        }\n\n        return null;\n      },\n      getUploads: function (optionalFilter) {\n        return this._uploadData.retrieve(optionalFilter);\n      },\n      getUuid: function (id) {\n        return this._uploadData.retrieve({\n          id: id\n        }).uuid;\n      },\n      isResumable: function (id) {\n        return this._handler.hasResumeRecord(id);\n      },\n      log: function (str, level) {\n        if (this._options.debug && (!level || level === \"info\")) {\n          qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n        } else if (level && level !== \"info\") {\n          qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n        }\n      },\n      pauseUpload: function (id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n\n        if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n          return false;\n        }\n\n        if (qq.indexOf([qq.status.UPLOADING, qq.status.UPLOAD_RETRYING], uploadData.status) >= 0) {\n          if (this._handler.pause(id)) {\n            this._uploadData.setStatus(id, qq.status.PAUSED);\n\n            return true;\n          } else {\n            this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n          }\n        } else {\n          this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n        }\n\n        return false;\n      },\n      removeFileRef: function (id) {\n        this._handler.expunge(id);\n\n        this._uploadData.removeFileRef(id);\n      },\n      reset: function () {\n        this.log(\"Resetting uploader...\");\n\n        this._handler.reset();\n\n        this._storedIds = [];\n        this._autoRetries = [];\n        this._retryTimeouts = [];\n        this._preventRetries = [];\n        this._thumbnailUrls = [];\n        qq.each(this._buttons, function (idx, button) {\n          button.reset();\n        });\n\n        this._paramsStore.reset();\n\n        this._endpointStore.reset();\n\n        this._netUploadedOrQueued = 0;\n        this._netUploaded = 0;\n\n        this._uploadData.reset();\n\n        this._buttonIdsForFileIds = [];\n        this._pasteHandler && this._pasteHandler.reset();\n        this._options.session.refreshOnReset && this._refreshSessionData();\n        this._succeededSinceLastAllComplete = [];\n        this._failedSinceLastAllComplete = [];\n        this._totalProgress && this._totalProgress.reset();\n\n        this._customResumeDataStore.reset();\n      },\n      retry: function (id) {\n        return this._manualRetry(id);\n      },\n      scaleImage: function (id, specs) {\n        var self = this;\n        return qq.Scaler.prototype.scaleImage(id, specs, {\n          log: qq.bind(self.log, self),\n          getFile: qq.bind(self.getFile, self),\n          uploadData: self._uploadData\n        });\n      },\n      setCustomHeaders: function (headers, id) {\n        this._customHeadersStore.set(headers, id);\n      },\n      setCustomResumeData: function (id, data) {\n        this._customResumeDataStore.set(data, id);\n      },\n      setDeleteFileCustomHeaders: function (headers, id) {\n        this._deleteFileCustomHeadersStore.set(headers, id);\n      },\n      setDeleteFileEndpoint: function (endpoint, id) {\n        this._deleteFileEndpointStore.set(endpoint, id);\n      },\n      setDeleteFileParams: function (params, id) {\n        this._deleteFileParamsStore.set(params, id);\n      },\n      setEndpoint: function (endpoint, id) {\n        this._endpointStore.set(endpoint, id);\n      },\n      setForm: function (elementOrId) {\n        this._updateFormSupportAndParams(elementOrId);\n      },\n      setItemLimit: function (newItemLimit) {\n        this._currentItemLimit = newItemLimit;\n      },\n      setName: function (id, newName) {\n        this._uploadData.updateName(id, newName);\n      },\n      setParams: function (params, id) {\n        this._paramsStore.set(params, id);\n      },\n      setUuid: function (id, newUuid) {\n        return this._uploadData.uuidChanged(id, newUuid);\n      },\n      setStatus: function (id, newStatus) {\n        var fileRecord = this.getUploads({\n          id: id\n        });\n\n        if (!fileRecord) {\n          throw new qq.Error(id + \" is not a valid file ID.\");\n        }\n\n        switch (newStatus) {\n          case qq.status.DELETED:\n            this._onDeleteComplete(id, null, false);\n\n            break;\n\n          case qq.status.DELETE_FAILED:\n            this._onDeleteComplete(id, null, true);\n\n            break;\n\n          default:\n            var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n            this.log(errorMessage);\n            throw new qq.Error(errorMessage);\n        }\n      },\n      uploadStoredFiles: function () {\n        if (this._storedIds.length === 0) {\n          this._itemError(\"noFilesError\");\n        } else {\n          this._uploadStoredFiles();\n        }\n      }\n    };\n    qq.basePrivateApi = {\n      _addCannedFile: function (sessionData) {\n        var self = this;\n        return this._uploadData.addFile({\n          uuid: sessionData.uuid,\n          name: sessionData.name,\n          size: sessionData.size,\n          status: qq.status.UPLOAD_SUCCESSFUL,\n          onBeforeStatusChange: function (id) {\n            sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n            sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n\n            if (sessionData.thumbnailUrl) {\n              self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n            }\n\n            self._netUploaded++;\n            self._netUploadedOrQueued++;\n          }\n        });\n      },\n      _annotateWithButtonId: function (file, associatedInput) {\n        if (qq.isFile(file)) {\n          file.qqButtonId = this._getButtonId(associatedInput);\n        }\n      },\n      _batchError: function (message) {\n        this._options.callbacks.onError(null, null, message, undefined);\n      },\n      _createDeleteHandler: function () {\n        var self = this;\n        return new qq.DeleteFileAjaxRequester({\n          method: this._options.deleteFile.method.toUpperCase(),\n          maxConnections: this._options.maxConnections,\n          uuidParamName: this._options.request.uuidName,\n          customHeaders: this._deleteFileCustomHeadersStore,\n          paramsStore: this._deleteFileParamsStore,\n          endpointStore: this._deleteFileEndpointStore,\n          cors: this._options.cors,\n          log: qq.bind(self.log, self),\n          onDelete: function (id) {\n            self._onDelete(id);\n\n            self._options.callbacks.onDelete(id);\n          },\n          onDeleteComplete: function (id, xhrOrXdr, isError) {\n            self._onDeleteComplete(id, xhrOrXdr, isError);\n\n            self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n          }\n        });\n      },\n      _createPasteHandler: function () {\n        var self = this;\n        return new qq.PasteSupport({\n          targetElement: this._options.paste.targetElement,\n          callbacks: {\n            log: qq.bind(self.log, self),\n            pasteReceived: function (blob) {\n              self._handleCheckedCallback({\n                name: \"onPasteReceived\",\n                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                identifier: \"pasted image\"\n              });\n            }\n          }\n        });\n      },\n      _createStore: function (initialValue, _readOnlyValues_) {\n        var store = {},\n            catchall = initialValue,\n            perIdReadOnlyValues = {},\n            readOnlyValues = _readOnlyValues_,\n            copy = function (orig) {\n          if (qq.isObject(orig)) {\n            return qq.extend({}, orig);\n          }\n\n          return orig;\n        },\n            getReadOnlyValues = function () {\n          if (qq.isFunction(readOnlyValues)) {\n            return readOnlyValues();\n          }\n\n          return readOnlyValues;\n        },\n            includeReadOnlyValues = function (id, existing) {\n          if (readOnlyValues && qq.isObject(existing)) {\n            qq.extend(existing, getReadOnlyValues());\n          }\n\n          if (perIdReadOnlyValues[id]) {\n            qq.extend(existing, perIdReadOnlyValues[id]);\n          }\n        };\n\n        return {\n          set: function (val, id) {\n            if (id == null) {\n              store = {};\n              catchall = copy(val);\n            } else {\n              store[id] = copy(val);\n            }\n          },\n          get: function (id) {\n            var values;\n\n            if (id != null && store[id]) {\n              values = store[id];\n            } else {\n              values = copy(catchall);\n            }\n\n            includeReadOnlyValues(id, values);\n            return copy(values);\n          },\n          addReadOnly: function (id, values) {\n            if (qq.isObject(store)) {\n              if (id === null) {\n                if (qq.isFunction(values)) {\n                  readOnlyValues = values;\n                } else {\n                  readOnlyValues = readOnlyValues || {};\n                  qq.extend(readOnlyValues, values);\n                }\n              } else {\n                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                qq.extend(perIdReadOnlyValues[id], values);\n              }\n            }\n          },\n          remove: function (fileId) {\n            return delete store[fileId];\n          },\n          reset: function () {\n            store = {};\n            perIdReadOnlyValues = {};\n            catchall = initialValue;\n          }\n        };\n      },\n      _createUploadDataTracker: function () {\n        var self = this;\n        return new qq.UploadData({\n          getName: function (id) {\n            return self.getName(id);\n          },\n          getUuid: function (id) {\n            return self.getUuid(id);\n          },\n          getSize: function (id) {\n            return self.getSize(id);\n          },\n          onStatusChange: function (id, oldStatus, newStatus) {\n            self._onUploadStatusChange(id, oldStatus, newStatus);\n\n            self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n\n            self._maybeAllComplete(id, newStatus);\n\n            if (self._totalProgress) {\n              setTimeout(function () {\n                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n              }, 0);\n            }\n          }\n        });\n      },\n      _createUploadButton: function (spec) {\n        var self = this,\n            acceptFiles = spec.accept || this._options.validation.acceptFiles,\n            allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions,\n            button;\n\n        function allowMultiple() {\n          if (qq.supportedFeatures.ajaxUploading) {\n            if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n              return false;\n            }\n\n            if (spec.multiple === undefined) {\n              return self._options.multiple;\n            }\n\n            return spec.multiple;\n          }\n\n          return false;\n        }\n\n        button = new qq.UploadButton({\n          acceptFiles: acceptFiles,\n          element: spec.element,\n          focusClass: this._options.classes.buttonFocus,\n          folders: spec.folders,\n          hoverClass: this._options.classes.buttonHover,\n          ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n          multiple: allowMultiple(),\n          name: this._options.request.inputName,\n          onChange: function (input) {\n            self._onInputChange(input);\n          },\n          title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n        });\n\n        this._disposeSupport.addDisposer(function () {\n          button.dispose();\n        });\n\n        self._buttons.push(button);\n\n        return button;\n      },\n      _createUploadHandler: function (additionalOptions, namespace) {\n        var self = this,\n            lastOnProgress = {},\n            options = {\n          debug: this._options.debug,\n          maxConnections: this._options.maxConnections,\n          cors: this._options.cors,\n          paramsStore: this._paramsStore,\n          endpointStore: this._endpointStore,\n          chunking: this._options.chunking,\n          resume: this._options.resume,\n          blobs: this._options.blobs,\n          log: qq.bind(self.log, self),\n          preventRetryParam: this._options.retry.preventRetryResponseProperty,\n          onProgress: function (id, name, loaded, total) {\n            if (loaded < 0 || total < 0) {\n              return;\n            }\n\n            if (lastOnProgress[id]) {\n              if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                self._onProgress(id, name, loaded, total);\n\n                self._options.callbacks.onProgress(id, name, loaded, total);\n              }\n            } else {\n              self._onProgress(id, name, loaded, total);\n\n              self._options.callbacks.onProgress(id, name, loaded, total);\n            }\n\n            lastOnProgress[id] = {\n              loaded: loaded,\n              total: total\n            };\n          },\n          onComplete: function (id, name, result, xhr) {\n            delete lastOnProgress[id];\n            var status = self.getUploads({\n              id: id\n            }).status,\n                retVal;\n\n            if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n              return;\n            }\n\n            retVal = self._onComplete(id, name, result, xhr);\n\n            if (retVal instanceof qq.Promise) {\n              retVal.done(function () {\n                self._options.callbacks.onComplete(id, name, result, xhr);\n              });\n            } else {\n              self._options.callbacks.onComplete(id, name, result, xhr);\n            }\n          },\n          onCancel: function (id, name, cancelFinalizationEffort) {\n            var promise = new qq.Promise();\n\n            self._handleCheckedCallback({\n              name: \"onCancel\",\n              callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n              onFailure: promise.failure,\n              onSuccess: function () {\n                cancelFinalizationEffort.then(function () {\n                  self._onCancel(id, name);\n                });\n                promise.success();\n              },\n              identifier: id\n            });\n\n            return promise;\n          },\n          onUploadPrep: qq.bind(this._onUploadPrep, this),\n          onUpload: function (id, name) {\n            self._onUpload(id, name);\n\n            var onUploadResult = self._options.callbacks.onUpload(id, name);\n\n            if (qq.isGenericPromise(onUploadResult)) {\n              self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n              return onUploadResult;\n            }\n\n            return new qq.Promise().success();\n          },\n          onUploadChunk: function (id, name, chunkData) {\n            self._onUploadChunk(id, chunkData);\n\n            var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n\n            if (qq.isGenericPromise(onUploadChunkResult)) {\n              self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n              return onUploadChunkResult;\n            }\n\n            return new qq.Promise().success();\n          },\n          onUploadChunkSuccess: function (id, chunkData, result, xhr) {\n            self._onUploadChunkSuccess(id, chunkData);\n\n            self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n          },\n          onResume: function (id, name, chunkData, customResumeData) {\n            return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n          },\n          onAutoRetry: function (id, name, responseJSON, xhr) {\n            return self._onAutoRetry.apply(self, arguments);\n          },\n          onUuidChanged: function (id, newUuid) {\n            self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n            self.setUuid(id, newUuid);\n          },\n          getName: qq.bind(self.getName, self),\n          getUuid: qq.bind(self.getUuid, self),\n          getSize: qq.bind(self.getSize, self),\n          setSize: qq.bind(self._setSize, self),\n          getDataByUuid: function (uuid) {\n            return self.getUploads({\n              uuid: uuid\n            });\n          },\n          isQueued: function (id) {\n            var status = self.getUploads({\n              id: id\n            }).status;\n            return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n          },\n          getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n          getIdsInBatch: self._uploadData.getIdsInBatch,\n          isInProgress: function (id) {\n            return self.getUploads({\n              id: id\n            }).status === qq.status.UPLOADING;\n          },\n          getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n          setStatus: function (id, status) {\n            self._uploadData.setStatus(id, status);\n          }\n        };\n        qq.each(this._options.request, function (prop, val) {\n          options[prop] = val;\n        });\n        options.customHeaders = this._customHeadersStore;\n\n        if (additionalOptions) {\n          qq.each(additionalOptions, function (key, val) {\n            options[key] = val;\n          });\n        }\n\n        return new qq.UploadHandlerController(options, namespace);\n      },\n      _fileOrBlobRejected: function (id) {\n        this._netUploadedOrQueued--;\n\n        this._uploadData.setStatus(id, qq.status.REJECTED);\n      },\n      _formatSize: function (bytes) {\n        if (bytes === 0) {\n          return bytes + this._options.text.sizeSymbols[0];\n        }\n\n        var i = -1;\n\n        do {\n          bytes = bytes / 1e3;\n          i++;\n        } while (bytes > 999);\n\n        return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n      },\n      _generateExtraButtonSpecs: function () {\n        var self = this;\n        this._extraButtonSpecs = {};\n        qq.each(this._options.extraButtons, function (idx, extraButtonOptionEntry) {\n          var multiple = extraButtonOptionEntry.multiple,\n              validation = qq.extend({}, self._options.validation, true),\n              extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n\n          if (multiple === undefined) {\n            multiple = self._options.multiple;\n          }\n\n          if (extraButtonSpec.validation) {\n            qq.extend(validation, extraButtonOptionEntry.validation, true);\n          }\n\n          qq.extend(extraButtonSpec, {\n            multiple: multiple,\n            validation: validation\n          }, true);\n\n          self._initExtraButton(extraButtonSpec);\n        });\n      },\n      _getButton: function (buttonId) {\n        var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n\n        if (extraButtonsSpec) {\n          return extraButtonsSpec.element;\n        } else if (buttonId === this._defaultButtonId) {\n          return this._options.button;\n        }\n      },\n      _getButtonId: function (buttonOrFileInputOrFile) {\n        var inputs,\n            fileInput,\n            fileBlobOrInput = buttonOrFileInputOrFile;\n\n        if (fileBlobOrInput instanceof qq.BlobProxy) {\n          fileBlobOrInput = fileBlobOrInput.referenceBlob;\n        }\n\n        if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n          if (qq.isFile(fileBlobOrInput)) {\n            return fileBlobOrInput.qqButtonId;\n          } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n            return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n          }\n\n          inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n          qq.each(inputs, function (idx, input) {\n            if (input.getAttribute(\"type\") === \"file\") {\n              fileInput = input;\n              return false;\n            }\n          });\n\n          if (fileInput) {\n            return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n          }\n        }\n      },\n      _getCustomResumeData: function (fileId) {\n        return this._customResumeDataStore.get(fileId);\n      },\n      _getNotFinished: function () {\n        return this._uploadData.retrieve({\n          status: [qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED]\n        }).length;\n      },\n      _getValidationBase: function (buttonId) {\n        var extraButtonSpec = this._extraButtonSpecs[buttonId];\n        return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n      },\n      _getValidationDescriptor: function (fileWrapper) {\n        if (fileWrapper.file instanceof qq.BlobProxy) {\n          return {\n            name: qq.getFilename(fileWrapper.file.referenceBlob),\n            size: fileWrapper.file.referenceBlob.size\n          };\n        }\n\n        return {\n          name: this.getUploads({\n            id: fileWrapper.id\n          }).name,\n          size: this.getUploads({\n            id: fileWrapper.id\n          }).size\n        };\n      },\n      _getValidationDescriptors: function (fileWrappers) {\n        var self = this,\n            fileDescriptors = [];\n        qq.each(fileWrappers, function (idx, fileWrapper) {\n          fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n        });\n        return fileDescriptors;\n      },\n      _handleCameraAccess: function () {\n        if (this._options.camera.ios && qq.ios()) {\n          var acceptIosCamera = \"image/*;capture=camera\",\n              button = this._options.camera.button,\n              buttonId = button ? this._getButtonId(button) : this._defaultButtonId,\n              optionRoot = this._options;\n\n          if (buttonId && buttonId !== this._defaultButtonId) {\n            optionRoot = this._extraButtonSpecs[buttonId];\n          }\n\n          optionRoot.multiple = false;\n\n          if (optionRoot.validation.acceptFiles === null) {\n            optionRoot.validation.acceptFiles = acceptIosCamera;\n          } else {\n            optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n          }\n\n          qq.each(this._buttons, function (idx, button) {\n            if (button.getButtonId() === buttonId) {\n              button.setMultiple(optionRoot.multiple);\n              button.setAcceptFiles(optionRoot.acceptFiles);\n              return false;\n            }\n          });\n        }\n      },\n      _handleCheckedCallback: function (details) {\n        var self = this,\n            callbackRetVal = details.callback();\n\n        if (qq.isGenericPromise(callbackRetVal)) {\n          this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n          return callbackRetVal.then(function (successParam) {\n            self.log(details.name + \" promise success for \" + details.identifier);\n            details.onSuccess(successParam);\n          }, function () {\n            if (details.onFailure) {\n              self.log(details.name + \" promise failure for \" + details.identifier);\n              details.onFailure();\n            } else {\n              self.log(details.name + \" promise failure for \" + details.identifier);\n            }\n          });\n        }\n\n        if (callbackRetVal !== false) {\n          details.onSuccess(callbackRetVal);\n        } else {\n          if (details.onFailure) {\n            this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n            details.onFailure();\n          } else {\n            this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n          }\n        }\n\n        return callbackRetVal;\n      },\n      _handleNewFile: function (file, batchId, newFileWrapperList) {\n        var self = this,\n            uuid = qq.getUniqueId(),\n            size = -1,\n            name = qq.getFilename(file),\n            actualFile = file.blob || file,\n            handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n\n        if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n          size = actualFile.size;\n        }\n\n        handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n          uploadData: self._uploadData,\n          paramsStore: self._paramsStore,\n          addFileToHandler: function (id, file) {\n            self._handler.add(id, file);\n\n            self._netUploadedOrQueued++;\n\n            self._trackButton(id);\n          }\n        });\n      },\n      _handleNewFileGeneric: function (file, name, uuid, size, fileList, batchId) {\n        var id = this._uploadData.addFile({\n          uuid: uuid,\n          name: name,\n          size: size,\n          batchId: batchId,\n          file: file\n        });\n\n        this._handler.add(id, file);\n\n        this._trackButton(id);\n\n        this._netUploadedOrQueued++;\n        fileList.push({\n          id: id,\n          file: file\n        });\n      },\n      _handlePasteSuccess: function (blob, extSuppliedName) {\n        var extension = blob.type.split(\"/\")[1],\n            name = extSuppliedName;\n\n        if (name == null) {\n          name = this._options.paste.defaultName;\n        }\n\n        name += \".\" + extension;\n        this.addFiles({\n          name: name,\n          blob: blob\n        });\n      },\n      _handleDeleteSuccess: function (id) {\n        if (this.getUploads({\n          id: id\n        }).status !== qq.status.DELETED) {\n          var name = this.getName(id);\n          this._netUploadedOrQueued--;\n          this._netUploaded--;\n\n          this._handler.expunge(id);\n\n          this._uploadData.setStatus(id, qq.status.DELETED);\n\n          this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n        }\n      },\n      _handleDeleteFailed: function (id, xhrOrXdr) {\n        var name = this.getName(id);\n\n        this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n\n        this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n\n        if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n          this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n        } else {\n          this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n        }\n      },\n      _initExtraButton: function (spec) {\n        var button = this._createUploadButton({\n          accept: spec.validation.acceptFiles,\n          allowedExtensions: spec.validation.allowedExtensions,\n          element: spec.element,\n          folders: spec.folders,\n          multiple: spec.multiple,\n          title: spec.fileInputTitle\n        });\n\n        this._extraButtonSpecs[button.getButtonId()] = spec;\n      },\n      _initFormSupportAndParams: function () {\n        this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n\n        if (this._formSupport && this._formSupport.attachedToForm) {\n          this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n          this._options.autoUpload = this._formSupport.newAutoUpload;\n\n          if (this._formSupport.newEndpoint) {\n            this._options.request.endpoint = this._formSupport.newEndpoint;\n          }\n        } else {\n          this._paramsStore = this._createStore(this._options.request.params);\n        }\n      },\n      _isDeletePossible: function () {\n        if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n          return false;\n        }\n\n        if (this._options.cors.expected) {\n          if (qq.supportedFeatures.deleteFileCorsXhr) {\n            return true;\n          }\n\n          if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n            return true;\n          }\n\n          return false;\n        }\n\n        return true;\n      },\n      _isAllowedExtension: function (allowed, fileName) {\n        var valid = false;\n\n        if (!allowed.length) {\n          return true;\n        }\n\n        qq.each(allowed, function (idx, allowedExt) {\n          if (qq.isString(allowedExt)) {\n            var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n\n            if (fileName.match(extRegex) != null) {\n              valid = true;\n              return false;\n            }\n          }\n        });\n        return valid;\n      },\n      _itemError: function (code, maybeNameOrNames, item) {\n        var message = this._options.messages[code],\n            allowedExtensions = [],\n            names = [].concat(maybeNameOrNames),\n            name = names[0],\n            buttonId = this._getButtonId(item),\n            validationBase = this._getValidationBase(buttonId),\n            extensionsForMessage,\n            placeholderMatch;\n\n        function r(name, replacement) {\n          message = message.replace(name, replacement);\n        }\n\n        qq.each(validationBase.allowedExtensions, function (idx, allowedExtension) {\n          if (qq.isString(allowedExtension)) {\n            allowedExtensions.push(allowedExtension);\n          }\n        });\n        extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n        r(\"{file}\", this._options.formatFileName(name));\n        r(\"{extensions}\", extensionsForMessage);\n        r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n        r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n        placeholderMatch = message.match(/(\\{\\w+\\})/g);\n\n        if (placeholderMatch !== null) {\n          qq.each(placeholderMatch, function (idx, placeholder) {\n            r(placeholder, names[idx]);\n          });\n        }\n\n        this._options.callbacks.onError(null, name, message, undefined);\n\n        return message;\n      },\n      _manualRetry: function (id, callback) {\n        if (this._onBeforeManualRetry(id)) {\n          this._netUploadedOrQueued++;\n\n          this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n\n          if (callback) {\n            callback(id);\n          } else {\n            this._handler.retry(id);\n          }\n\n          return true;\n        }\n      },\n      _maybeAllComplete: function (id, status) {\n        var self = this,\n            notFinished = this._getNotFinished();\n\n        if (status === qq.status.UPLOAD_SUCCESSFUL) {\n          this._succeededSinceLastAllComplete.push(id);\n        } else if (status === qq.status.UPLOAD_FAILED) {\n          this._failedSinceLastAllComplete.push(id);\n        }\n\n        if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n          setTimeout(function () {\n            self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n          }, 0);\n        }\n      },\n      _maybeHandleIos8SafariWorkaround: function () {\n        var self = this;\n\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n          setTimeout(function () {\n            window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n          }, 0);\n          throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n        }\n      },\n      _maybeParseAndSendUploadError: function (id, name, response, xhr) {\n        if (!response.success) {\n          if (xhr && xhr.status !== 200 && !response.error) {\n            this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n          } else {\n            var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n\n            this._options.callbacks.onError(id, name, errorReason, xhr);\n          }\n        }\n      },\n      _maybeProcessNextItemAfterOnValidateCallback: function (validItem, items, index, params, endpoint) {\n        var self = this;\n\n        if (items.length > index) {\n          if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n            setTimeout(function () {\n              var validationDescriptor = self._getValidationDescriptor(items[index]),\n                  buttonId = self._getButtonId(items[index].file),\n                  button = self._getButton(buttonId);\n\n              self._handleCheckedCallback({\n                name: \"onValidate\",\n                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n              });\n            }, 0);\n          } else if (!validItem) {\n            for (; index < items.length; index++) {\n              self._fileOrBlobRejected(items[index].id);\n            }\n          }\n        }\n      },\n      _onAllComplete: function (successful, failed) {\n        this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n\n        this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n\n        this._succeededSinceLastAllComplete = [];\n        this._failedSinceLastAllComplete = [];\n      },\n      _onAutoRetry: function (id, name, responseJSON, xhr, callback) {\n        var self = this;\n        self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n\n        if (self._shouldAutoRetry(id)) {\n          var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n\n          self._maybeParseAndSendUploadError.apply(self, arguments);\n\n          self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n\n          self._onBeforeAutoRetry(id, name);\n\n          self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n\n          self._retryTimeouts[id] = setTimeout(function () {\n            self.log(\"Starting retry for \" + name + \"...\");\n\n            if (callback) {\n              callback(id);\n            } else {\n              self._handler.retry(id);\n            }\n          }, retryWaitPeriod);\n          return true;\n        }\n      },\n      _onBeforeAutoRetry: function (id, name) {\n        this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n      },\n      _onBeforeManualRetry: function (id) {\n        var itemLimit = this._currentItemLimit,\n            fileName;\n\n        if (this._preventRetries[id]) {\n          this.log(\"Retries are forbidden for id \" + id, \"warn\");\n          return false;\n        } else if (this._handler.isValid(id)) {\n          fileName = this.getName(id);\n\n          if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n            return false;\n          }\n\n          if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n            this._itemError(\"retryFailTooManyItems\");\n\n            return false;\n          }\n\n          this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n          return true;\n        } else {\n          this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n          return false;\n        }\n      },\n      _onCancel: function (id, name) {\n        this._netUploadedOrQueued--;\n        clearTimeout(this._retryTimeouts[id]);\n        var storedItemIndex = qq.indexOf(this._storedIds, id);\n\n        if (!this._options.autoUpload && storedItemIndex >= 0) {\n          this._storedIds.splice(storedItemIndex, 1);\n        }\n\n        this._uploadData.setStatus(id, qq.status.CANCELED);\n      },\n      _onComplete: function (id, name, result, xhr) {\n        if (!result.success) {\n          this._netUploadedOrQueued--;\n\n          this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n\n          if (result[this._options.retry.preventRetryResponseProperty] === true) {\n            this._preventRetries[id] = true;\n          }\n        } else {\n          if (result.thumbnailUrl) {\n            this._thumbnailUrls[id] = result.thumbnailUrl;\n          }\n\n          this._netUploaded++;\n\n          this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n        }\n\n        this._maybeParseAndSendUploadError(id, name, result, xhr);\n\n        return result.success ? true : false;\n      },\n      _onDelete: function (id) {\n        this._uploadData.setStatus(id, qq.status.DELETING);\n      },\n      _onDeleteComplete: function (id, xhrOrXdr, isError) {\n        var name = this.getName(id);\n\n        if (isError) {\n          this._handleDeleteFailed(id, xhrOrXdr);\n        } else {\n          this._handleDeleteSuccess(id);\n        }\n      },\n      _onInputChange: function (input) {\n        var fileIndex;\n\n        if (qq.supportedFeatures.ajaxUploading) {\n          for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n            this._annotateWithButtonId(input.files[fileIndex], input);\n          }\n\n          this.addFiles(input.files);\n        } else if (input.value.length > 0) {\n          this.addFiles(input);\n        }\n\n        qq.each(this._buttons, function (idx, button) {\n          button.reset();\n        });\n      },\n      _onProgress: function (id, name, loaded, total) {\n        this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n      },\n      _onSubmit: function (id, name) {},\n      _onSubmitCallbackSuccess: function (id, name) {\n        this._onSubmit.apply(this, arguments);\n\n        this._uploadData.setStatus(id, qq.status.SUBMITTED);\n\n        this._onSubmitted.apply(this, arguments);\n\n        if (this._options.autoUpload) {\n          this._options.callbacks.onSubmitted.apply(this, arguments);\n\n          this._uploadFile(id);\n        } else {\n          this._storeForLater(id);\n\n          this._options.callbacks.onSubmitted.apply(this, arguments);\n        }\n      },\n      _onSubmitDelete: function (id, onSuccessCallback, additionalMandatedParams) {\n        var uuid = this.getUuid(id),\n            adjustedOnSuccessCallback;\n\n        if (onSuccessCallback) {\n          adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n        }\n\n        if (this._isDeletePossible()) {\n          this._handleCheckedCallback({\n            name: \"onSubmitDelete\",\n            callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n            onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n            identifier: id\n          });\n\n          return true;\n        } else {\n          this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n          return false;\n        }\n      },\n      _onSubmitted: function (id) {},\n      _onTotalProgress: function (loaded, total) {\n        this._options.callbacks.onTotalProgress(loaded, total);\n      },\n      _onUploadPrep: function (id) {},\n      _onUpload: function (id, name) {\n        this._uploadData.setStatus(id, qq.status.UPLOADING);\n      },\n      _onUploadChunk: function (id, chunkData) {},\n      _onUploadChunkSuccess: function (id, chunkData) {\n        if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n          this._autoRetries[id] = 0;\n        }\n      },\n      _onUploadStatusChange: function (id, oldStatus, newStatus) {\n        if (newStatus === qq.status.PAUSED) {\n          clearTimeout(this._retryTimeouts[id]);\n        }\n      },\n      _onValidateBatchCallbackFailure: function (fileWrappers) {\n        var self = this;\n        qq.each(fileWrappers, function (idx, fileWrapper) {\n          self._fileOrBlobRejected(fileWrapper.id);\n        });\n      },\n      _onValidateBatchCallbackSuccess: function (validationDescriptors, items, params, endpoint, button) {\n        var errorMessage,\n            itemLimit = this._currentItemLimit,\n            proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n\n        if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n          if (items.length > 0) {\n            this._handleCheckedCallback({\n              name: \"onValidate\",\n              callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n              onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n              onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n              identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n            });\n          } else {\n            this._itemError(\"noFilesError\");\n          }\n        } else {\n          this._onValidateBatchCallbackFailure(items);\n\n          errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n\n          this._batchError(errorMessage);\n        }\n      },\n      _onValidateCallbackFailure: function (items, index, params, endpoint) {\n        var nextIndex = index + 1;\n\n        this._fileOrBlobRejected(items[index].id, items[index].file.name);\n\n        this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n      },\n      _onValidateCallbackSuccess: function (items, index, params, endpoint) {\n        var self = this,\n            nextIndex = index + 1,\n            validationDescriptor = this._getValidationDescriptor(items[index]);\n\n        this._validateFileOrBlobData(items[index], validationDescriptor).then(function () {\n          self._upload(items[index].id, params, endpoint);\n\n          self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n        }, function () {\n          self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n        });\n      },\n      _prepareItemsForUpload: function (items, params, endpoint) {\n        if (items.length === 0) {\n          this._itemError(\"noFilesError\");\n\n          return;\n        }\n\n        var validationDescriptors = this._getValidationDescriptors(items),\n            buttonId = this._getButtonId(items[0].file),\n            button = this._getButton(buttonId);\n\n        this._handleCheckedCallback({\n          name: \"onValidateBatch\",\n          callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n          onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n          onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n          identifier: \"batch validation\"\n        });\n      },\n      _preventLeaveInProgress: function () {\n        var self = this;\n\n        this._disposeSupport.attach(window, \"beforeunload\", function (e) {\n          if (self.getInProgress()) {\n            e = e || window.event;\n            e.returnValue = self._options.messages.onLeave;\n            return self._options.messages.onLeave;\n          }\n        });\n      },\n      _refreshSessionData: function () {\n        var self = this,\n            options = this._options.session;\n\n        if (qq.Session && this._options.session.endpoint != null) {\n          if (!this._session) {\n            qq.extend(options, {\n              cors: this._options.cors\n            });\n            options.log = qq.bind(this.log, this);\n            options.addFileRecord = qq.bind(this._addCannedFile, this);\n            this._session = new qq.Session(options);\n          }\n\n          setTimeout(function () {\n            self._session.refresh().then(function (response, xhrOrXdr) {\n              self._sessionRequestComplete();\n\n              self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n            }, function (response, xhrOrXdr) {\n              self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n            });\n          }, 0);\n        }\n      },\n      _sessionRequestComplete: function () {},\n      _setSize: function (id, newSize) {\n        this._uploadData.updateSize(id, newSize);\n\n        this._totalProgress && this._totalProgress.onNewSize(id);\n      },\n      _shouldAutoRetry: function (id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n\n        if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n          if (this._autoRetries[id] === undefined) {\n            this._autoRetries[id] = 0;\n          }\n\n          if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n            this._autoRetries[id] += 1;\n            return true;\n          }\n        }\n\n        return false;\n      },\n      _storeForLater: function (id) {\n        this._storedIds.push(id);\n      },\n      _trackButton: function (id) {\n        var buttonId;\n\n        if (qq.supportedFeatures.ajaxUploading) {\n          buttonId = this._handler.getFile(id).qqButtonId;\n        } else {\n          buttonId = this._getButtonId(this._handler.getInput(id));\n        }\n\n        if (buttonId) {\n          this._buttonIdsForFileIds[id] = buttonId;\n        }\n      },\n      _updateFormSupportAndParams: function (formElementOrId) {\n        this._options.form.element = formElementOrId;\n        this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n\n        if (this._formSupport && this._formSupport.attachedToForm) {\n          this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n\n          this._options.autoUpload = this._formSupport.newAutoUpload;\n\n          if (this._formSupport.newEndpoint) {\n            this.setEndpoint(this._formSupport.newEndpoint);\n          }\n        }\n      },\n      _upload: function (id, params, endpoint) {\n        var name = this.getName(id);\n\n        if (params) {\n          this.setParams(params, id);\n        }\n\n        if (endpoint) {\n          this.setEndpoint(endpoint, id);\n        }\n\n        this._handleCheckedCallback({\n          name: \"onSubmit\",\n          callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n          onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n          onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n          identifier: id\n        });\n      },\n      _uploadFile: function (id) {\n        if (!this._handler.upload(id)) {\n          this._uploadData.setStatus(id, qq.status.QUEUED);\n        }\n      },\n      _uploadStoredFiles: function () {\n        var idToUpload,\n            stillSubmitting,\n            self = this;\n\n        while (this._storedIds.length) {\n          idToUpload = this._storedIds.shift();\n\n          this._uploadFile(idToUpload);\n        }\n\n        stillSubmitting = this.getUploads({\n          status: qq.status.SUBMITTING\n        }).length;\n\n        if (stillSubmitting) {\n          qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n          setTimeout(function () {\n            self._uploadStoredFiles();\n          }, 1e3);\n        }\n      },\n      _validateFileOrBlobData: function (fileWrapper, validationDescriptor) {\n        var self = this,\n            file = function () {\n          if (fileWrapper.file instanceof qq.BlobProxy) {\n            return fileWrapper.file.referenceBlob;\n          }\n\n          return fileWrapper.file;\n        }(),\n            name = validationDescriptor.name,\n            size = validationDescriptor.size,\n            buttonId = this._getButtonId(fileWrapper.file),\n            validationBase = this._getValidationBase(buttonId),\n            validityChecker = new qq.Promise();\n\n        validityChecker.then(function () {}, function () {\n          self._fileOrBlobRejected(fileWrapper.id, name);\n        });\n\n        if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n          this._itemError(\"typeError\", name, file);\n\n          return validityChecker.failure();\n        }\n\n        if (!this._options.validation.allowEmpty && size === 0) {\n          this._itemError(\"emptyError\", name, file);\n\n          return validityChecker.failure();\n        }\n\n        if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n          this._itemError(\"sizeError\", name, file);\n\n          return validityChecker.failure();\n        }\n\n        if (size > 0 && size < validationBase.minSizeLimit) {\n          this._itemError(\"minSizeError\", name, file);\n\n          return validityChecker.failure();\n        }\n\n        if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n          new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function (errorCode) {\n            self._itemError(errorCode + \"ImageError\", name, file);\n\n            validityChecker.failure();\n          });\n        } else {\n          validityChecker.success();\n        }\n\n        return validityChecker;\n      },\n      _wrapCallbacks: function () {\n        var self, safeCallback, prop;\n        self = this;\n\n        safeCallback = function (name, callback, args) {\n          var errorMsg;\n\n          try {\n            return callback.apply(self, args);\n          } catch (exception) {\n            errorMsg = exception.message || exception.toString();\n            self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n          }\n        };\n\n        for (prop in this._options.callbacks) {\n          (function () {\n            var callbackName, callbackFunc;\n            callbackName = prop;\n            callbackFunc = self._options.callbacks[callbackName];\n\n            self._options.callbacks[callbackName] = function () {\n              return safeCallback(callbackName, callbackFunc, arguments);\n            };\n          })();\n        }\n      }\n    };\n  })();\n\n  (function () {\n    \"use strict\";\n\n    qq.FineUploaderBasic = function (o) {\n      var self = this;\n      this._options = {\n        debug: false,\n        button: null,\n        multiple: true,\n        maxConnections: 3,\n        disableCancelForFormUploads: false,\n        autoUpload: true,\n        warnBeforeUnload: true,\n        request: {\n          customHeaders: {},\n          endpoint: \"/server/upload\",\n          filenameParam: \"qqfilename\",\n          forceMultipart: true,\n          inputName: \"qqfile\",\n          method: \"POST\",\n          omitDefaultParams: false,\n          params: {},\n          paramsInBody: true,\n          requireSuccessJson: true,\n          totalFileSizeName: \"qqtotalfilesize\",\n          uuidName: \"qquuid\"\n        },\n        validation: {\n          allowedExtensions: [],\n          sizeLimit: 0,\n          minSizeLimit: 0,\n          itemLimit: 0,\n          stopOnFirstInvalidFile: true,\n          acceptFiles: null,\n          image: {\n            maxHeight: 0,\n            maxWidth: 0,\n            minHeight: 0,\n            minWidth: 0\n          },\n          allowEmpty: false\n        },\n        callbacks: {\n          onSubmit: function (id, name) {},\n          onSubmitted: function (id, name) {},\n          onComplete: function (id, name, responseJSON, maybeXhr) {},\n          onAllComplete: function (successful, failed) {},\n          onCancel: function (id, name) {},\n          onUpload: function (id, name) {},\n          onUploadChunk: function (id, name, chunkData) {},\n          onUploadChunkSuccess: function (id, chunkData, responseJSON, xhr) {},\n          onResume: function (id, fileName, chunkData, customResumeData) {},\n          onProgress: function (id, name, loaded, total) {},\n          onTotalProgress: function (loaded, total) {},\n          onError: function (id, name, reason, maybeXhrOrXdr) {},\n          onAutoRetry: function (id, name, attemptNumber) {},\n          onManualRetry: function (id, name) {},\n          onValidateBatch: function (fileOrBlobData) {},\n          onValidate: function (fileOrBlobData) {},\n          onSubmitDelete: function (id) {},\n          onDelete: function (id) {},\n          onDeleteComplete: function (id, xhrOrXdr, isError) {},\n          onPasteReceived: function (blob) {},\n          onStatusChange: function (id, oldStatus, newStatus) {},\n          onSessionRequestComplete: function (response, success, xhrOrXdr) {}\n        },\n        messages: {\n          typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n          sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n          minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n          emptyError: \"{file} is empty, please select files again without it.\",\n          noFilesError: \"No files to upload.\",\n          tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n          maxHeightImageError: \"Image is too tall.\",\n          maxWidthImageError: \"Image is too wide.\",\n          minHeightImageError: \"Image is not tall enough.\",\n          minWidthImageError: \"Image is not wide enough.\",\n          retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n          onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n          unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n        },\n        retry: {\n          enableAuto: false,\n          maxAutoAttempts: 3,\n          autoAttemptDelay: 5,\n          preventRetryResponseProperty: \"preventRetry\"\n        },\n        classes: {\n          buttonHover: \"qq-upload-button-hover\",\n          buttonFocus: \"qq-upload-button-focus\"\n        },\n        chunking: {\n          enabled: false,\n          concurrent: {\n            enabled: false\n          },\n          mandatory: false,\n          paramNames: {\n            partIndex: \"qqpartindex\",\n            partByteOffset: \"qqpartbyteoffset\",\n            chunkSize: \"qqchunksize\",\n            totalFileSize: \"qqtotalfilesize\",\n            totalParts: \"qqtotalparts\"\n          },\n          partSize: function (id) {\n            return 2e6;\n          },\n          success: {\n            endpoint: null,\n            headers: function (id) {\n              return null;\n            },\n            jsonPayload: false,\n            method: \"POST\",\n            params: function (id) {\n              return null;\n            },\n            resetOnStatus: []\n          }\n        },\n        resume: {\n          enabled: false,\n          recordsExpireIn: 7,\n          paramNames: {\n            resuming: \"qqresume\"\n          },\n          customKeys: function (fileId) {\n            return [];\n          }\n        },\n        formatFileName: function (fileOrBlobName) {\n          return fileOrBlobName;\n        },\n        text: {\n          defaultResponseError: \"Upload failure reason unknown\",\n          fileInputTitle: \"file input\",\n          sizeSymbols: [\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"]\n        },\n        deleteFile: {\n          enabled: false,\n          method: \"DELETE\",\n          endpoint: \"/server/upload\",\n          customHeaders: {},\n          params: {}\n        },\n        cors: {\n          expected: false,\n          sendCredentials: false,\n          allowXdr: false\n        },\n        blobs: {\n          defaultName: \"misc_data\"\n        },\n        paste: {\n          targetElement: null,\n          defaultName: \"pasted_image\"\n        },\n        camera: {\n          ios: false,\n          button: null\n        },\n        extraButtons: [],\n        session: {\n          endpoint: null,\n          params: {},\n          customHeaders: {},\n          refreshOnReset: true\n        },\n        form: {\n          element: \"qq-form\",\n          autoUpload: false,\n          interceptSubmit: true\n        },\n        scaling: {\n          customResizer: null,\n          sendOriginal: true,\n          orient: true,\n          defaultType: null,\n          defaultQuality: 80,\n          failureText: \"Failed to scale\",\n          includeExif: false,\n          sizes: []\n        },\n        workarounds: {\n          iosEmptyVideos: true,\n          ios8SafariUploads: true,\n          ios8BrowserCrash: false\n        }\n      };\n      qq.extend(this._options, o, true);\n      this._buttons = [];\n      this._extraButtonSpecs = {};\n      this._buttonIdsForFileIds = [];\n\n      this._wrapCallbacks();\n\n      this._disposeSupport = new qq.DisposeSupport();\n      this._storedIds = [];\n      this._autoRetries = [];\n      this._retryTimeouts = [];\n      this._preventRetries = [];\n      this._thumbnailUrls = [];\n      this._netUploadedOrQueued = 0;\n      this._netUploaded = 0;\n      this._uploadData = this._createUploadDataTracker();\n\n      this._initFormSupportAndParams();\n\n      this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n      this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n      this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n      this._endpointStore = this._createStore(this._options.request.endpoint);\n      this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n      this._handler = this._createUploadHandler();\n      this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n\n      if (this._options.button) {\n        this._defaultButtonId = this._createUploadButton({\n          element: this._options.button,\n          title: this._options.text.fileInputTitle\n        }).getButtonId();\n      }\n\n      this._generateExtraButtonSpecs();\n\n      this._handleCameraAccess();\n\n      if (this._options.paste.targetElement) {\n        if (qq.PasteSupport) {\n          this._pasteHandler = this._createPasteHandler();\n        } else {\n          this.log(\"Paste support module not found\", \"error\");\n        }\n      }\n\n      this._options.warnBeforeUnload && this._preventLeaveInProgress();\n      this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n\n      this._refreshSessionData();\n\n      this._succeededSinceLastAllComplete = [];\n      this._failedSinceLastAllComplete = [];\n      this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n\n      if (this._scaler.enabled) {\n        this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n      }\n\n      if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n        this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function (id) {\n          var entry = self._uploadData.retrieve({\n            id: id\n          });\n\n          return entry && entry.size || 0;\n        });\n      }\n\n      this._currentItemLimit = this._options.validation.itemLimit;\n      this._customResumeDataStore = this._createStore();\n    };\n\n    qq.FineUploaderBasic.prototype = qq.basePublicApi;\n    qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n  })();\n\n  qq.AjaxRequester = function (o) {\n    \"use strict\";\n\n    var log,\n        shouldParamsBeInQueryString,\n        queue = [],\n        requestData = {},\n        options = {\n      acceptHeader: null,\n      validMethods: [\"PATCH\", \"POST\", \"PUT\"],\n      method: \"POST\",\n      contentType: \"application/x-www-form-urlencoded\",\n      maxConnections: 3,\n      customHeaders: {},\n      endpointStore: {},\n      paramsStore: {},\n      mandatedParams: {},\n      allowXRequestedWithAndCacheControl: true,\n      successfulResponseCodes: {\n        DELETE: [200, 202, 204],\n        PATCH: [200, 201, 202, 203, 204],\n        POST: [200, 201, 202, 203, 204],\n        PUT: [200, 201, 202, 203, 204],\n        GET: [200]\n      },\n      cors: {\n        expected: false,\n        sendCredentials: false\n      },\n      log: function (str, level) {},\n      onSend: function (id) {},\n      onComplete: function (id, xhrOrXdr, isError) {},\n      onProgress: null\n    };\n    qq.extend(options, o);\n    log = options.log;\n\n    if (qq.indexOf(options.validMethods, options.method) < 0) {\n      throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n    }\n\n    function isSimpleMethod() {\n      return qq.indexOf([\"GET\", \"POST\", \"HEAD\"], options.method) >= 0;\n    }\n\n    function containsNonSimpleHeaders(headers) {\n      var containsNonSimple = false;\n      qq.each(containsNonSimple, function (idx, header) {\n        if (qq.indexOf([\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\"], header) < 0) {\n          containsNonSimple = true;\n          return false;\n        }\n      });\n      return containsNonSimple;\n    }\n\n    function isXdr(xhr) {\n      return options.cors.expected && xhr.withCredentials === undefined;\n    }\n\n    function getCorsAjaxTransport() {\n      var xhrOrXdr;\n\n      if (window.XMLHttpRequest || window.ActiveXObject) {\n        xhrOrXdr = qq.createXhrInstance();\n\n        if (xhrOrXdr.withCredentials === undefined) {\n          xhrOrXdr = new XDomainRequest();\n\n          xhrOrXdr.onload = function () {};\n\n          xhrOrXdr.onerror = function () {};\n\n          xhrOrXdr.ontimeout = function () {};\n\n          xhrOrXdr.onprogress = function () {};\n        }\n      }\n\n      return xhrOrXdr;\n    }\n\n    function getXhrOrXdr(id, suppliedXhr) {\n      var xhrOrXdr = requestData[id] && requestData[id].xhr;\n\n      if (!xhrOrXdr) {\n        if (suppliedXhr) {\n          xhrOrXdr = suppliedXhr;\n        } else {\n          if (options.cors.expected) {\n            xhrOrXdr = getCorsAjaxTransport();\n          } else {\n            xhrOrXdr = qq.createXhrInstance();\n          }\n        }\n\n        requestData[id].xhr = xhrOrXdr;\n      }\n\n      return xhrOrXdr;\n    }\n\n    function dequeue(id) {\n      var i = qq.indexOf(queue, id),\n          max = options.maxConnections,\n          nextId;\n      delete requestData[id];\n      queue.splice(i, 1);\n\n      if (queue.length >= max && i < max) {\n        nextId = queue[max - 1];\n        sendRequest(nextId);\n      }\n    }\n\n    function onComplete(id, xdrError) {\n      var xhr = getXhrOrXdr(id),\n          method = options.method,\n          isError = xdrError === true;\n      dequeue(id);\n\n      if (isError) {\n        log(method + \" request for \" + id + \" has failed\", \"error\");\n      } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n        isError = true;\n        log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n      }\n\n      options.onComplete(id, xhr, isError);\n    }\n\n    function getParams(id) {\n      var onDemandParams = requestData[id].additionalParams,\n          mandatedParams = options.mandatedParams,\n          params;\n\n      if (options.paramsStore.get) {\n        params = options.paramsStore.get(id);\n      }\n\n      if (onDemandParams) {\n        qq.each(onDemandParams, function (name, val) {\n          params = params || {};\n          params[name] = val;\n        });\n      }\n\n      if (mandatedParams) {\n        qq.each(mandatedParams, function (name, val) {\n          params = params || {};\n          params[name] = val;\n        });\n      }\n\n      return params;\n    }\n\n    function sendRequest(id, optXhr) {\n      var xhr = getXhrOrXdr(id, optXhr),\n          method = options.method,\n          params = getParams(id),\n          payload = requestData[id].payload,\n          url;\n      options.onSend(id);\n      url = createUrl(id, params, requestData[id].additionalQueryParams);\n\n      if (isXdr(xhr)) {\n        xhr.onload = getXdrLoadHandler(id);\n        xhr.onerror = getXdrErrorHandler(id);\n      } else {\n        xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n      }\n\n      registerForUploadProgress(id);\n      xhr.open(method, url, true);\n\n      if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n        xhr.withCredentials = true;\n      }\n\n      setHeaders(id);\n      log(\"Sending \" + method + \" request for \" + id);\n\n      if (payload) {\n        xhr.send(payload);\n      } else if (shouldParamsBeInQueryString || !params) {\n        xhr.send();\n      } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n        xhr.send(qq.obj2url(params, \"\"));\n      } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n        xhr.send(JSON.stringify(params));\n      } else {\n        xhr.send(params);\n      }\n\n      return xhr;\n    }\n\n    function createUrl(id, params, additionalQueryParams) {\n      var endpoint = options.endpointStore.get(id),\n          addToPath = requestData[id].addToPath;\n\n      if (addToPath != undefined) {\n        endpoint += \"/\" + addToPath;\n      }\n\n      if (shouldParamsBeInQueryString && params) {\n        endpoint = qq.obj2url(params, endpoint);\n      }\n\n      if (additionalQueryParams) {\n        endpoint = qq.obj2url(additionalQueryParams, endpoint);\n      }\n\n      return endpoint;\n    }\n\n    function getXhrReadyStateChangeHandler(id) {\n      return function () {\n        if (getXhrOrXdr(id).readyState === 4) {\n          onComplete(id);\n        }\n      };\n    }\n\n    function registerForUploadProgress(id) {\n      var onProgress = options.onProgress;\n\n      if (onProgress) {\n        getXhrOrXdr(id).upload.onprogress = function (e) {\n          if (e.lengthComputable) {\n            onProgress(id, e.loaded, e.total);\n          }\n        };\n      }\n    }\n\n    function getXdrLoadHandler(id) {\n      return function () {\n        onComplete(id);\n      };\n    }\n\n    function getXdrErrorHandler(id) {\n      return function () {\n        onComplete(id, true);\n      };\n    }\n\n    function setHeaders(id) {\n      var xhr = getXhrOrXdr(id),\n          customHeaders = options.customHeaders,\n          onDemandHeaders = requestData[id].additionalHeaders || {},\n          method = options.method,\n          allHeaders = {};\n\n      if (!isXdr(xhr)) {\n        options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n\n        if (options.allowXRequestedWithAndCacheControl) {\n          if (!options.cors.expected || !isSimpleMethod() || containsNonSimpleHeaders(customHeaders)) {\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n          }\n        }\n\n        if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n          xhr.setRequestHeader(\"Content-Type\", options.contentType);\n        }\n\n        qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n        qq.extend(allHeaders, onDemandHeaders);\n        qq.each(allHeaders, function (name, val) {\n          xhr.setRequestHeader(name, val);\n        });\n      }\n    }\n\n    function isResponseSuccessful(responseCode) {\n      return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n    }\n\n    function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n      requestData[id] = {\n        addToPath: addToPath,\n        additionalParams: additionalParams,\n        additionalQueryParams: additionalQueryParams,\n        additionalHeaders: additionalHeaders,\n        payload: payload\n      };\n      var len = queue.push(id);\n\n      if (len <= options.maxConnections) {\n        return sendRequest(id, optXhr);\n      }\n    }\n\n    shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n    qq.extend(this, {\n      initTransport: function (id) {\n        var path, params, headers, payload, cacheBuster, additionalQueryParams;\n        return {\n          withPath: function (appendToPath) {\n            path = appendToPath;\n            return this;\n          },\n          withParams: function (additionalParams) {\n            params = additionalParams;\n            return this;\n          },\n          withQueryParams: function (_additionalQueryParams_) {\n            additionalQueryParams = _additionalQueryParams_;\n            return this;\n          },\n          withHeaders: function (additionalHeaders) {\n            headers = additionalHeaders;\n            return this;\n          },\n          withPayload: function (thePayload) {\n            payload = thePayload;\n            return this;\n          },\n          withCacheBuster: function () {\n            cacheBuster = true;\n            return this;\n          },\n          send: function (optXhr) {\n            if (cacheBuster && qq.indexOf([\"GET\", \"DELETE\"], options.method) >= 0) {\n              params.qqtimestamp = new Date().getTime();\n            }\n\n            return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n          }\n        };\n      },\n      canceled: function (id) {\n        dequeue(id);\n      }\n    });\n  };\n\n  qq.UploadHandler = function (spec) {\n    \"use strict\";\n\n    var proxy = spec.proxy,\n        fileState = {},\n        onCancel = proxy.onCancel,\n        getName = proxy.getName;\n    qq.extend(this, {\n      add: function (id, fileItem) {\n        fileState[id] = fileItem;\n        fileState[id].temp = {};\n      },\n      cancel: function (id) {\n        var self = this,\n            cancelFinalizationEffort = new qq.Promise(),\n            onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n        onCancelRetVal.then(function () {\n          if (self.isValid(id)) {\n            fileState[id].canceled = true;\n            self.expunge(id);\n          }\n\n          cancelFinalizationEffort.success();\n        });\n      },\n      expunge: function (id) {\n        delete fileState[id];\n      },\n      getThirdPartyFileId: function (id) {\n        return fileState[id].key;\n      },\n      isValid: function (id) {\n        return fileState[id] !== undefined;\n      },\n      reset: function () {\n        fileState = {};\n      },\n      _getFileState: function (id) {\n        return fileState[id];\n      },\n      _setThirdPartyFileId: function (id, thirdPartyFileId) {\n        fileState[id].key = thirdPartyFileId;\n      },\n      _wasCanceled: function (id) {\n        return !!fileState[id].canceled;\n      }\n    });\n  };\n\n  qq.UploadHandlerController = function (o, namespace) {\n    \"use strict\";\n\n    var controller = this,\n        chunkingPossible = false,\n        concurrentChunkingPossible = false,\n        chunking,\n        preventRetryResponse,\n        log,\n        handler,\n        options = {\n      paramsStore: {},\n      maxConnections: 3,\n      chunking: {\n        enabled: false,\n        multiple: {\n          enabled: false\n        }\n      },\n      log: function (str, level) {},\n      onProgress: function (id, fileName, loaded, total) {},\n      onComplete: function (id, fileName, response, xhr) {},\n      onCancel: function (id, fileName) {},\n      onUploadPrep: function (id) {},\n      onUpload: function (id, fileName) {},\n      onUploadChunk: function (id, fileName, chunkData) {},\n      onUploadChunkSuccess: function (id, chunkData, response, xhr) {},\n      onAutoRetry: function (id, fileName, response, xhr) {},\n      onResume: function (id, fileName, chunkData, customResumeData) {},\n      onUuidChanged: function (id, newUuid) {},\n      getName: function (id) {},\n      setSize: function (id, newSize) {},\n      isQueued: function (id) {},\n      getIdsInProxyGroup: function (id) {},\n      getIdsInBatch: function (id) {},\n      isInProgress: function (id) {}\n    },\n        chunked = {\n      done: function (id, chunkIdx, response, xhr) {\n        var chunkData = handler._getChunkData(id, chunkIdx);\n\n        handler._getFileState(id).attemptingResume = false;\n        delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n        handler._getFileState(id).loaded += chunkData.size;\n        options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n      },\n      finalize: function (id) {\n        var size = options.getSize(id),\n            name = options.getName(id);\n        log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n        handler.finalizeChunks(id).then(function (response, xhr) {\n          log(\"Finalize successful for \" + id);\n          var normaizedResponse = upload.normalizeResponse(response, true);\n          options.onProgress(id, name, size, size);\n\n          handler._maybeDeletePersistedChunkData(id);\n\n          upload.cleanup(id, normaizedResponse, xhr);\n        }, function (response, xhr) {\n          var normalizedResponse = upload.normalizeResponse(response, false);\n          log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n\n          if (normalizedResponse.reset || xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0) {\n            chunked.reset(id);\n          }\n\n          if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n            upload.cleanup(id, normalizedResponse, xhr);\n          }\n        });\n      },\n      handleFailure: function (chunkIdx, id, response, xhr) {\n        var name = options.getName(id);\n        log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n        handler.clearCachedChunk(id, chunkIdx);\n        var responseToReport = upload.normalizeResponse(response, false),\n            inProgressIdx;\n\n        if (responseToReport.reset) {\n          chunked.reset(id);\n        } else {\n          var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n\n          inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n\n          if (inProgressIdx >= 0) {\n            handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n\n            handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n          }\n        }\n\n        if (!handler._getFileState(id).temp.ignoreFailure) {\n          if (concurrentChunkingPossible) {\n            handler._getFileState(id).temp.ignoreFailure = true;\n            log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n            qq.each(handler._getXhrs(id), function (ckid, ckXhr) {\n              log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n              ckXhr.abort();\n              ckXhr._cancelled = true;\n            });\n            handler.moveInProgressToRemaining(id);\n            connectionManager.free(id, true);\n          }\n\n          if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n            upload.cleanup(id, responseToReport, xhr);\n          }\n        }\n      },\n      hasMoreParts: function (id) {\n        return !!handler._getFileState(id).chunking.remaining.length;\n      },\n      nextPart: function (id) {\n        var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n\n        if (nextIdx >= handler._getTotalChunks(id)) {\n          nextIdx = null;\n        }\n\n        return nextIdx;\n      },\n      reset: function (id) {\n        log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n\n        handler._maybeDeletePersistedChunkData(id);\n\n        handler.reevaluateChunking(id);\n        handler._getFileState(id).loaded = 0;\n        handler._getFileState(id).attemptingResume = false;\n      },\n      sendNext: function (id) {\n        var size = options.getSize(id),\n            name = options.getName(id),\n            chunkIdx = chunked.nextPart(id),\n            chunkData = handler._getChunkData(id, chunkIdx),\n            fileState = handler._getFileState(id),\n            resuming = fileState.attemptingResume,\n            inProgressChunks = fileState.chunking.inProgress || [];\n\n        if (fileState.loaded == null) {\n          fileState.loaded = 0;\n        }\n\n        if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n          chunked.reset(id);\n          chunkIdx = chunked.nextPart(id);\n          chunkData = handler._getChunkData(id, chunkIdx);\n          resuming = false;\n        }\n\n        if (chunkIdx == null && inProgressChunks.length === 0) {\n          chunked.finalize(id);\n        } else {\n          inProgressChunks.push(chunkIdx);\n          handler._getFileState(id).chunking.inProgress = inProgressChunks;\n\n          if (concurrentChunkingPossible) {\n            connectionManager.open(id, chunkIdx);\n          }\n\n          if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n            chunked.sendNext(id);\n          }\n\n          if (chunkData.blob.size === 0) {\n            log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n            chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n          }\n\n          var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n          onUploadChunkPromise.then(function (requestOverrides) {\n            if (!options.isInProgress(id)) {\n              log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n            } else {\n              log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n              var uploadChunkData = {\n                chunkIdx: chunkIdx,\n                id: id,\n                overrides: requestOverrides,\n                resuming: resuming\n              };\n              handler.uploadChunk(uploadChunkData).then(function success(response, xhr) {\n                log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                handler.clearCachedChunk(id, chunkIdx);\n                var inProgressChunks = handler._getFileState(id).chunking.inProgress || [],\n                    responseToReport = upload.normalizeResponse(response, true),\n                    inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                chunked.done(id, chunkIdx, responseToReport, xhr);\n\n                if (inProgressChunkIdx >= 0) {\n                  inProgressChunks.splice(inProgressChunkIdx, 1);\n                }\n\n                handler._maybePersistChunkedState(id);\n\n                if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                  chunked.finalize(id);\n                } else if (chunked.hasMoreParts(id)) {\n                  chunked.sendNext(id);\n                } else {\n                  log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                }\n              }, function failure(response, xhr) {\n                chunked.handleFailure(chunkIdx, id, response, xhr);\n              }).done(function () {\n                handler.clearXhr(id, chunkIdx);\n              });\n            }\n          }, function (error) {\n            chunked.handleFailure(chunkIdx, id, error, null);\n          });\n        }\n      }\n    },\n        connectionManager = {\n      _open: [],\n      _openChunks: {},\n      _waiting: [],\n      available: function () {\n        var max = options.maxConnections,\n            openChunkEntriesCount = 0,\n            openChunksCount = 0;\n        qq.each(connectionManager._openChunks, function (fileId, openChunkIndexes) {\n          openChunkEntriesCount++;\n          openChunksCount += openChunkIndexes.length;\n        });\n        return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n      },\n      free: function (id, dontAllowNext) {\n        var allowNext = !dontAllowNext,\n            waitingIndex = qq.indexOf(connectionManager._waiting, id),\n            connectionsIndex = qq.indexOf(connectionManager._open, id),\n            nextId;\n        delete connectionManager._openChunks[id];\n\n        if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n          log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n          delete handler._getFileState(id).file;\n        }\n\n        if (waitingIndex >= 0) {\n          connectionManager._waiting.splice(waitingIndex, 1);\n        } else if (allowNext && connectionsIndex >= 0) {\n          connectionManager._open.splice(connectionsIndex, 1);\n\n          nextId = connectionManager._waiting.shift();\n\n          if (nextId >= 0) {\n            connectionManager._open.push(nextId);\n\n            upload.start(nextId);\n          }\n        }\n      },\n      getWaitingOrConnected: function () {\n        var waitingOrConnected = [];\n        qq.each(connectionManager._openChunks, function (fileId, chunks) {\n          if (chunks && chunks.length) {\n            waitingOrConnected.push(parseInt(fileId));\n          }\n        });\n        qq.each(connectionManager._open, function (idx, fileId) {\n          if (!connectionManager._openChunks[fileId]) {\n            waitingOrConnected.push(parseInt(fileId));\n          }\n        });\n        waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n        return waitingOrConnected;\n      },\n      isUsingConnection: function (id) {\n        return qq.indexOf(connectionManager._open, id) >= 0;\n      },\n      open: function (id, chunkIdx) {\n        if (chunkIdx == null) {\n          connectionManager._waiting.push(id);\n        }\n\n        if (connectionManager.available()) {\n          if (chunkIdx == null) {\n            connectionManager._waiting.pop();\n\n            connectionManager._open.push(id);\n          } else {\n            (function () {\n              var openChunksEntry = connectionManager._openChunks[id] || [];\n              openChunksEntry.push(chunkIdx);\n              connectionManager._openChunks[id] = openChunksEntry;\n            })();\n          }\n\n          return true;\n        }\n\n        return false;\n      },\n      reset: function () {\n        connectionManager._waiting = [];\n        connectionManager._open = [];\n      }\n    },\n        simple = {\n      send: function (id, name) {\n        var fileState = handler._getFileState(id);\n\n        if (!fileState) {\n          log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n          return;\n        }\n\n        fileState.loaded = 0;\n        log(\"Sending simple upload request for \" + id);\n        handler.uploadFile(id).then(function (response, optXhr) {\n          log(\"Simple upload request succeeded for \" + id);\n          var responseToReport = upload.normalizeResponse(response, true),\n              size = options.getSize(id);\n          options.onProgress(id, name, size, size);\n          upload.maybeNewUuid(id, responseToReport);\n          upload.cleanup(id, responseToReport, optXhr);\n        }, function (response, optXhr) {\n          log(\"Simple upload request failed for \" + id);\n          var responseToReport = upload.normalizeResponse(response, false);\n\n          if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n            upload.cleanup(id, responseToReport, optXhr);\n          }\n        });\n      }\n    },\n        upload = {\n      cancel: function (id) {\n        log(\"Cancelling \" + id);\n        options.paramsStore.remove(id);\n        connectionManager.free(id);\n      },\n      cleanup: function (id, response, optXhr) {\n        var name = options.getName(id);\n        options.onComplete(id, name, response, optXhr);\n\n        if (handler._getFileState(id)) {\n          handler._clearXhrs && handler._clearXhrs(id);\n        }\n\n        connectionManager.free(id);\n      },\n      getProxyOrBlob: function (id) {\n        return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n      },\n      initHandler: function () {\n        var handlerType = namespace ? qq[namespace] : qq.traditional,\n            handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n        handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n          getCustomResumeData: options.getCustomResumeData,\n          getDataByUuid: options.getDataByUuid,\n          getName: options.getName,\n          getSize: options.getSize,\n          getUuid: options.getUuid,\n          log: log,\n          onCancel: options.onCancel,\n          onProgress: options.onProgress,\n          onUuidChanged: options.onUuidChanged,\n          onFinalizing: function (id) {\n            options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n          }\n        });\n\n        if (handler._removeExpiredChunkingRecords) {\n          handler._removeExpiredChunkingRecords();\n        }\n      },\n      isDeferredEligibleForUpload: function (id) {\n        return options.isQueued(id);\n      },\n      maybeDefer: function (id, blob) {\n        if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n          options.onUploadPrep(id);\n          log(\"Attempting to generate a blob on-demand for \" + id);\n          blob.create().then(function (generatedBlob) {\n            log(\"Generated an on-demand blob for \" + id);\n            handler.updateBlob(id, generatedBlob);\n            options.setSize(id, generatedBlob.size);\n            handler.reevaluateChunking(id);\n            upload.maybeSendDeferredFiles(id);\n          }, function (errorMessage) {\n            var errorResponse = {};\n\n            if (errorMessage) {\n              errorResponse.error = errorMessage;\n            }\n\n            log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n            options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n            upload.maybeSendDeferredFiles(id);\n            connectionManager.free(id);\n          });\n        } else {\n          return upload.maybeSendDeferredFiles(id);\n        }\n\n        return false;\n      },\n      maybeSendDeferredFiles: function (id) {\n        var idsInGroup = options.getIdsInProxyGroup(id),\n            uploadedThisId = false;\n\n        if (idsInGroup && idsInGroup.length) {\n          log(\"Maybe ready to upload proxy group file \" + id);\n          qq.each(idsInGroup, function (idx, idInGroup) {\n            if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n              uploadedThisId = idInGroup === id;\n              upload.now(idInGroup);\n            } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n              return false;\n            }\n          });\n        } else {\n          uploadedThisId = true;\n          upload.now(id);\n        }\n\n        return uploadedThisId;\n      },\n      maybeNewUuid: function (id, response) {\n        if (response.newUuid !== undefined) {\n          options.onUuidChanged(id, response.newUuid);\n        }\n      },\n      normalizeResponse: function (originalResponse, successful) {\n        var response = originalResponse;\n\n        if (!qq.isObject(originalResponse)) {\n          response = {};\n\n          if (qq.isString(originalResponse) && !successful) {\n            response.error = originalResponse;\n          }\n        }\n\n        response.success = successful;\n        return response;\n      },\n      now: function (id) {\n        var name = options.getName(id);\n\n        if (!controller.isValid(id)) {\n          throw new qq.Error(id + \" is not a valid file ID to upload!\");\n        }\n\n        options.onUpload(id, name).then(function (response) {\n          if (response && response.pause) {\n            options.setStatus(id, qq.status.PAUSED);\n            handler.pause(id);\n            connectionManager.free(id);\n          } else {\n            if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n              chunked.sendNext(id);\n            } else {\n              simple.send(id, name);\n            }\n          }\n        }, function (error) {\n          error = error || {};\n          log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n\n          if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n            var response = upload.normalizeResponse(error.responseJSON, false);\n            upload.cleanup(id, response);\n          }\n        });\n      },\n      start: function (id) {\n        var blobToUpload = upload.getProxyOrBlob(id);\n\n        if (blobToUpload) {\n          return upload.maybeDefer(id, blobToUpload);\n        } else {\n          upload.now(id);\n          return true;\n        }\n      }\n    };\n    qq.extend(this, {\n      add: function (id, file) {\n        handler.add.apply(this, arguments);\n      },\n      upload: function (id) {\n        if (connectionManager.open(id)) {\n          return upload.start(id);\n        }\n\n        return false;\n      },\n      retry: function (id) {\n        if (concurrentChunkingPossible) {\n          handler._getFileState(id).temp.ignoreFailure = false;\n        }\n\n        if (connectionManager.isUsingConnection(id)) {\n          return upload.start(id);\n        } else {\n          return controller.upload(id);\n        }\n      },\n      cancel: function (id) {\n        var cancelRetVal = handler.cancel(id);\n\n        if (qq.isGenericPromise(cancelRetVal)) {\n          cancelRetVal.then(function () {\n            upload.cancel(id);\n          });\n        } else if (cancelRetVal !== false) {\n          upload.cancel(id);\n        }\n      },\n      cancelAll: function () {\n        var waitingOrConnected = connectionManager.getWaitingOrConnected(),\n            i;\n\n        if (waitingOrConnected.length) {\n          for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n            controller.cancel(waitingOrConnected[i]);\n          }\n        }\n\n        connectionManager.reset();\n      },\n      getFile: function (id) {\n        if (handler.getProxy && handler.getProxy(id)) {\n          return handler.getProxy(id).referenceBlob;\n        }\n\n        return handler.getFile && handler.getFile(id);\n      },\n      isProxied: function (id) {\n        return !!(handler.getProxy && handler.getProxy(id));\n      },\n      getInput: function (id) {\n        if (handler.getInput) {\n          return handler.getInput(id);\n        }\n      },\n      reset: function () {\n        log(\"Resetting upload handler\");\n        controller.cancelAll();\n        connectionManager.reset();\n        handler.reset();\n      },\n      expunge: function (id) {\n        if (controller.isValid(id)) {\n          return handler.expunge(id);\n        }\n      },\n      isValid: function (id) {\n        return handler.isValid(id);\n      },\n      hasResumeRecord: function (id) {\n        var key = handler.isValid(id) && handler._getLocalStorageId && handler._getLocalStorageId(id);\n\n        if (key) {\n          return !!localStorage.getItem(key);\n        }\n\n        return false;\n      },\n      getResumableFilesData: function () {\n        if (handler.getResumableFilesData) {\n          return handler.getResumableFilesData();\n        }\n\n        return [];\n      },\n      getThirdPartyFileId: function (id) {\n        if (controller.isValid(id)) {\n          return handler.getThirdPartyFileId(id);\n        }\n      },\n      pause: function (id) {\n        if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n          connectionManager.free(id);\n          handler.moveInProgressToRemaining(id);\n          return true;\n        }\n\n        return false;\n      },\n      isAttemptingResume: function (id) {\n        return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n      },\n      isResumable: function (id) {\n        return !!handler.isResumable && handler.isResumable(id);\n      }\n    });\n    qq.extend(options, o);\n    log = options.log;\n    chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n    concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n\n    preventRetryResponse = function () {\n      var response = {};\n      response[options.preventRetryParam] = true;\n      return response;\n    }();\n\n    upload.initHandler();\n  };\n\n  qq.WindowReceiveMessage = function (o) {\n    \"use strict\";\n\n    var options = {\n      log: function (message, level) {}\n    },\n        callbackWrapperDetachers = {};\n    qq.extend(options, o);\n    qq.extend(this, {\n      receiveMessage: function (id, callback) {\n        var onMessageCallbackWrapper = function (event) {\n          callback(event.data);\n        };\n\n        if (window.postMessage) {\n          callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n        } else {\n          log(\"iframe message passing not supported in this browser!\", \"error\");\n        }\n      },\n      stopReceivingMessages: function (id) {\n        if (window.postMessage) {\n          var detacher = callbackWrapperDetachers[id];\n\n          if (detacher) {\n            detacher();\n          }\n        }\n      }\n    });\n  };\n\n  qq.FormUploadHandler = function (spec) {\n    \"use strict\";\n\n    var options = spec.options,\n        handler = this,\n        proxy = spec.proxy,\n        formHandlerInstanceId = qq.getUniqueId(),\n        onloadCallbacks = {},\n        detachLoadEvents = {},\n        postMessageCallbackTimers = {},\n        isCors = options.isCors,\n        inputName = options.inputName,\n        getUuid = proxy.getUuid,\n        log = proxy.log,\n        corsMessageReceiver = new qq.WindowReceiveMessage({\n      log: log\n    });\n\n    function expungeFile(id) {\n      delete detachLoadEvents[id];\n\n      if (isCors) {\n        clearTimeout(postMessageCallbackTimers[id]);\n        delete postMessageCallbackTimers[id];\n        corsMessageReceiver.stopReceivingMessages(id);\n      }\n\n      var iframe = document.getElementById(handler._getIframeName(id));\n\n      if (iframe) {\n        iframe.setAttribute(\"src\", \"javascript:false;\");\n        qq(iframe).remove();\n      }\n    }\n\n    function getFileIdForIframeName(iframeName) {\n      return iframeName.split(\"_\")[0];\n    }\n\n    function initIframeForUpload(name) {\n      var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n      iframe.setAttribute(\"id\", name);\n      iframe.style.display = \"none\";\n      document.body.appendChild(iframe);\n      return iframe;\n    }\n\n    function registerPostMessageCallback(iframe, callback) {\n      var iframeName = iframe.id,\n          fileId = getFileIdForIframeName(iframeName),\n          uuid = getUuid(fileId);\n      onloadCallbacks[uuid] = callback;\n      detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function () {\n        if (handler.getInput(fileId)) {\n          log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n          postMessageCallbackTimers[iframeName] = setTimeout(function () {\n            var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n            log(errorMessage, \"error\");\n            callback({\n              error: errorMessage\n            });\n          }, 1e3);\n        }\n      });\n      corsMessageReceiver.receiveMessage(iframeName, function (message) {\n        log(\"Received the following window message: '\" + message + \"'\");\n\n        var fileId = getFileIdForIframeName(iframeName),\n            response = handler._parseJsonResponse(message),\n            uuid = response.uuid,\n            onloadCallback;\n\n        if (uuid && onloadCallbacks[uuid]) {\n          log(\"Handling response for iframe name \" + iframeName);\n          clearTimeout(postMessageCallbackTimers[iframeName]);\n          delete postMessageCallbackTimers[iframeName];\n\n          handler._detachLoadEvent(iframeName);\n\n          onloadCallback = onloadCallbacks[uuid];\n          delete onloadCallbacks[uuid];\n          corsMessageReceiver.stopReceivingMessages(iframeName);\n          onloadCallback(response);\n        } else if (!uuid) {\n          log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n        }\n      });\n    }\n\n    qq.extend(this, new qq.UploadHandler(spec));\n    qq.override(this, function (super_) {\n      return {\n        add: function (id, fileInput) {\n          super_.add(id, {\n            input: fileInput\n          });\n          fileInput.setAttribute(\"name\", inputName);\n\n          if (fileInput.parentNode) {\n            qq(fileInput).remove();\n          }\n        },\n        expunge: function (id) {\n          expungeFile(id);\n          super_.expunge(id);\n        },\n        isValid: function (id) {\n          return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n        }\n      };\n    });\n    qq.extend(this, {\n      getInput: function (id) {\n        return handler._getFileState(id).input;\n      },\n      _attachLoadEvent: function (iframe, callback) {\n        var responseDescriptor;\n\n        if (isCors) {\n          registerPostMessageCallback(iframe, callback);\n        } else {\n          detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function () {\n            log(\"Received response for \" + iframe.id);\n\n            if (!iframe.parentNode) {\n              return;\n            }\n\n            try {\n              if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                return;\n              }\n            } catch (error) {\n              log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n              responseDescriptor = {\n                success: false\n              };\n            }\n\n            callback(responseDescriptor);\n          });\n        }\n      },\n      _createIframe: function (id) {\n        var iframeName = handler._getIframeName(id);\n\n        return initIframeForUpload(iframeName);\n      },\n      _detachLoadEvent: function (id) {\n        if (detachLoadEvents[id] !== undefined) {\n          detachLoadEvents[id]();\n          delete detachLoadEvents[id];\n        }\n      },\n      _getIframeName: function (fileId) {\n        return fileId + \"_\" + formHandlerInstanceId;\n      },\n      _initFormForUpload: function (spec) {\n        var method = spec.method,\n            endpoint = spec.endpoint,\n            params = spec.params,\n            paramsInBody = spec.paramsInBody,\n            targetName = spec.targetName,\n            form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"),\n            url = endpoint;\n\n        if (paramsInBody) {\n          qq.obj2Inputs(params, form);\n        } else {\n          url = qq.obj2url(params, endpoint);\n        }\n\n        form.setAttribute(\"action\", url);\n        form.setAttribute(\"target\", targetName);\n        form.style.display = \"none\";\n        document.body.appendChild(form);\n        return form;\n      },\n      _parseJsonResponse: function (innerHtmlOrMessage) {\n        var response = {};\n\n        try {\n          response = qq.parseJson(innerHtmlOrMessage);\n        } catch (error) {\n          log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n        }\n\n        return response;\n      }\n    });\n  };\n\n  qq.XhrUploadHandler = function (spec) {\n    \"use strict\";\n\n    var handler = this,\n        namespace = spec.options.namespace,\n        proxy = spec.proxy,\n        chunking = spec.options.chunking,\n        getChunkSize = function (id) {\n      var fileState = handler._getFileState(id);\n\n      if (fileState.chunkSize) {\n        return fileState.chunkSize;\n      } else {\n        var chunkSize = chunking.partSize;\n\n        if (qq.isFunction(chunkSize)) {\n          chunkSize = chunkSize(id, getSize(id));\n        }\n\n        fileState.chunkSize = chunkSize;\n        return chunkSize;\n      }\n    },\n        resume = spec.options.resume,\n        chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking,\n        resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume,\n        getName = proxy.getName,\n        getSize = proxy.getSize,\n        getUuid = proxy.getUuid,\n        getEndpoint = proxy.getEndpoint,\n        getDataByUuid = proxy.getDataByUuid,\n        onUuidChanged = proxy.onUuidChanged,\n        onProgress = proxy.onProgress,\n        log = proxy.log,\n        getCustomResumeData = proxy.getCustomResumeData;\n\n    function abort(id) {\n      qq.each(handler._getXhrs(id), function (xhrId, xhr) {\n        var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n\n        xhr.onreadystatechange = null;\n        xhr.upload.onprogress = null;\n        xhr.abort();\n        ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n      });\n    }\n\n    qq.extend(this, new qq.UploadHandler(spec));\n    qq.override(this, function (super_) {\n      return {\n        add: function (id, blobOrProxy) {\n          if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n            super_.add(id, {\n              file: blobOrProxy\n            });\n          } else if (blobOrProxy instanceof qq.BlobProxy) {\n            super_.add(id, {\n              proxy: blobOrProxy\n            });\n          } else {\n            throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n          }\n\n          handler._initTempState(id);\n\n          resumeEnabled && handler._maybePrepareForResume(id);\n        },\n        expunge: function (id) {\n          abort(id);\n\n          handler._maybeDeletePersistedChunkData(id);\n\n          handler._clearXhrs(id);\n\n          super_.expunge(id);\n        }\n      };\n    });\n    qq.extend(this, {\n      clearCachedChunk: function (id, chunkIdx) {\n        var fileState = handler._getFileState(id);\n\n        if (fileState) {\n          delete fileState.temp.cachedChunks[chunkIdx];\n        }\n      },\n      clearXhr: function (id, chunkIdx) {\n        var tempState = handler._getFileState(id).temp;\n\n        if (tempState.xhrs) {\n          delete tempState.xhrs[chunkIdx];\n        }\n\n        if (tempState.ajaxRequesters) {\n          delete tempState.ajaxRequesters[chunkIdx];\n        }\n      },\n      finalizeChunks: function (id, responseParser) {\n        var lastChunkIdx = handler._getTotalChunks(id) - 1,\n            xhr = handler._getXhr(id, lastChunkIdx);\n\n        if (responseParser) {\n          return new qq.Promise().success(responseParser(xhr), xhr);\n        }\n\n        return new qq.Promise().success({}, xhr);\n      },\n      getFile: function (id) {\n        return handler.isValid(id) && handler._getFileState(id).file;\n      },\n      getProxy: function (id) {\n        return handler.isValid(id) && handler._getFileState(id).proxy;\n      },\n      getResumableFilesData: function () {\n        var resumableFilesData = [];\n\n        handler._iterateResumeRecords(function (key, uploadData) {\n          handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n          var data = {\n            name: uploadData.name,\n            remaining: uploadData.chunking.remaining,\n            size: uploadData.size,\n            uuid: uploadData.uuid\n          };\n\n          if (uploadData.key) {\n            data.key = uploadData.key;\n          }\n\n          if (uploadData.customResumeData) {\n            data.customResumeData = uploadData.customResumeData;\n          }\n\n          resumableFilesData.push(data);\n        });\n\n        return resumableFilesData;\n      },\n      isAttemptingResume: function (id) {\n        return handler._getFileState(id).attemptingResume;\n      },\n      isResumable: function (id) {\n        return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n      },\n      moveInProgressToRemaining: function (id, optInProgress, optRemaining) {\n        var fileState = handler._getFileState(id) || {},\n            chunkingState = fileState.chunking || {},\n            inProgress = optInProgress || chunkingState.inProgress,\n            remaining = optRemaining || chunkingState.remaining;\n\n        if (inProgress) {\n          log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n          inProgress.reverse();\n          qq.each(inProgress, function (idx, chunkIdx) {\n            remaining.unshift(chunkIdx);\n          });\n          inProgress.length = 0;\n        }\n      },\n      pause: function (id) {\n        if (handler.isValid(id)) {\n          log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n          handler._getFileState(id).paused = true;\n          abort(id);\n          return true;\n        }\n      },\n      reevaluateChunking: function (id) {\n        if (chunking && handler.isValid(id)) {\n          var state = handler._getFileState(id),\n              totalChunks,\n              i;\n\n          delete state.chunking;\n          state.chunking = {};\n          totalChunks = handler._getTotalChunks(id);\n\n          if (totalChunks > 1 || chunking.mandatory) {\n            state.chunking.enabled = true;\n            state.chunking.parts = totalChunks;\n            state.chunking.remaining = [];\n\n            for (i = 0; i < totalChunks; i++) {\n              state.chunking.remaining.push(i);\n            }\n\n            handler._initTempState(id);\n          } else {\n            state.chunking.enabled = false;\n          }\n        }\n      },\n      updateBlob: function (id, newBlob) {\n        if (handler.isValid(id)) {\n          handler._getFileState(id).file = newBlob;\n        }\n      },\n      _clearXhrs: function (id) {\n        var tempState = handler._getFileState(id).temp;\n\n        qq.each(tempState.ajaxRequesters, function (chunkId) {\n          delete tempState.ajaxRequesters[chunkId];\n        });\n        qq.each(tempState.xhrs, function (chunkId) {\n          delete tempState.xhrs[chunkId];\n        });\n      },\n      _createXhr: function (id, optChunkIdx) {\n        return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n      },\n      _getAjaxRequester: function (id, optChunkIdx) {\n        var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n        return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n      },\n      _getChunkData: function (id, chunkIndex) {\n        var chunkSize = getChunkSize(id),\n            fileSize = getSize(id),\n            fileOrBlob = handler.getFile(id),\n            startBytes = chunkSize * chunkIndex,\n            endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize,\n            totalChunks = handler._getTotalChunks(id),\n            cachedChunks = this._getFileState(id).temp.cachedChunks,\n            blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n\n        cachedChunks[chunkIndex] = blob;\n        return {\n          part: chunkIndex,\n          start: startBytes,\n          end: endBytes,\n          count: totalChunks,\n          blob: blob,\n          size: endBytes - startBytes\n        };\n      },\n      _getChunkDataForCallback: function (chunkData) {\n        return {\n          partIndex: chunkData.part,\n          startByte: chunkData.start + 1,\n          endByte: chunkData.end,\n          totalParts: chunkData.count\n        };\n      },\n      _getLocalStorageId: function (id) {\n        var formatVersion = \"5.0\",\n            name = getName(id),\n            size = getSize(id),\n            chunkSize = getChunkSize(id),\n            endpoint = getEndpoint(id),\n            customKeys = resume.customKeys(id),\n            localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n        customKeys.forEach(function (key) {\n          localStorageId += \"-\" + key;\n        });\n        return localStorageId;\n      },\n      _getMimeType: function (id) {\n        return handler.getFile(id).type;\n      },\n      _getPersistableData: function (id) {\n        return handler._getFileState(id).chunking;\n      },\n      _getTotalChunks: function (id) {\n        if (chunking) {\n          var fileSize = getSize(id),\n              chunkSize = getChunkSize(id);\n          return Math.ceil(fileSize / chunkSize);\n        }\n      },\n      _getXhr: function (id, optChunkIdx) {\n        var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n        return handler._getFileState(id).temp.xhrs[chunkIdx];\n      },\n      _getXhrs: function (id) {\n        return handler._getFileState(id).temp.xhrs;\n      },\n      _iterateResumeRecords: function (callback) {\n        if (resumeEnabled) {\n          qq.each(localStorage, function (key, item) {\n            if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n              var uploadData = JSON.parse(item);\n              callback(key, uploadData);\n            }\n          });\n        }\n      },\n      _initTempState: function (id) {\n        handler._getFileState(id).temp = {\n          ajaxRequesters: {},\n          chunkProgress: {},\n          xhrs: {},\n          cachedChunks: {}\n        };\n      },\n      _markNotResumable: function (id) {\n        handler._getFileState(id).notResumable = true;\n      },\n      _maybeDeletePersistedChunkData: function (id) {\n        var localStorageId;\n\n        if (resumeEnabled && handler.isResumable(id)) {\n          localStorageId = handler._getLocalStorageId(id);\n\n          if (localStorageId && localStorage.getItem(localStorageId)) {\n            localStorage.removeItem(localStorageId);\n            return true;\n          }\n        }\n\n        return false;\n      },\n      _maybePrepareForResume: function (id) {\n        var state = handler._getFileState(id),\n            localStorageId,\n            persistedData;\n\n        if (resumeEnabled && state.key === undefined) {\n          localStorageId = handler._getLocalStorageId(id);\n          persistedData = localStorage.getItem(localStorageId);\n\n          if (persistedData) {\n            persistedData = JSON.parse(persistedData);\n\n            if (getDataByUuid(persistedData.uuid)) {\n              handler._markNotResumable(id);\n            } else {\n              log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n              onUuidChanged(id, persistedData.uuid);\n              state.key = persistedData.key;\n              state.chunking = persistedData.chunking;\n              state.loaded = persistedData.loaded;\n              state.customResumeData = persistedData.customResumeData;\n              state.attemptingResume = true;\n              handler.moveInProgressToRemaining(id);\n            }\n          }\n        }\n      },\n      _maybePersistChunkedState: function (id) {\n        var state = handler._getFileState(id),\n            localStorageId,\n            persistedData;\n\n        if (resumeEnabled && handler.isResumable(id)) {\n          var customResumeData = getCustomResumeData(id);\n          localStorageId = handler._getLocalStorageId(id);\n          persistedData = {\n            name: getName(id),\n            size: getSize(id),\n            uuid: getUuid(id),\n            key: state.key,\n            chunking: state.chunking,\n            loaded: state.loaded,\n            lastUpdated: Date.now()\n          };\n\n          if (customResumeData) {\n            persistedData.customResumeData = customResumeData;\n          }\n\n          try {\n            localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n          } catch (error) {\n            log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n          }\n        }\n      },\n      _registerProgressHandler: function (id, chunkIdx, chunkSize) {\n        var xhr = handler._getXhr(id, chunkIdx),\n            name = getName(id),\n            progressCalculator = {\n          simple: function (loaded, total) {\n            var fileSize = getSize(id);\n\n            if (loaded === total) {\n              onProgress(id, name, fileSize, fileSize);\n            } else {\n              onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n            }\n          },\n          chunked: function (loaded, total) {\n            var chunkProgress = handler._getFileState(id).temp.chunkProgress,\n                totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded,\n                loadedForRequest = loaded,\n                totalForRequest = total,\n                totalFileSize = getSize(id),\n                estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize),\n                totalLoadedForFile = totalSuccessfullyLoadedForFile;\n\n            chunkProgress[chunkIdx] = estActualChunkLoaded;\n            qq.each(chunkProgress, function (chunkIdx, chunkLoaded) {\n              totalLoadedForFile += chunkLoaded;\n            });\n            onProgress(id, name, totalLoadedForFile, totalFileSize);\n          }\n        };\n\n        xhr.upload.onprogress = function (e) {\n          if (e.lengthComputable) {\n            var type = chunkSize == null ? \"simple\" : \"chunked\";\n            progressCalculator[type](e.loaded, e.total);\n          }\n        };\n      },\n      _registerXhr: function (id, optChunkIdx, xhr, optAjaxRequester) {\n        var xhrsId = optChunkIdx == null ? -1 : optChunkIdx,\n            tempState = handler._getFileState(id).temp;\n\n        tempState.xhrs = tempState.xhrs || {};\n        tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n        tempState.xhrs[xhrsId] = xhr;\n\n        if (optAjaxRequester) {\n          tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n        }\n\n        return xhr;\n      },\n      _removeExpiredChunkingRecords: function () {\n        var expirationDays = resume.recordsExpireIn;\n\n        handler._iterateResumeRecords(function (key, uploadData) {\n          var expirationDate = new Date(uploadData.lastUpdated);\n          expirationDate.setDate(expirationDate.getDate() + expirationDays);\n\n          if (expirationDate.getTime() <= Date.now()) {\n            log(\"Removing expired resume record with key \" + key);\n            localStorage.removeItem(key);\n          }\n        });\n      },\n      _shouldChunkThisFile: function (id) {\n        var state = handler._getFileState(id);\n\n        if (state) {\n          if (!state.chunking) {\n            handler.reevaluateChunking(id);\n          }\n\n          return state.chunking.enabled;\n        }\n      }\n    });\n  };\n\n  qq.DeleteFileAjaxRequester = function (o) {\n    \"use strict\";\n\n    var requester,\n        options = {\n      method: \"DELETE\",\n      uuidParamName: \"qquuid\",\n      endpointStore: {},\n      maxConnections: 3,\n      customHeaders: function (id) {\n        return {};\n      },\n      paramsStore: {},\n      cors: {\n        expected: false,\n        sendCredentials: false\n      },\n      log: function (str, level) {},\n      onDelete: function (id) {},\n      onDeleteComplete: function (id, xhrOrXdr, isError) {}\n    };\n    qq.extend(options, o);\n\n    function getMandatedParams() {\n      if (options.method.toUpperCase() === \"POST\") {\n        return {\n          _method: \"DELETE\"\n        };\n      }\n\n      return {};\n    }\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n      acceptHeader: \"application/json\",\n      validMethods: [\"POST\", \"DELETE\"],\n      method: options.method,\n      endpointStore: options.endpointStore,\n      paramsStore: options.paramsStore,\n      mandatedParams: getMandatedParams(),\n      maxConnections: options.maxConnections,\n      customHeaders: function (id) {\n        return options.customHeaders.get(id);\n      },\n      log: options.log,\n      onSend: options.onDelete,\n      onComplete: options.onDeleteComplete,\n      cors: options.cors\n    }));\n    qq.extend(this, {\n      sendDelete: function (id, uuid, additionalMandatedParams) {\n        var additionalOptions = additionalMandatedParams || {};\n        options.log(\"Submitting delete file request for \" + id);\n\n        if (options.method === \"DELETE\") {\n          requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n        } else {\n          additionalOptions[options.uuidParamName] = uuid;\n          requester.initTransport(id).withParams(additionalOptions).send();\n        }\n      }\n    });\n  };\n\n  (function () {\n    function detectSubsampling(img) {\n      var iw = img.naturalWidth,\n          ih = img.naturalHeight,\n          canvas = document.createElement(\"canvas\"),\n          ctx;\n\n      if (iw * ih > 1024 * 1024) {\n        canvas.width = canvas.height = 1;\n        ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, -iw + 1, 0);\n        return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n      } else {\n        return false;\n      }\n    }\n\n    function detectVerticalSquash(img, iw, ih) {\n      var canvas = document.createElement(\"canvas\"),\n          sy = 0,\n          ey = ih,\n          py = ih,\n          ctx,\n          data,\n          alpha,\n          ratio;\n      canvas.width = 1;\n      canvas.height = ih;\n      ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(img, 0, 0);\n      data = ctx.getImageData(0, 0, 1, ih).data;\n\n      while (py > sy) {\n        alpha = data[(py - 1) * 4 + 3];\n\n        if (alpha === 0) {\n          ey = py;\n        } else {\n          sy = py;\n        }\n\n        py = ey + sy >> 1;\n      }\n\n      ratio = py / ih;\n      return ratio === 0 ? 1 : ratio;\n    }\n\n    function renderImageToDataURL(img, blob, options, doSquash) {\n      var canvas = document.createElement(\"canvas\"),\n          mime = options.mime || \"image/jpeg\",\n          promise = new qq.Promise();\n      renderImageToCanvas(img, blob, canvas, options, doSquash).then(function () {\n        promise.success(canvas.toDataURL(mime, options.quality || .8));\n      });\n      return promise;\n    }\n\n    function maybeCalculateDownsampledDimensions(spec) {\n      var maxPixels = 5241e3;\n\n      if (!qq.ios()) {\n        throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n      }\n\n      if (spec.origHeight * spec.origWidth > maxPixels) {\n        return {\n          newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n          newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n        };\n      }\n    }\n\n    function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n      var iw = img.naturalWidth,\n          ih = img.naturalHeight,\n          width = options.width,\n          height = options.height,\n          ctx = canvas.getContext(\"2d\"),\n          promise = new qq.Promise(),\n          modifiedDimensions;\n      ctx.save();\n\n      if (options.resize) {\n        return renderImageToCanvasWithCustomResizer({\n          blob: blob,\n          canvas: canvas,\n          image: img,\n          imageHeight: ih,\n          imageWidth: iw,\n          orientation: options.orientation,\n          resize: options.resize,\n          targetHeight: height,\n          targetWidth: width\n        });\n      }\n\n      if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n        modifiedDimensions = maybeCalculateDownsampledDimensions({\n          origWidth: width,\n          origHeight: height\n        });\n\n        if (modifiedDimensions) {\n          qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n          width = modifiedDimensions.newWidth;\n          height = modifiedDimensions.newHeight;\n        }\n      }\n\n      transformCoordinate(canvas, width, height, options.orientation);\n\n      if (qq.ios()) {\n        (function () {\n          if (detectSubsampling(img)) {\n            iw /= 2;\n            ih /= 2;\n          }\n\n          var d = 1024,\n              tmpCanvas = document.createElement(\"canvas\"),\n              vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1,\n              dw = Math.ceil(d * width / iw),\n              dh = Math.ceil(d * height / ih / vertSquashRatio),\n              sy = 0,\n              dy = 0,\n              tmpCtx,\n              sx,\n              dx;\n          tmpCanvas.width = tmpCanvas.height = d;\n          tmpCtx = tmpCanvas.getContext(\"2d\");\n\n          while (sy < ih) {\n            sx = 0;\n            dx = 0;\n\n            while (sx < iw) {\n              tmpCtx.clearRect(0, 0, d, d);\n              tmpCtx.drawImage(img, -sx, -sy);\n              ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n              sx += d;\n              dx += dw;\n            }\n\n            sy += d;\n            dy += dh;\n          }\n\n          ctx.restore();\n          tmpCanvas = tmpCtx = null;\n        })();\n      } else {\n        ctx.drawImage(img, 0, 0, width, height);\n      }\n\n      canvas.qqImageRendered && canvas.qqImageRendered();\n      promise.success();\n      return promise;\n    }\n\n    function renderImageToCanvasWithCustomResizer(resizeInfo) {\n      var blob = resizeInfo.blob,\n          image = resizeInfo.image,\n          imageHeight = resizeInfo.imageHeight,\n          imageWidth = resizeInfo.imageWidth,\n          orientation = resizeInfo.orientation,\n          promise = new qq.Promise(),\n          resize = resizeInfo.resize,\n          sourceCanvas = document.createElement(\"canvas\"),\n          sourceCanvasContext = sourceCanvas.getContext(\"2d\"),\n          targetCanvas = resizeInfo.canvas,\n          targetHeight = resizeInfo.targetHeight,\n          targetWidth = resizeInfo.targetWidth;\n      transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n      targetCanvas.height = targetHeight;\n      targetCanvas.width = targetWidth;\n      sourceCanvasContext.drawImage(image, 0, 0);\n      resize({\n        blob: blob,\n        height: targetHeight,\n        image: image,\n        sourceCanvas: sourceCanvas,\n        targetCanvas: targetCanvas,\n        width: targetWidth\n      }).then(function success() {\n        targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n        promise.success();\n      }, promise.failure);\n      return promise;\n    }\n\n    function transformCoordinate(canvas, width, height, orientation) {\n      switch (orientation) {\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n          canvas.width = height;\n          canvas.height = width;\n          break;\n\n        default:\n          canvas.width = width;\n          canvas.height = height;\n      }\n\n      var ctx = canvas.getContext(\"2d\");\n\n      switch (orientation) {\n        case 2:\n          ctx.translate(width, 0);\n          ctx.scale(-1, 1);\n          break;\n\n        case 3:\n          ctx.translate(width, height);\n          ctx.rotate(Math.PI);\n          break;\n\n        case 4:\n          ctx.translate(0, height);\n          ctx.scale(1, -1);\n          break;\n\n        case 5:\n          ctx.rotate(.5 * Math.PI);\n          ctx.scale(1, -1);\n          break;\n\n        case 6:\n          ctx.rotate(.5 * Math.PI);\n          ctx.translate(0, -height);\n          break;\n\n        case 7:\n          ctx.rotate(.5 * Math.PI);\n          ctx.translate(width, -height);\n          ctx.scale(-1, 1);\n          break;\n\n        case 8:\n          ctx.rotate(-.5 * Math.PI);\n          ctx.translate(-width, 0);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    function MegaPixImage(srcImage, errorCallback) {\n      var self = this;\n\n      if (window.Blob && srcImage instanceof Blob) {\n        (function () {\n          var img = new Image(),\n              URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n\n          if (!URL) {\n            throw Error(\"No createObjectURL function found to create blob url\");\n          }\n\n          img.src = URL.createObjectURL(srcImage);\n          self.blob = srcImage;\n          srcImage = img;\n        })();\n      }\n\n      if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n        srcImage.onload = function () {\n          var listeners = self.imageLoadListeners;\n\n          if (listeners) {\n            self.imageLoadListeners = null;\n            setTimeout(function () {\n              for (var i = 0, len = listeners.length; i < len; i++) {\n                listeners[i]();\n              }\n            }, 0);\n          }\n        };\n\n        srcImage.onerror = errorCallback;\n        this.imageLoadListeners = [];\n      }\n\n      this.srcImage = srcImage;\n    }\n\n    MegaPixImage.prototype.render = function (target, options) {\n      options = options || {};\n      var self = this,\n          imgWidth = this.srcImage.naturalWidth,\n          imgHeight = this.srcImage.naturalHeight,\n          width = options.width,\n          height = options.height,\n          maxWidth = options.maxWidth,\n          maxHeight = options.maxHeight,\n          doSquash = !this.blob || this.blob.type === \"image/jpeg\",\n          tagName = target.tagName.toLowerCase(),\n          opt;\n\n      if (this.imageLoadListeners) {\n        this.imageLoadListeners.push(function () {\n          self.render(target, options);\n        });\n        return;\n      }\n\n      if (width && !height) {\n        height = imgHeight * width / imgWidth << 0;\n      } else if (height && !width) {\n        width = imgWidth * height / imgHeight << 0;\n      } else {\n        width = imgWidth;\n        height = imgHeight;\n      }\n\n      if (maxWidth && width > maxWidth) {\n        width = maxWidth;\n        height = imgHeight * width / imgWidth << 0;\n      }\n\n      if (maxHeight && height > maxHeight) {\n        height = maxHeight;\n        width = imgWidth * height / imgHeight << 0;\n      }\n\n      opt = {\n        width: width,\n        height: height\n      }, qq.each(options, function (optionsKey, optionsValue) {\n        opt[optionsKey] = optionsValue;\n      });\n\n      if (tagName === \"img\") {\n        (function () {\n          var oldTargetSrc = target.src;\n          renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function (dataUri) {\n            target.src = dataUri;\n            oldTargetSrc === target.src && target.onload();\n          });\n        })();\n      } else if (tagName === \"canvas\") {\n        renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n      }\n\n      if (typeof this.onrender === \"function\") {\n        this.onrender(target);\n      }\n    };\n\n    qq.MegaPixImage = MegaPixImage;\n  })();\n\n  qq.ImageGenerator = function (log) {\n    \"use strict\";\n\n    function isImg(el) {\n      return el.tagName.toLowerCase() === \"img\";\n    }\n\n    function isCanvas(el) {\n      return el.tagName.toLowerCase() === \"canvas\";\n    }\n\n    function isImgCorsSupported() {\n      return new Image().crossOrigin !== undefined;\n    }\n\n    function isCanvasSupported() {\n      var canvas = document.createElement(\"canvas\");\n      return canvas.getContext && canvas.getContext(\"2d\");\n    }\n\n    function determineMimeOfFileName(nameWithPath) {\n      var pathSegments = nameWithPath.split(\"/\"),\n          name = pathSegments[pathSegments.length - 1].split(\"?\")[0],\n          extension = qq.getExtension(name);\n      extension = extension && extension.toLowerCase();\n\n      switch (extension) {\n        case \"jpeg\":\n        case \"jpg\":\n          return \"image/jpeg\";\n\n        case \"png\":\n          return \"image/png\";\n\n        case \"bmp\":\n          return \"image/bmp\";\n\n        case \"gif\":\n          return \"image/gif\";\n\n        case \"tiff\":\n        case \"tif\":\n          return \"image/tiff\";\n      }\n    }\n\n    function isCrossOrigin(url) {\n      var targetAnchor = document.createElement(\"a\"),\n          targetProtocol,\n          targetHostname,\n          targetPort;\n      targetAnchor.href = url;\n      targetProtocol = targetAnchor.protocol;\n      targetPort = targetAnchor.port;\n      targetHostname = targetAnchor.hostname;\n\n      if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n        return true;\n      }\n\n      if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n        return true;\n      }\n\n      if (targetPort !== window.location.port && !qq.ie()) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function registerImgLoadListeners(img, promise) {\n      img.onload = function () {\n        img.onload = null;\n        img.onerror = null;\n        promise.success(img);\n      };\n\n      img.onerror = function () {\n        img.onload = null;\n        img.onerror = null;\n        log(\"Problem drawing thumbnail!\", \"error\");\n        promise.failure(img, \"Problem drawing thumbnail!\");\n      };\n    }\n\n    function registerCanvasDrawImageListener(canvas, promise) {\n      canvas.qqImageRendered = function () {\n        promise.success(canvas);\n      };\n    }\n\n    function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n      var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n\n      if (isImg(imgOrCanvas)) {\n        registerImgLoadListeners(imgOrCanvas, promise);\n      } else if (isCanvas(imgOrCanvas)) {\n        registerCanvasDrawImageListener(imgOrCanvas, promise);\n      } else {\n        promise.failure(imgOrCanvas);\n        log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n      }\n\n      return registered;\n    }\n\n    function draw(fileOrBlob, container, options) {\n      var drawPreview = new qq.Promise(),\n          identifier = new qq.Identify(fileOrBlob, log),\n          maxSize = options.maxSize,\n          orient = options.orient == null ? true : options.orient,\n          megapixErrorHandler = function () {\n        container.onerror = null;\n        container.onload = null;\n        log(\"Could not render preview, file may be too large!\", \"error\");\n        drawPreview.failure(container, \"Browser cannot render image!\");\n      };\n\n      identifier.isPreviewable().then(function (mime) {\n        var dummyExif = {\n          parse: function () {\n            return new qq.Promise().success();\n          }\n        },\n            exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif,\n            mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n\n        if (registerThumbnailRenderedListener(container, drawPreview)) {\n          exif.parse().then(function (exif) {\n            var orientation = exif && exif.Orientation;\n            mpImg.render(container, {\n              maxWidth: maxSize,\n              maxHeight: maxSize,\n              orientation: orientation,\n              mime: mime,\n              resize: options.customResizeFunction\n            });\n          }, function (failureMsg) {\n            log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n            mpImg.render(container, {\n              maxWidth: maxSize,\n              maxHeight: maxSize,\n              mime: mime,\n              resize: options.customResizeFunction\n            });\n          });\n        }\n      }, function () {\n        log(\"Not previewable\");\n        drawPreview.failure(container, \"Not previewable\");\n      });\n      return drawPreview;\n    }\n\n    function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n      var tempImg = new Image(),\n          tempImgRender = new qq.Promise();\n      registerThumbnailRenderedListener(tempImg, tempImgRender);\n\n      if (isCrossOrigin(url)) {\n        tempImg.crossOrigin = \"anonymous\";\n      }\n\n      tempImg.src = url;\n      tempImgRender.then(function rendered() {\n        registerThumbnailRenderedListener(canvasOrImg, draw);\n        var mpImg = new qq.MegaPixImage(tempImg);\n        mpImg.render(canvasOrImg, {\n          maxWidth: maxSize,\n          maxHeight: maxSize,\n          mime: determineMimeOfFileName(url),\n          resize: customResizeFunction\n        });\n      }, draw.failure);\n    }\n\n    function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n      registerThumbnailRenderedListener(img, draw);\n      qq(img).css({\n        maxWidth: maxSize + \"px\",\n        maxHeight: maxSize + \"px\"\n      });\n      img.src = url;\n    }\n\n    function drawFromUrl(url, container, options) {\n      var draw = new qq.Promise(),\n          scale = options.scale,\n          maxSize = scale ? options.maxSize : null;\n\n      if (scale && isImg(container)) {\n        if (isCanvasSupported()) {\n          if (isCrossOrigin(url) && !isImgCorsSupported()) {\n            drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n          } else {\n            drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n          }\n        } else {\n          drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n        }\n      } else if (isCanvas(container)) {\n        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n      } else if (registerThumbnailRenderedListener(container, draw)) {\n        container.src = url;\n      }\n\n      return draw;\n    }\n\n    qq.extend(this, {\n      generate: function (fileBlobOrUrl, container, options) {\n        if (qq.isString(fileBlobOrUrl)) {\n          log(\"Attempting to update thumbnail based on server response.\");\n          return drawFromUrl(fileBlobOrUrl, container, options || {});\n        } else {\n          log(\"Attempting to draw client-side image preview.\");\n          return draw(fileBlobOrUrl, container, options || {});\n        }\n      }\n    });\n    this._testing = {};\n    this._testing.isImg = isImg;\n    this._testing.isCanvas = isCanvas;\n    this._testing.isCrossOrigin = isCrossOrigin;\n    this._testing.determineMimeOfFileName = determineMimeOfFileName;\n  };\n\n  qq.Exif = function (fileOrBlob, log) {\n    \"use strict\";\n\n    var TAG_IDS = [274],\n        TAG_INFO = {\n      274: {\n        name: \"Orientation\",\n        bytes: 2\n      }\n    };\n\n    function parseLittleEndian(hex) {\n      var result = 0,\n          pow = 0;\n\n      while (hex.length > 0) {\n        result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n        hex = hex.substring(2, hex.length);\n        pow += 8;\n      }\n\n      return result;\n    }\n\n    function seekToApp1(offset, promise) {\n      var theOffset = offset,\n          thePromise = promise;\n\n      if (theOffset === undefined) {\n        theOffset = 2;\n        thePromise = new qq.Promise();\n      }\n\n      qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function (hex) {\n        var match = /^ffe([0-9])/.exec(hex),\n            segmentLength;\n\n        if (match) {\n          if (match[1] !== \"1\") {\n            segmentLength = parseInt(hex.slice(4, 8), 16);\n            seekToApp1(theOffset + segmentLength + 2, thePromise);\n          } else {\n            thePromise.success(theOffset);\n          }\n        } else {\n          thePromise.failure(\"No EXIF header to be found!\");\n        }\n      });\n      return thePromise;\n    }\n\n    function getApp1Offset() {\n      var promise = new qq.Promise();\n      qq.readBlobToHex(fileOrBlob, 0, 6).then(function (hex) {\n        if (hex.indexOf(\"ffd8\") !== 0) {\n          promise.failure(\"Not a valid JPEG!\");\n        } else {\n          seekToApp1().then(function (offset) {\n            promise.success(offset);\n          }, function (error) {\n            promise.failure(error);\n          });\n        }\n      });\n      return promise;\n    }\n\n    function isLittleEndian(app1Start) {\n      var promise = new qq.Promise();\n      qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function (hex) {\n        promise.success(hex === \"4949\");\n      });\n      return promise;\n    }\n\n    function getDirEntryCount(app1Start, littleEndian) {\n      var promise = new qq.Promise();\n      qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function (hex) {\n        if (littleEndian) {\n          return promise.success(parseLittleEndian(hex));\n        } else {\n          promise.success(parseInt(hex, 16));\n        }\n      });\n      return promise;\n    }\n\n    function getIfd(app1Start, dirEntries) {\n      var offset = app1Start + 20,\n          bytes = dirEntries * 12;\n      return qq.readBlobToHex(fileOrBlob, offset, bytes);\n    }\n\n    function getDirEntries(ifdHex) {\n      var entries = [],\n          offset = 0;\n\n      while (offset + 24 <= ifdHex.length) {\n        entries.push(ifdHex.slice(offset, offset + 24));\n        offset += 24;\n      }\n\n      return entries;\n    }\n\n    function getTagValues(littleEndian, dirEntries) {\n      var TAG_VAL_OFFSET = 16,\n          tagsToFind = qq.extend([], TAG_IDS),\n          vals = {};\n      qq.each(dirEntries, function (idx, entry) {\n        var idHex = entry.slice(0, 4),\n            id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16),\n            tagsToFindIdx = tagsToFind.indexOf(id),\n            tagValHex,\n            tagName,\n            tagValLength;\n\n        if (tagsToFindIdx >= 0) {\n          tagName = TAG_INFO[id].name;\n          tagValLength = TAG_INFO[id].bytes;\n          tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n          vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n          tagsToFind.splice(tagsToFindIdx, 1);\n        }\n\n        if (tagsToFind.length === 0) {\n          return false;\n        }\n      });\n      return vals;\n    }\n\n    qq.extend(this, {\n      parse: function () {\n        var parser = new qq.Promise(),\n            onParseFailure = function (message) {\n          log(qq.format(\"EXIF header parse failed: '{}' \", message));\n          parser.failure(message);\n        };\n\n        getApp1Offset().then(function (app1Offset) {\n          log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n          isLittleEndian(app1Offset).then(function (littleEndian) {\n            log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n            getDirEntryCount(app1Offset, littleEndian).then(function (dirEntryCount) {\n              log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n              getIfd(app1Offset, dirEntryCount).then(function (ifdHex) {\n                var dirEntries = getDirEntries(ifdHex),\n                    tagValues = getTagValues(littleEndian, dirEntries);\n                log(\"Successfully parsed some EXIF tags\");\n                parser.success(tagValues);\n              }, onParseFailure);\n            }, onParseFailure);\n          }, onParseFailure);\n        }, onParseFailure);\n        return parser;\n      }\n    });\n    this._testing = {};\n    this._testing.parseLittleEndian = parseLittleEndian;\n  };\n\n  qq.Identify = function (fileOrBlob, log) {\n    \"use strict\";\n\n    function isIdentifiable(magicBytes, questionableBytes) {\n      var identifiable = false,\n          magicBytesEntries = [].concat(magicBytes);\n      qq.each(magicBytesEntries, function (idx, magicBytesArrayEntry) {\n        if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n          identifiable = true;\n          return false;\n        }\n      });\n      return identifiable;\n    }\n\n    qq.extend(this, {\n      isPreviewable: function () {\n        var self = this,\n            identifier = new qq.Promise(),\n            previewable = false,\n            name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n        log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n        log(\"First pass: check type attribute of blob object.\");\n\n        if (this.isPreviewableSync()) {\n          log(\"Second pass: check for magic bytes in file header.\");\n          qq.readBlobToHex(fileOrBlob, 0, 4).then(function (hex) {\n            qq.each(self.PREVIEWABLE_MIME_TYPES, function (mime, bytes) {\n              if (isIdentifiable(bytes, hex)) {\n                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                  previewable = true;\n                  identifier.success(mime);\n                }\n\n                return false;\n              }\n            });\n            log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n\n            if (!previewable) {\n              identifier.failure();\n            }\n          }, function () {\n            log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n            identifier.failure();\n          });\n        } else {\n          identifier.failure();\n        }\n\n        return identifier;\n      },\n      isPreviewableSync: function () {\n        var fileMime = fileOrBlob.type,\n            isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0,\n            previewable = false,\n            name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\n        if (isRecognizedImage) {\n          if (fileMime === \"image/tiff\") {\n            previewable = qq.supportedFeatures.tiffPreviews;\n          } else {\n            previewable = true;\n          }\n        }\n\n        !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n        return previewable;\n      }\n    });\n  };\n\n  qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n    \"image/jpeg\": \"ffd8ff\",\n    \"image/gif\": \"474946\",\n    \"image/png\": \"89504e\",\n    \"image/bmp\": \"424d\",\n    \"image/tiff\": [\"49492a00\", \"4d4d002a\"]\n  };\n\n  qq.ImageValidation = function (blob, log) {\n    \"use strict\";\n\n    function hasNonZeroLimits(limits) {\n      var atLeastOne = false;\n      qq.each(limits, function (limit, value) {\n        if (value > 0) {\n          atLeastOne = true;\n          return false;\n        }\n      });\n      return atLeastOne;\n    }\n\n    function getWidthHeight() {\n      var sizeDetermination = new qq.Promise();\n      new qq.Identify(blob, log).isPreviewable().then(function () {\n        var image = new Image(),\n            url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n\n        if (url) {\n          image.onerror = function () {\n            log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n            sizeDetermination.failure();\n          };\n\n          image.onload = function () {\n            sizeDetermination.success({\n              width: this.width,\n              height: this.height\n            });\n          };\n\n          image.src = url.createObjectURL(blob);\n        } else {\n          log(\"No createObjectURL function available to generate image URL!\", \"error\");\n          sizeDetermination.failure();\n        }\n      }, sizeDetermination.failure);\n      return sizeDetermination;\n    }\n\n    function getFailingLimit(limits, dimensions) {\n      var failingLimit;\n      qq.each(limits, function (limitName, limitValue) {\n        if (limitValue > 0) {\n          var limitMatcher = /(max|min)(Width|Height)/.exec(limitName),\n              dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1),\n              actualValue = dimensions[dimensionPropName];\n\n          switch (limitMatcher[1]) {\n            case \"min\":\n              if (actualValue < limitValue) {\n                failingLimit = limitName;\n                return false;\n              }\n\n              break;\n\n            case \"max\":\n              if (actualValue > limitValue) {\n                failingLimit = limitName;\n                return false;\n              }\n\n              break;\n          }\n        }\n      });\n      return failingLimit;\n    }\n\n    this.validate = function (limits) {\n      var validationEffort = new qq.Promise();\n      log(\"Attempting to validate image.\");\n\n      if (hasNonZeroLimits(limits)) {\n        getWidthHeight().then(function (dimensions) {\n          var failingLimit = getFailingLimit(limits, dimensions);\n\n          if (failingLimit) {\n            validationEffort.failure(failingLimit);\n          } else {\n            validationEffort.success();\n          }\n        }, validationEffort.success);\n      } else {\n        validationEffort.success();\n      }\n\n      return validationEffort;\n    };\n  };\n\n  qq.Session = function (spec) {\n    \"use strict\";\n\n    var options = {\n      endpoint: null,\n      params: {},\n      customHeaders: {},\n      cors: {},\n      addFileRecord: function (sessionData) {},\n      log: function (message, level) {}\n    };\n    qq.extend(options, spec, true);\n\n    function isJsonResponseValid(response) {\n      if (qq.isArray(response)) {\n        return true;\n      }\n\n      options.log(\"Session response is not an array.\", \"error\");\n    }\n\n    function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n      var someItemsIgnored = false;\n      success = success && isJsonResponseValid(fileItems);\n\n      if (success) {\n        qq.each(fileItems, function (idx, fileItem) {\n          if (fileItem.uuid == null) {\n            someItemsIgnored = true;\n            options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n          } else if (fileItem.name == null) {\n            someItemsIgnored = true;\n            options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n          } else {\n            try {\n              options.addFileRecord(fileItem);\n              return true;\n            } catch (err) {\n              someItemsIgnored = true;\n              options.log(err.message, \"error\");\n            }\n          }\n\n          return false;\n        });\n      }\n\n      promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n    }\n\n    this.refresh = function () {\n      var refreshEffort = new qq.Promise(),\n          refreshCompleteCallback = function (response, success, xhrOrXdr) {\n        handleFileItems(response, success, xhrOrXdr, refreshEffort);\n      },\n          requesterOptions = qq.extend({}, options),\n          requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n        onComplete: refreshCompleteCallback\n      }));\n\n      requester.queryServer();\n      return refreshEffort;\n    };\n  };\n\n  qq.SessionAjaxRequester = function (spec) {\n    \"use strict\";\n\n    var requester,\n        options = {\n      endpoint: null,\n      customHeaders: {},\n      params: {},\n      cors: {\n        expected: false,\n        sendCredentials: false\n      },\n      onComplete: function (response, success, xhrOrXdr) {},\n      log: function (str, level) {}\n    };\n    qq.extend(options, spec);\n\n    function onComplete(id, xhrOrXdr, isError) {\n      var response = null;\n\n      if (xhrOrXdr.responseText != null) {\n        try {\n          response = qq.parseJson(xhrOrXdr.responseText);\n        } catch (err) {\n          options.log(\"Problem parsing session response: \" + err.message, \"error\");\n          isError = true;\n        }\n      }\n\n      options.onComplete(response, !isError, xhrOrXdr);\n    }\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n      acceptHeader: \"application/json\",\n      validMethods: [\"GET\"],\n      method: \"GET\",\n      endpointStore: {\n        get: function () {\n          return options.endpoint;\n        }\n      },\n      customHeaders: options.customHeaders,\n      log: options.log,\n      onComplete: onComplete,\n      cors: options.cors\n    }));\n    qq.extend(this, {\n      queryServer: function () {\n        var params = qq.extend({}, options.params);\n        options.log(\"Session query request.\");\n        requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n      }\n    });\n  };\n\n  qq.Scaler = function (spec, log) {\n    \"use strict\";\n\n    var self = this,\n        customResizeFunction = spec.customResizer,\n        includeOriginal = spec.sendOriginal,\n        orient = spec.orient,\n        defaultType = spec.defaultType,\n        defaultQuality = spec.defaultQuality / 100,\n        failedToScaleText = spec.failureText,\n        includeExif = spec.includeExif,\n        sizes = this._getSortedSizes(spec.sizes);\n\n    qq.extend(this, {\n      enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n      getFileRecords: function (originalFileUuid, originalFileName, originalBlobOrBlobData) {\n        var self = this,\n            records = [],\n            originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData,\n            identifier = new qq.Identify(originalBlob, log);\n\n        if (identifier.isPreviewableSync()) {\n          qq.each(sizes, function (idx, sizeRecord) {\n            var outputType = self._determineOutputType({\n              defaultType: defaultType,\n              requestedType: sizeRecord.type,\n              refType: originalBlob.type\n            });\n\n            records.push({\n              uuid: qq.getUniqueId(),\n              name: self._getName(originalFileName, {\n                name: sizeRecord.name,\n                type: outputType,\n                refType: originalBlob.type\n              }),\n              blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                customResizeFunction: customResizeFunction,\n                maxSize: sizeRecord.maxSize,\n                orient: orient,\n                type: outputType,\n                quality: defaultQuality,\n                failedText: failedToScaleText,\n                includeExif: includeExif,\n                log: log\n              }))\n            });\n          });\n          records.push({\n            uuid: originalFileUuid,\n            name: originalFileName,\n            size: originalBlob.size,\n            blob: includeOriginal ? originalBlob : null\n          });\n        } else {\n          records.push({\n            uuid: originalFileUuid,\n            name: originalFileName,\n            size: originalBlob.size,\n            blob: originalBlob\n          });\n        }\n\n        return records;\n      },\n      handleNewFile: function (file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n        var self = this,\n            buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId,\n            scaledIds = [],\n            originalId = null,\n            addFileToHandler = api.addFileToHandler,\n            uploadData = api.uploadData,\n            paramsStore = api.paramsStore,\n            proxyGroupId = qq.getUniqueId();\n        qq.each(self.getFileRecords(uuid, name, file), function (idx, record) {\n          var blobSize = record.size,\n              id;\n\n          if (record.blob instanceof qq.BlobProxy) {\n            blobSize = -1;\n          }\n\n          id = uploadData.addFile({\n            uuid: record.uuid,\n            name: record.name,\n            size: blobSize,\n            batchId: batchId,\n            proxyGroupId: proxyGroupId\n          });\n\n          if (record.blob instanceof qq.BlobProxy) {\n            scaledIds.push(id);\n          } else {\n            originalId = id;\n          }\n\n          if (record.blob) {\n            addFileToHandler(id, record.blob);\n            fileList.push({\n              id: id,\n              file: record.blob\n            });\n          } else {\n            uploadData.setStatus(id, qq.status.REJECTED);\n          }\n        });\n\n        if (originalId !== null) {\n          qq.each(scaledIds, function (idx, scaledId) {\n            var params = {\n              qqparentuuid: uploadData.retrieve({\n                id: originalId\n              }).uuid,\n              qqparentsize: uploadData.retrieve({\n                id: originalId\n              }).size\n            };\n            params[uuidParamName] = uploadData.retrieve({\n              id: scaledId\n            }).uuid;\n            uploadData.setParentId(scaledId, originalId);\n            paramsStore.addReadOnly(scaledId, params);\n          });\n\n          if (scaledIds.length) {\n            (function () {\n              var param = {};\n              param[uuidParamName] = uploadData.retrieve({\n                id: originalId\n              }).uuid;\n              paramsStore.addReadOnly(originalId, param);\n            })();\n          }\n        }\n      }\n    });\n  };\n\n  qq.extend(qq.Scaler.prototype, {\n    scaleImage: function (id, specs, api) {\n      \"use strict\";\n\n      if (!qq.supportedFeatures.scaling) {\n        throw new qq.Error(\"Scaling is not supported in this browser!\");\n      }\n\n      var scalingEffort = new qq.Promise(),\n          log = api.log,\n          file = api.getFile(id),\n          uploadData = api.uploadData.retrieve({\n        id: id\n      }),\n          name = uploadData && uploadData.name,\n          uuid = uploadData && uploadData.uuid,\n          scalingOptions = {\n        customResizer: specs.customResizer,\n        sendOriginal: false,\n        orient: specs.orient,\n        defaultType: specs.type || null,\n        defaultQuality: specs.quality,\n        failedToScaleText: \"Unable to scale\",\n        sizes: [{\n          name: \"\",\n          maxSize: specs.maxSize\n        }]\n      },\n          scaler = new qq.Scaler(scalingOptions, log);\n\n      if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n        scalingEffort.failure();\n        log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n      } else {\n        qq.bind(function () {\n          var record = scaler.getFileRecords(uuid, name, file)[0];\n\n          if (record && record.blob instanceof qq.BlobProxy) {\n            record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n          } else {\n            log(id + \" is not a scalable image!\", \"error\");\n            scalingEffort.failure();\n          }\n        }, this)();\n      }\n\n      return scalingEffort;\n    },\n    _determineOutputType: function (spec) {\n      \"use strict\";\n\n      var requestedType = spec.requestedType,\n          defaultType = spec.defaultType,\n          referenceType = spec.refType;\n\n      if (!defaultType && !requestedType) {\n        if (referenceType !== \"image/jpeg\") {\n          return \"image/png\";\n        }\n\n        return referenceType;\n      }\n\n      if (!requestedType) {\n        return defaultType;\n      }\n\n      if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n        if (requestedType === \"image/tiff\") {\n          return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n        }\n\n        return requestedType;\n      }\n\n      return defaultType;\n    },\n    _getName: function (originalName, scaledVersionProperties) {\n      \"use strict\";\n\n      var startOfExt = originalName.lastIndexOf(\".\"),\n          versionType = scaledVersionProperties.type || \"image/png\",\n          referenceType = scaledVersionProperties.refType,\n          scaledName = \"\",\n          scaledExt = qq.getExtension(originalName),\n          nameAppendage = \"\";\n\n      if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n        nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n      }\n\n      if (startOfExt >= 0) {\n        scaledName = originalName.substr(0, startOfExt);\n\n        if (referenceType !== versionType) {\n          scaledExt = versionType.split(\"/\")[1];\n        }\n\n        scaledName += nameAppendage + \".\" + scaledExt;\n      } else {\n        scaledName = originalName + nameAppendage;\n      }\n\n      return scaledName;\n    },\n    _getSortedSizes: function (sizes) {\n      \"use strict\";\n\n      sizes = qq.extend([], sizes);\n      return sizes.sort(function (a, b) {\n        if (a.maxSize > b.maxSize) {\n          return 1;\n        }\n\n        if (a.maxSize < b.maxSize) {\n          return -1;\n        }\n\n        return 0;\n      });\n    },\n    _generateScaledImage: function (spec, sourceFile) {\n      \"use strict\";\n\n      var self = this,\n          customResizeFunction = spec.customResizeFunction,\n          log = spec.log,\n          maxSize = spec.maxSize,\n          orient = spec.orient,\n          type = spec.type,\n          quality = spec.quality,\n          failedText = spec.failedText,\n          includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\",\n          scalingEffort = new qq.Promise(),\n          imageGenerator = new qq.ImageGenerator(log),\n          canvas = document.createElement(\"canvas\");\n      log(\"Attempting to generate scaled version for \" + sourceFile.name);\n      imageGenerator.generate(sourceFile, canvas, {\n        maxSize: maxSize,\n        orient: orient,\n        customResizeFunction: customResizeFunction\n      }).then(function () {\n        var scaledImageDataUri = canvas.toDataURL(type, quality),\n            signalSuccess = function () {\n          log(\"Success generating scaled version for \" + sourceFile.name);\n          var blob = qq.dataUriToBlob(scaledImageDataUri);\n          scalingEffort.success(blob);\n        };\n\n        if (includeExif) {\n          self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function (scaledImageDataUriWithExif) {\n            scaledImageDataUri = scaledImageDataUriWithExif;\n            signalSuccess();\n          }, function () {\n            log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n            signalSuccess();\n          });\n        } else {\n          signalSuccess();\n        }\n      }, function () {\n        log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n        scalingEffort.failure(failedText);\n      });\n      return scalingEffort;\n    },\n    _insertExifHeader: function (originalImage, scaledImageDataUri, log) {\n      \"use strict\";\n\n      var reader = new FileReader(),\n          insertionEffort = new qq.Promise(),\n          originalImageDataUri = \"\";\n\n      reader.onload = function () {\n        originalImageDataUri = reader.result;\n        insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n      };\n\n      reader.onerror = function () {\n        log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n        insertionEffort.failure();\n      };\n\n      reader.readAsDataURL(originalImage);\n      return insertionEffort;\n    },\n    _dataUriToBlob: function (dataUri) {\n      \"use strict\";\n\n      var byteString, mimeString, arrayBuffer, intArray;\n\n      if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n        byteString = atob(dataUri.split(\",\")[1]);\n      } else {\n        byteString = decodeURI(dataUri.split(\",\")[1]);\n      }\n\n      mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n      arrayBuffer = new ArrayBuffer(byteString.length);\n      intArray = new Uint8Array(arrayBuffer);\n      qq.each(byteString, function (idx, character) {\n        intArray[idx] = character.charCodeAt(0);\n      });\n      return this._createBlob(arrayBuffer, mimeString);\n    },\n    _createBlob: function (data, mime) {\n      \"use strict\";\n\n      var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,\n          blobBuilder = BlobBuilder && new BlobBuilder();\n\n      if (blobBuilder) {\n        blobBuilder.append(data);\n        return blobBuilder.getBlob(mime);\n      } else {\n        return new Blob([data], {\n          type: mime\n        });\n      }\n    }\n  });\n\n  qq.ExifRestorer = function () {\n    var ExifRestorer = {};\n    ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n\n    ExifRestorer.encode64 = function (input) {\n      var output = \"\",\n          chr1,\n          chr2,\n          chr3 = \"\",\n          enc1,\n          enc2,\n          enc3,\n          enc4 = \"\",\n          i = 0;\n\n      do {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = \"\";\n        enc1 = enc2 = enc3 = enc4 = \"\";\n      } while (i < input.length);\n\n      return output;\n    };\n\n    ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {\n      var expectedBase64Header = \"data:image/jpeg;base64,\";\n\n      if (!origFileBase64.match(expectedBase64Header)) {\n        return resizedFileBase64;\n      }\n\n      var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n      var segments = this.slice2Segments(rawImage);\n      var image = this.exifManipulation(resizedFileBase64, segments);\n      return expectedBase64Header + this.encode64(image);\n    };\n\n    ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {\n      var exifArray = this.getExifArray(segments),\n          newImageArray = this.insertExif(resizedFileBase64, exifArray),\n          aBuffer = new Uint8Array(newImageArray);\n      return aBuffer;\n    };\n\n    ExifRestorer.getExifArray = function (segments) {\n      var seg;\n\n      for (var x = 0; x < segments.length; x++) {\n        seg = segments[x];\n\n        if (seg[0] == 255 & seg[1] == 225) {\n          return seg;\n        }\n      }\n\n      return [];\n    };\n\n    ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {\n      var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"),\n          buf = this.decode64(imageData),\n          separatePoint = buf.indexOf(255, 3),\n          mae = buf.slice(0, separatePoint),\n          ato = buf.slice(separatePoint),\n          array = mae;\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    };\n\n    ExifRestorer.slice2Segments = function (rawImageArray) {\n      var head = 0,\n          segments = [];\n\n      while (1) {\n        if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n          break;\n        }\n\n        if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n          head += 2;\n        } else {\n          var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],\n              endPoint = head + length + 2,\n              seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n\n      return segments;\n    };\n\n    ExifRestorer.decode64 = function (input) {\n      var output = \"\",\n          chr1,\n          chr2,\n          chr3 = \"\",\n          enc1,\n          enc2,\n          enc3,\n          enc4 = \"\",\n          i = 0,\n          buf = [];\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n\n      if (base64test.exec(input)) {\n        throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n      }\n\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n      do {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        buf.push(chr1);\n\n        if (enc3 != 64) {\n          buf.push(chr2);\n        }\n\n        if (enc4 != 64) {\n          buf.push(chr3);\n        }\n\n        chr1 = chr2 = chr3 = \"\";\n        enc1 = enc2 = enc3 = enc4 = \"\";\n      } while (i < input.length);\n\n      return buf;\n    };\n\n    return ExifRestorer;\n  }();\n\n  qq.TotalProgress = function (callback, getSize) {\n    \"use strict\";\n\n    var perFileProgress = {},\n        totalLoaded = 0,\n        totalSize = 0,\n        lastLoadedSent = -1,\n        lastTotalSent = -1,\n        callbackProxy = function (loaded, total) {\n      if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n        callback(loaded, total);\n      }\n\n      lastLoadedSent = loaded;\n      lastTotalSent = total;\n    },\n        noRetryableFiles = function (failed, retryable) {\n      var none = true;\n      qq.each(failed, function (idx, failedId) {\n        if (qq.indexOf(retryable, failedId) >= 0) {\n          none = false;\n          return false;\n        }\n      });\n      return none;\n    },\n        onCancel = function (id) {\n      updateTotalProgress(id, -1, -1);\n      delete perFileProgress[id];\n    },\n        onAllComplete = function (successful, failed, retryable) {\n      if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n        callbackProxy(totalSize, totalSize);\n        this.reset();\n      }\n    },\n        onNew = function (id) {\n      var size = getSize(id);\n\n      if (size > 0) {\n        updateTotalProgress(id, 0, size);\n        perFileProgress[id] = {\n          loaded: 0,\n          total: size\n        };\n      }\n    },\n        updateTotalProgress = function (id, newLoaded, newTotal) {\n      var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0,\n          oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n\n      if (newLoaded === -1 && newTotal === -1) {\n        totalLoaded -= oldLoaded;\n        totalSize -= oldTotal;\n      } else {\n        if (newLoaded) {\n          totalLoaded += newLoaded - oldLoaded;\n        }\n\n        if (newTotal) {\n          totalSize += newTotal - oldTotal;\n        }\n      }\n\n      callbackProxy(totalLoaded, totalSize);\n    };\n\n    qq.extend(this, {\n      onAllComplete: onAllComplete,\n      onStatusChange: function (id, oldStatus, newStatus) {\n        if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n          onCancel(id);\n        } else if (newStatus === qq.status.SUBMITTING) {\n          onNew(id);\n        }\n      },\n      onIndividualProgress: function (id, loaded, total) {\n        updateTotalProgress(id, loaded, total);\n        perFileProgress[id] = {\n          loaded: loaded,\n          total: total\n        };\n      },\n      onNewSize: function (id) {\n        onNew(id);\n      },\n      reset: function () {\n        perFileProgress = {};\n        totalLoaded = 0;\n        totalSize = 0;\n      }\n    });\n  };\n\n  qq.PasteSupport = function (o) {\n    \"use strict\";\n\n    var options, detachPasteHandler;\n    options = {\n      targetElement: null,\n      callbacks: {\n        log: function (message, level) {},\n        pasteReceived: function (blob) {}\n      }\n    };\n\n    function isImage(item) {\n      return item.type && item.type.indexOf(\"image/\") === 0;\n    }\n\n    function registerPasteHandler() {\n      detachPasteHandler = qq(options.targetElement).attach(\"paste\", function (event) {\n        var clipboardData = event.clipboardData;\n\n        if (clipboardData) {\n          qq.each(clipboardData.items, function (idx, item) {\n            if (isImage(item)) {\n              var blob = item.getAsFile();\n              options.callbacks.pasteReceived(blob);\n            }\n          });\n        }\n      });\n    }\n\n    function unregisterPasteHandler() {\n      if (detachPasteHandler) {\n        detachPasteHandler();\n      }\n    }\n\n    qq.extend(options, o);\n    registerPasteHandler();\n    qq.extend(this, {\n      reset: function () {\n        unregisterPasteHandler();\n      }\n    });\n  };\n\n  qq.FormSupport = function (options, startUpload, log) {\n    \"use strict\";\n\n    var self = this,\n        interceptSubmit = options.interceptSubmit,\n        formEl = options.element,\n        autoUpload = options.autoUpload;\n    qq.extend(this, {\n      newEndpoint: null,\n      newAutoUpload: autoUpload,\n      attachedToForm: false,\n      getFormInputsAsObject: function () {\n        if (formEl == null) {\n          return null;\n        }\n\n        return self._form2Obj(formEl);\n      }\n    });\n\n    function determineNewEndpoint(formEl) {\n      if (formEl.getAttribute(\"action\")) {\n        self.newEndpoint = formEl.getAttribute(\"action\");\n      }\n    }\n\n    function validateForm(formEl, nativeSubmit) {\n      if (formEl.checkValidity && !formEl.checkValidity()) {\n        log(\"Form did not pass validation checks - will not upload.\", \"error\");\n        nativeSubmit();\n      } else {\n        return true;\n      }\n    }\n\n    function maybeUploadOnSubmit(formEl) {\n      var nativeSubmit = formEl.submit;\n      qq(formEl).attach(\"submit\", function (event) {\n        event = event || window.event;\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else {\n          event.returnValue = false;\n        }\n\n        validateForm(formEl, nativeSubmit) && startUpload();\n      });\n\n      formEl.submit = function () {\n        validateForm(formEl, nativeSubmit) && startUpload();\n      };\n    }\n\n    function determineFormEl(formEl) {\n      if (formEl) {\n        if (qq.isString(formEl)) {\n          formEl = document.getElementById(formEl);\n        }\n\n        if (formEl) {\n          log(\"Attaching to form element.\");\n          determineNewEndpoint(formEl);\n          interceptSubmit && maybeUploadOnSubmit(formEl);\n        }\n      }\n\n      return formEl;\n    }\n\n    formEl = determineFormEl(formEl);\n    this.attachedToForm = !!formEl;\n  };\n\n  qq.extend(qq.FormSupport.prototype, {\n    _form2Obj: function (form) {\n      \"use strict\";\n\n      var obj = {},\n          notIrrelevantType = function (type) {\n        var irrelevantTypes = [\"button\", \"image\", \"reset\", \"submit\"];\n        return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n      },\n          radioOrCheckbox = function (type) {\n        return qq.indexOf([\"checkbox\", \"radio\"], type.toLowerCase()) >= 0;\n      },\n          ignoreValue = function (el) {\n        if (radioOrCheckbox(el.type) && !el.checked) {\n          return true;\n        }\n\n        return el.disabled && el.type.toLowerCase() !== \"hidden\";\n      },\n          selectValue = function (select) {\n        var value = null;\n        qq.each(qq(select).children(), function (idx, child) {\n          if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n            value = child.value;\n            return false;\n          }\n        });\n        return value;\n      };\n\n      qq.each(form.elements, function (idx, el) {\n        if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n          obj[el.name] = el.value;\n        } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n          var value = selectValue(el);\n\n          if (value !== null) {\n            obj[el.name] = value;\n          }\n        }\n      });\n      return obj;\n    }\n  });\n  qq.traditional = qq.traditional || {};\n\n  qq.traditional.FormUploadHandler = function (options, proxy) {\n    \"use strict\";\n\n    var handler = this,\n        getName = proxy.getName,\n        getUuid = proxy.getUuid,\n        log = proxy.log;\n\n    function getIframeContentJson(id, iframe) {\n      var response, doc, innerHtml;\n\n      try {\n        doc = iframe.contentDocument || iframe.contentWindow.document;\n        innerHtml = doc.body.innerHTML;\n        log(\"converting iframe's innerHTML to JSON\");\n        log(\"innerHTML = \" + innerHtml);\n\n        if (innerHtml && innerHtml.match(/^<pre/i)) {\n          innerHtml = doc.body.firstChild.firstChild.nodeValue;\n        }\n\n        response = handler._parseJsonResponse(innerHtml);\n      } catch (error) {\n        log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n        response = {\n          success: false\n        };\n      }\n\n      return response;\n    }\n\n    function createForm(id, iframe) {\n      var params = options.paramsStore.get(id),\n          method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\",\n          endpoint = options.endpointStore.get(id),\n          name = getName(id);\n      params[options.uuidName] = getUuid(id);\n      params[options.filenameParam] = name;\n      return handler._initFormForUpload({\n        method: method,\n        endpoint: endpoint,\n        params: params,\n        paramsInBody: options.paramsInBody,\n        targetName: iframe.name\n      });\n    }\n\n    this.uploadFile = function (id) {\n      var input = handler.getInput(id),\n          iframe = handler._createIframe(id),\n          promise = new qq.Promise(),\n          form;\n\n      form = createForm(id, iframe);\n      form.appendChild(input);\n\n      handler._attachLoadEvent(iframe, function (responseFromMessage) {\n        log(\"iframe loaded\");\n        var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n\n        handler._detachLoadEvent(id);\n\n        if (!options.cors.expected) {\n          qq(iframe).remove();\n        }\n\n        if (response.success) {\n          promise.success(response);\n        } else {\n          promise.failure(response);\n        }\n      });\n\n      log(\"Sending upload request for \" + id);\n      form.submit();\n      qq(form).remove();\n      return promise;\n    };\n\n    qq.extend(this, new qq.FormUploadHandler({\n      options: {\n        isCors: options.cors.expected,\n        inputName: options.inputName\n      },\n      proxy: {\n        onCancel: options.onCancel,\n        getName: getName,\n        getUuid: getUuid,\n        log: log\n      }\n    }));\n  };\n\n  qq.traditional = qq.traditional || {};\n\n  qq.traditional.XhrUploadHandler = function (spec, proxy) {\n    \"use strict\";\n\n    var handler = this,\n        getName = proxy.getName,\n        getSize = proxy.getSize,\n        getUuid = proxy.getUuid,\n        log = proxy.log,\n        multipart = spec.forceMultipart || spec.paramsInBody,\n        addChunkingSpecificParams = function (id, params, chunkData) {\n      var size = getSize(id),\n          name = getName(id);\n\n      if (!spec.omitDefaultParams) {\n        params[spec.chunking.paramNames.partIndex] = chunkData.part;\n        params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n        params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n        params[spec.chunking.paramNames.totalParts] = chunkData.count;\n        params[spec.totalFileSizeName] = size;\n      }\n\n      if (multipart && !spec.omitDefaultParams) {\n        params[spec.filenameParam] = name;\n      }\n    },\n        allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n      cors: spec.cors,\n      endpoint: spec.chunking.success.endpoint,\n      headers: spec.chunking.success.headers,\n      jsonPayload: spec.chunking.success.jsonPayload,\n      log: log,\n      method: spec.chunking.success.method,\n      params: spec.chunking.success.params\n    }),\n        createReadyStateChangedHandler = function (id, xhr) {\n      var promise = new qq.Promise();\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          var result = onUploadOrChunkComplete(id, xhr);\n\n          if (result.success) {\n            promise.success(result.response, xhr);\n          } else {\n            promise.failure(result.response, xhr);\n          }\n        }\n      };\n\n      return promise;\n    },\n        getChunksCompleteParams = function (id) {\n      var params = spec.paramsStore.get(id),\n          name = getName(id),\n          size = getSize(id);\n      params[spec.uuidName] = getUuid(id);\n      params[spec.filenameParam] = name;\n      params[spec.totalFileSizeName] = size;\n      params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n      return params;\n    },\n        isErrorUploadResponse = function (xhr, response) {\n      return qq.indexOf([200, 201, 202, 203, 204], xhr.status) < 0 || spec.requireSuccessJson && !response.success || response.reset;\n    },\n        onUploadOrChunkComplete = function (id, xhr) {\n      var response;\n      log(\"xhr - server response received for \" + id);\n      log(\"responseText = \" + xhr.responseText);\n      response = parseResponse(true, xhr);\n      return {\n        success: !isErrorUploadResponse(xhr, response),\n        response: response\n      };\n    },\n        parseResponse = function (upload, xhr) {\n      var response = {};\n\n      try {\n        log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n        response = qq.parseJson(xhr.responseText);\n      } catch (error) {\n        upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n      }\n\n      return response;\n    },\n        sendChunksCompleteRequest = function (id) {\n      var promise = new qq.Promise();\n      allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function (xhr) {\n        promise.success(parseResponse(false, xhr), xhr);\n      }, function (xhr) {\n        promise.failure(parseResponse(false, xhr), xhr);\n      });\n      return promise;\n    },\n        setParamsAndGetEntityToSend = function (entityToSendParams) {\n      var fileOrBlob = entityToSendParams.fileOrBlob;\n      var id = entityToSendParams.id;\n      var xhr = entityToSendParams.xhr;\n      var xhrOverrides = entityToSendParams.xhrOverrides || {};\n      var customParams = entityToSendParams.customParams || {};\n      var defaultParams = entityToSendParams.params || {};\n      var xhrOverrideParams = xhrOverrides.params || {};\n      var params;\n      var formData = multipart ? new FormData() : null,\n          method = xhrOverrides.method || spec.method,\n          endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id),\n          name = getName(id),\n          size = getSize(id);\n\n      if (spec.omitDefaultParams) {\n        params = qq.extend({}, customParams);\n        qq.extend(params, xhrOverrideParams);\n      } else {\n        params = qq.extend({}, customParams);\n        qq.extend(params, xhrOverrideParams);\n        qq.extend(params, defaultParams);\n        params[spec.uuidName] = getUuid(id);\n        params[spec.filenameParam] = name;\n\n        if (multipart) {\n          params[spec.totalFileSizeName] = size;\n        } else if (!spec.paramsInBody) {\n          params[spec.inputName] = name;\n        }\n      }\n\n      if (!spec.paramsInBody) {\n        endpoint = qq.obj2url(params, endpoint);\n      }\n\n      xhr.open(method, endpoint, true);\n\n      if (spec.cors.expected && spec.cors.sendCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      if (multipart) {\n        if (spec.paramsInBody) {\n          qq.obj2FormData(params, formData);\n        }\n\n        formData.append(spec.inputName, fileOrBlob);\n        return formData;\n      }\n\n      return fileOrBlob;\n    },\n        setUploadHeaders = function (headersOptions) {\n      var headerOverrides = headersOptions.headerOverrides;\n      var id = headersOptions.id;\n      var xhr = headersOptions.xhr;\n\n      if (headerOverrides) {\n        qq.each(headerOverrides, function (headerName, headerValue) {\n          xhr.setRequestHeader(headerName, headerValue);\n        });\n      } else {\n        var extraHeaders = spec.customHeaders.get(id),\n            fileOrBlob = handler.getFile(id);\n        xhr.setRequestHeader(\"Accept\", \"application/json\");\n        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n\n        if (!multipart) {\n          xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n          xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n        }\n\n        qq.each(extraHeaders, function (name, val) {\n          xhr.setRequestHeader(name, val);\n        });\n      }\n    };\n\n    qq.extend(this, {\n      uploadChunk: function (uploadChunkParams) {\n        var id = uploadChunkParams.id;\n        var chunkIdx = uploadChunkParams.chunkIdx;\n        var overrides = uploadChunkParams.overrides || {};\n        var resuming = uploadChunkParams.resuming;\n\n        var chunkData = handler._getChunkData(id, chunkIdx),\n            xhr = handler._createXhr(id, chunkIdx),\n            promise,\n            toSend,\n            customParams,\n            params = {};\n\n        promise = createReadyStateChangedHandler(id, xhr);\n\n        handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n\n        customParams = spec.paramsStore.get(id);\n        addChunkingSpecificParams(id, params, chunkData);\n\n        if (resuming) {\n          params[spec.resume.paramNames.resuming] = true;\n        }\n\n        toSend = setParamsAndGetEntityToSend({\n          fileOrBlob: chunkData.blob,\n          id: id,\n          customParams: customParams,\n          params: params,\n          xhr: xhr,\n          xhrOverrides: overrides\n        });\n        setUploadHeaders({\n          headerOverrides: overrides.headers,\n          id: id,\n          xhr: xhr\n        });\n        xhr.send(toSend);\n        return promise;\n      },\n      uploadFile: function (id) {\n        var fileOrBlob = handler.getFile(id),\n            promise,\n            xhr,\n            customParams,\n            toSend;\n        xhr = handler._createXhr(id);\n\n        handler._registerProgressHandler(id);\n\n        promise = createReadyStateChangedHandler(id, xhr);\n        customParams = spec.paramsStore.get(id);\n        toSend = setParamsAndGetEntityToSend({\n          fileOrBlob: fileOrBlob,\n          id: id,\n          customParams: customParams,\n          xhr: xhr\n        });\n        setUploadHeaders({\n          id: id,\n          xhr: xhr\n        });\n        xhr.send(toSend);\n        return promise;\n      }\n    });\n    qq.extend(this, new qq.XhrUploadHandler({\n      options: qq.extend({\n        namespace: \"traditional\"\n      }, spec),\n      proxy: qq.extend({\n        getEndpoint: spec.endpointStore.get\n      }, proxy)\n    }));\n    qq.override(this, function (super_) {\n      return {\n        finalizeChunks: function (id) {\n          proxy.onFinalizing(id);\n\n          if (spec.chunking.success.endpoint) {\n            return sendChunksCompleteRequest(id);\n          } else {\n            return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n          }\n        }\n      };\n    });\n  };\n\n  qq.traditional.AllChunksDoneAjaxRequester = function (o) {\n    \"use strict\";\n\n    var requester,\n        options = {\n      cors: {\n        allowXdr: false,\n        expected: false,\n        sendCredentials: false\n      },\n      endpoint: null,\n      log: function (str, level) {},\n      method: \"POST\"\n    },\n        promises = {},\n        endpointHandler = {\n      get: function (id) {\n        if (qq.isFunction(options.endpoint)) {\n          return options.endpoint(id);\n        }\n\n        return options.endpoint;\n      }\n    };\n    qq.extend(options, o);\n    requester = qq.extend(this, new qq.AjaxRequester({\n      acceptHeader: \"application/json\",\n      contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n      validMethods: [options.method],\n      method: options.method,\n      endpointStore: endpointHandler,\n      allowXRequestedWithAndCacheControl: false,\n      cors: options.cors,\n      log: options.log,\n      onComplete: function (id, xhr, isError) {\n        var promise = promises[id];\n        delete promises[id];\n\n        if (isError) {\n          promise.failure(xhr);\n        } else {\n          promise.success(xhr);\n        }\n      }\n    }));\n    qq.extend(this, {\n      complete: function (id, xhr, params, headers) {\n        var promise = new qq.Promise();\n        options.log(\"Submitting All Chunks Done request for \" + id);\n        promises[id] = promise;\n        requester.initTransport(id).withParams(options.params(id) || params).withHeaders(options.headers(id) || headers).send(xhr);\n        return promise;\n      }\n    });\n  };\n})(window);","map":{"version":3,"sources":["?","../client/js/util.js","../client/js/export.js","../client/js/error/error.js","../client/js/version.js","../client/js/features.js","../client/js/promise.js","../client/js/blob-proxy.js","../client/js/button.js","../client/js/upload-data.js","../client/js/uploader.basic.api.js","../client/js/uploader.basic.js","../client/js/ajax.requester.js","../client/js/upload-handler/upload.handler.js","../client/js/upload-handler/upload.handler.controller.js","../client/js/window.receive.message.js","../client/js/upload-handler/form.upload.handler.js","../client/js/upload-handler/xhr.upload.handler.js","../client/js/deletefile.ajax.requester.js","../client/js/image-support/megapix-image.js","../client/js/image-support/image.js","../client/js/image-support/exif.js","../client/js/identify.js","../client/js/image-support/validation.image.js","../client/js/session.js","../client/js/session.ajax.requester.js","../client/js/image-support/scaler.js","../client/js/third-party/ExifRestorer.js","../client/js/total-progress.js","../client/js/paste.js","../client/js/form-support.js","../client/js/traditional/traditional.form.upload.handler.js","../client/js/traditional/traditional.xhr.upload.handler.js","../client/js/traditional/all-chunks-done.ajax.requester.js"],"names":["global","window","qq","element","hide","style","display","this","attach","type","fn","addEventListener","attachEvent","detach","removeEventListener","detachEvent","contains","descendant","compareDocumentPosition","insertBefore","elementB","parentNode","remove","removeChild","css","styles","Error","opacity","filter","Math","round","extend","hasClass","name","considerParent","re","RegExp","test","className","addClass","removeClass","replace","getByClass","first","candidates","result","querySelector","querySelectorAll","getElementsByTagName","each","idx","val","push","getFirstByClass","children","child","firstChild","nodeType","nextSibling","setText","text","innerText","textContent","clearText","hasAttribute","attrName","attrVal","exec","getAttribute","undefined","canvasToBlob","canvas","mime","quality","dataUriToBlob","toDataURL","dataUri","arrayBuffer","byteString","createBlob","data","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","blobBuilder","append","getBlob","Blob","intArray","mimeString","split","indexOf","atob","decodeURI","ArrayBuffer","length","Uint8Array","character","charCodeAt","log","message","level","console","isObject","variable","Object","prototype","toString","call","isFunction","isArray","value","buffer","constructor","isItemList","maybeItemList","isNodeList","maybeNodeList","item","namedItem","isString","maybeString","trimStr","string","String","trim","format","str","args","Array","slice","arguments","newStr","nextIdxToReplace","strBefore","substring","strAfter","isFile","maybeFile","File","isFileList","maybeFileList","FileList","isFileOrInput","maybeFileOrInput","isInput","maybeInput","notFile","evaluateType","normalizedType","toLowerCase","HTMLInputElement","tagName","isBlob","maybeBlob","isXhrUploadSupported","input","document","createElement","multiple","FormData","createXhrInstance","upload","XMLHttpRequest","ActiveXObject","error","isFolderDropSupported","dataTransfer","items","webkitGetAsEntry","isFileChunkingSupported","androidStock","webkitSlice","mozSlice","sliceBlob","fileOrBlob","start","end","slicer","arrayBufferToHex","bytesAsHex","bytes","byt","byteAsHexStr","readBlobToHex","blob","startOffset","initialBlob","fileReader","FileReader","promise","Promise","onload","success","onerror","failure","readAsArrayBuffer","second","extendNested","prop","override","target","sourceFn","super_","source","srcPropName","srcPropVal","arr","elt","from","len","hasOwnProperty","getUniqueId","c","r","random","v","ie","navigator","userAgent","ie7","ie8","ie10","ie11","edge","safari","vendor","chrome","opera","firefox","windows","platform","android","ios6","ios","ios7","ios8","ios800","iosChrome","iosSafari","iosSafariWebView","preventDefault","e","returnValue","toElement","div","html","innerHTML","iterableItem","callback","keyOrIndex","retVal","Storage","key","getItem","charAt","bind","oldFunc","context","newArgs","concat","apply","obj2url","obj","temp","prefixDone","uristrings","prefix","add","nextObj","i","nextTemp","encodeURIComponent","join","obj2FormData","formData","arrayKeyName","obj2Inputs","form","setAttribute","appendChild","parseJson","json","JSON","parse","eval","getExtension","filename","extIdx","lastIndexOf","substr","getFilename","blobOrFileInput","fileName","DisposeSupport","disposers","dispose","disposer","shift","addDisposer","disposeFunction","define","amd","module","exports","version","supportedFeatures","supportsUploading","supportsUploadingBlobs","supportsFileDrop","supportsAjaxFileUploading","supportsFolderDrop","supportsChunking","supportsResume","supportsUploadViaPaste","supportsUploadCors","supportsDeleteFileXdr","supportsDeleteFileCorsXhr","supportsDeleteFileCors","supportsFolderSelection","supportsImagePreviews","supportsUploadProgress","testSupportsFileInputElement","supported","tempInput","disabled","ex","isChrome14OrHigher","match","isCrossOriginXhrSupported","xhr","withCredentials","isXdrSupported","XDomainRequest","isCrossOriginAjaxSupported","isFolderSelectionSupported","webkitdirectory","isLocalStorageSupported","localStorage","setItem","isDragAndDropSupported","span","postMessage","ajaxUploading","blobUploading","canDetermineSize","chunking","deleteFileCors","deleteFileCorsXdr","deleteFileCorsXhr","dialogElement","HTMLDialogElement","fileDrop","folderDrop","folderSelection","imagePreviews","imageValidation","itemSizeValidation","pause","progressBar","resume","scaling","tiffPreviews","unlimitedScaledImageSize","uploading","uploadCors","uploadCustomHeaders","uploadNonMultipart","uploadViaPaste","isGenericPromise","maybePromise","then","successArgs","failureArgs","successCallbacks","failureCallbacks","doneCallbacks","state","onSuccess","onFailure","done","BlobProxy","referenceBlob","onCreate","create","UploadButton","o","self","disposeSupport","options","acceptFiles","focusClass","folders","hoverClass","ios8BrowserCrashWorkaround","onChange","title","buttonId","createInput","BUTTON_ID_ATTR_NAME","setMultiple","position","right","top","fontFamily","fontSize","margin","padding","cursor","height","overflow","direction","getInput","getButtonId","isMultiple","optInput","removeAttribute","setAcceptFiles","reset","UploadData","uploaderProxy","byUuid","byStatus","byProxyGroupId","byBatchId","getDataByIds","idOrIds","entries","id","getDataByUuids","uuids","uuid","getDataByStatus","status","statusResults","statuses","index","statusEnum","statusResultIndexes","dataIndex","addFile","spec","SUBMITTING","originalName","size","file","batchId","proxyGroupId","onBeforeStatusChange","onStatusChange","retrieve","optionalFilter","removeFileRef","record","setStatus","newStatus","oldStatus","byStatusOldStatusIndex","splice","uuidChanged","newUuid","oldUuid","updateName","newName","updateSize","newSize","setParentId","targetId","parentId","getIdsInProxyGroup","getIdsInBatch","SUBMITTED","REJECTED","QUEUED","CANCELED","PAUSED","UPLOADING","UPLOAD_FINALIZING","UPLOAD_RETRYING","UPLOAD_SUCCESSFUL","UPLOAD_FAILED","DELETE_FAILED","DELETING","DELETED","basePublicApi","addBlobs","blobDataOrArray","params","endpoint","addFiles","addInitialFiles","cannedFileList","cannedFile","_addCannedFile","_maybeHandleIos8SafariWorkaround","_storedIds","_currentBatchId","processBlob","_handleNewFile","_options","blobs","defaultName","verifiedFiles","processBlobData","blobData","processCanvas","processCanvasData","canvasData","normalizedQuality","processFileOrInput","fileOrInput","files","normalizeData","fileContainer","_prepareItemsForUpload","cancel","uploadData","_uploadData","getName","_handler","cancelAll","storedIdsCopy","storedFileId","clearStoredFiles","continueUpload","enabled","_uploadFile","deleteFile","_onSubmitDelete","doesExist","fileOrBlobId","isValid","drawThumbnail","fileId","imgOrCanvas","maxSize","fromServer","customResizeFunction","promiseToReturn","fileOrUrl","_imageGenerator","_thumbnailUrls","scale","getFile","container","generate","modifiedContainer","reason","getButton","_getButton","_buttonIdsForFileIds","getEndpoint","_endpointStore","get","uploadDataRecord","getInProgress","getParentId","uploadDataEntry","getUploads","getResumableFilesData","getSize","getNetUploads","_netUploaded","getRemainingAllowedItems","allowedItems","_currentItemLimit","_netUploadedOrQueued","getUuid","isResumable","hasResumeRecord","debug","pauseUpload","expunge","_autoRetries","_retryTimeouts","_preventRetries","_buttons","button","_paramsStore","_pasteHandler","session","refreshOnReset","_refreshSessionData","_succeededSinceLastAllComplete","_failedSinceLastAllComplete","_totalProgress","_customResumeDataStore","retry","_manualRetry","scaleImage","specs","Scaler","setCustomHeaders","headers","_customHeadersStore","set","setCustomResumeData","setDeleteFileCustomHeaders","_deleteFileCustomHeadersStore","setDeleteFileEndpoint","_deleteFileEndpointStore","setDeleteFileParams","_deleteFileParamsStore","setEndpoint","setForm","elementOrId","_updateFormSupportAndParams","setItemLimit","newItemLimit","setName","setParams","setUuid","fileRecord","_onDeleteComplete","errorMessage","uploadStoredFiles","_itemError","_uploadStoredFiles","basePrivateApi","sessionData","deleteFileEndpoint","deleteFileParams","thumbnailUrl","_annotateWithButtonId","associatedInput","qqButtonId","_getButtonId","_batchError","callbacks","onError","_createDeleteHandler","DeleteFileAjaxRequester","method","toUpperCase","maxConnections","uuidParamName","request","uuidName","customHeaders","paramsStore","endpointStore","cors","onDelete","_onDelete","onDeleteComplete","xhrOrXdr","isError","_createPasteHandler","PasteSupport","targetElement","paste","pasteReceived","_handleCheckedCallback","onPasteReceived","_handlePasteSuccess","identifier","_createStore","initialValue","_readOnlyValues_","store","catchall","perIdReadOnlyValues","readOnlyValues","copy","orig","getReadOnlyValues","includeReadOnlyValues","existing","values","addReadOnly","_createUploadDataTracker","_onUploadStatusChange","_maybeAllComplete","setTimeout","_createUploadButton","accept","validation","allowedExtensions","allowMultiple","workarounds","iosEmptyVideos","_isAllowedExtension","classes","buttonFocus","buttonHover","ios8BrowserCrash","inputName","_onInputChange","fileInputTitle","_disposeSupport","_createUploadHandler","additionalOptions","namespace","lastOnProgress","preventRetryParam","preventRetryResponseProperty","onProgress","loaded","total","_onProgress","onComplete","_onComplete","onCancel","cancelFinalizationEffort","_onCancel","onUploadPrep","_onUploadPrep","onUpload","_onUpload","onUploadResult","onUploadChunk","chunkData","_onUploadChunk","onUploadChunkResult","partIndex","onUploadChunkSuccess","_onUploadChunkSuccess","onResume","customResumeData","onAutoRetry","responseJSON","_onAutoRetry","onUuidChanged","setSize","_setSize","getDataByUuid","isQueued","isInProgress","getCustomResumeData","_getCustomResumeData","UploadHandlerController","_fileOrBlobRejected","_formatSize","sizeSymbols","max","toFixed","_generateExtraButtonSpecs","_extraButtonSpecs","extraButtons","extraButtonOptionEntry","extraButtonSpec","_initExtraButton","extraButtonsSpec","_defaultButtonId","buttonOrFileInputOrFile","inputs","fileInput","fileBlobOrInput","_getNotFinished","_getValidationBase","_getValidationDescriptor","fileWrapper","_getValidationDescriptors","fileWrappers","fileDescriptors","_handleCameraAccess","camera","acceptIosCamera","optionRoot","details","callbackRetVal","successParam","newFileWrapperList","actualFile","handler","_customNewFileHandler","_handleNewFileGeneric","addFileToHandler","_trackButton","fileList","extSuppliedName","extension","_handleDeleteSuccess","_handleDeleteFailed","_initFormSupportAndParams","_formSupport","FormSupport","attachedToForm","getFormInputsAsObject","autoUpload","newAutoUpload","newEndpoint","_isDeletePossible","expected","allowXdr","allowed","valid","allowedExt","extRegex","code","maybeNameOrNames","messages","names","validationBase","extensionsForMessage","placeholderMatch","replacement","allowedExtension","formatFileName","sizeLimit","minSizeLimit","placeholder","_onBeforeManualRetry","notFinished","_onAllComplete","ios8SafariUploads","alert","unsupportedBrowserIos8Safari","_maybeParseAndSendUploadError","response","errorReason","defaultResponseError","_maybeProcessNextItemAfterOnValidateCallback","validItem","stopOnFirstInvalidFile","validationDescriptor","onValidate","_onValidateCallbackSuccess","_onValidateCallbackFailure","successful","failed","onAllComplete","_shouldAutoRetry","retryWaitPeriod","autoAttemptDelay","_onBeforeAutoRetry","itemLimit","onManualRetry","clearTimeout","storedItemIndex","fileIndex","onIndividualProgress","_onSubmit","_onSubmitCallbackSuccess","_onSubmitted","onSubmitted","_storeForLater","onSuccessCallback","additionalMandatedParams","adjustedOnSuccessCallback","onSubmitDelete","_deleteHandler","sendDelete","_onTotalProgress","onTotalProgress","enableAuto","_onValidateBatchCallbackFailure","_onValidateBatchCallbackSuccess","validationDescriptors","proposedNetFilesUploadedOrQueued","tooManyItemsError","nextIndex","_validateFileOrBlobData","_upload","onValidateBatch","_preventLeaveInProgress","event","onLeave","Session","_session","addFileRecord","refresh","_sessionRequestComplete","onSessionRequestComplete","onNewSize","maxAutoAttempts","formElementOrId","onSubmit","idToUpload","stillSubmitting","validityChecker","allowEmpty","ImageValidation","validate","image","errorCode","_wrapCallbacks","safeCallback","errorMsg","exception","callbackName","callbackFunc","FineUploaderBasic","disableCancelForFormUploads","warnBeforeUnload","filenameParam","forceMultipart","omitDefaultParams","paramsInBody","requireSuccessJson","totalFileSizeName","maxHeight","maxWidth","minHeight","minWidth","maybeXhr","maybeXhrOrXdr","attemptNumber","fileOrBlobData","typeError","sizeError","minSizeError","emptyError","noFilesError","maxHeightImageError","maxWidthImageError","minHeightImageError","minWidthImageError","retryFailTooManyItems","concurrent","mandatory","paramNames","partByteOffset","chunkSize","totalFileSize","totalParts","partSize","jsonPayload","resetOnStatus","recordsExpireIn","resuming","customKeys","fileOrBlobName","sendCredentials","interceptSubmit","customResizer","sendOriginal","orient","defaultType","defaultQuality","failureText","includeExif","sizes","ImageGenerator","_scaler","handleNewFile","TotalProgress","entry","AjaxRequester","shouldParamsBeInQueryString","queue","requestData","acceptHeader","validMethods","contentType","mandatedParams","allowXRequestedWithAndCacheControl","successfulResponseCodes","DELETE","PATCH","POST","PUT","GET","onSend","isSimpleMethod","containsNonSimpleHeaders","containsNonSimple","header","isXdr","getCorsAjaxTransport","ontimeout","onprogress","getXhrOrXdr","suppliedXhr","dequeue","nextId","sendRequest","xdrError","isResponseSuccessful","getParams","onDemandParams","additionalParams","optXhr","payload","url","createUrl","additionalQueryParams","getXdrLoadHandler","getXdrErrorHandler","onreadystatechange","getXhrReadyStateChangeHandler","registerForUploadProgress","open","setHeaders","send","stringify","addToPath","readyState","lengthComputable","onDemandHeaders","additionalHeaders","allHeaders","setRequestHeader","responseCode","prepareToSend","initTransport","path","cacheBuster","withPath","appendToPath","withParams","withQueryParams","_additionalQueryParams_","withHeaders","withPayload","thePayload","withCacheBuster","qqtimestamp","Date","getTime","canceled","UploadHandler","proxy","fileState","fileItem","onCancelRetVal","getThirdPartyFileId","_getFileState","_setThirdPartyFileId","thirdPartyFileId","_wasCanceled","controller","chunkingPossible","concurrentChunkingPossible","preventRetryResponse","chunked","chunkIdx","_getChunkData","attemptingResume","chunkProgress","_getChunkDataForCallback","finalize","finalizeChunks","normaizedResponse","normalizeResponse","_maybeDeletePersistedChunkData","cleanup","normalizedResponse","handleFailure","clearCachedChunk","responseToReport","inProgressIdx","inProgressChunksArray","inProgress","remaining","unshift","ignoreFailure","keys","_getXhrs","ckid","ckXhr","abort","_cancelled","moveInProgressToRemaining","connectionManager","free","hasMoreParts","nextPart","nextIdx","_getTotalChunks","reevaluateChunking","sendNext","inProgressChunks","available","onUploadChunkPromise","requestOverrides","uploadChunkData","overrides","uploadChunk","inProgressChunkIdx","_maybePersistChunkedState","clearXhr","_open","_openChunks","_waiting","openChunkEntriesCount","openChunksCount","openChunkIndexes","dontAllowNext","allowNext","waitingIndex","connectionsIndex","getProxyOrBlob","getWaitingOrConnected","waitingOrConnected","chunks","parseInt","isUsingConnection","pop","openChunksEntry","simple","uploadFile","maybeNewUuid","_clearXhrs","getProxy","initHandler","handlerType","traditional","handlerModuleSubtype","onFinalizing","_removeExpiredChunkingRecords","isDeferredEligibleForUpload","maybeDefer","generatedBlob","updateBlob","maybeSendDeferredFiles","errorResponse","idsInGroup","uploadedThisId","idInGroup","now","originalResponse","_shouldChunkThisFile","blobToUpload","cancelRetVal","isProxied","_getLocalStorageId","isAttemptingResume","WindowReceiveMessage","callbackWrapperDetachers","receiveMessage","onMessageCallbackWrapper","stopReceivingMessages","detacher","FormUploadHandler","formHandlerInstanceId","onloadCallbacks","detachLoadEvents","postMessageCallbackTimers","isCors","corsMessageReceiver","expungeFile","iframe","getElementById","_getIframeName","getFileIdForIframeName","iframeName","initIframeForUpload","body","registerPostMessageCallback","_parseJsonResponse","onloadCallback","_detachLoadEvent","_attachLoadEvent","responseDescriptor","contentDocument","_createIframe","_initFormForUpload","targetName","innerHtmlOrMessage","XhrUploadHandler","getChunkSize","chunkFiles","resumeEnabled","xhrId","ajaxRequester","_getAjaxRequester","blobOrProxy","_initTempState","_maybePrepareForResume","cachedChunks","tempState","xhrs","ajaxRequesters","responseParser","lastChunkIdx","_getXhr","resumableFilesData","_iterateResumeRecords","notResumable","optInProgress","optRemaining","chunkingState","reverse","paused","totalChunks","parts","newBlob","chunkId","_createXhr","optChunkIdx","_registerXhr","chunkIndex","fileSize","startBytes","endBytes","part","count","startByte","endByte","formatVersion","localStorageId","forEach","_getMimeType","_getPersistableData","ceil","_markNotResumable","removeItem","persistedData","lastUpdated","_registerProgressHandler","progressCalculator","totalSuccessfullyLoadedForFile","loadedForRequest","totalForRequest","estActualChunkLoaded","totalLoadedForFile","chunkLoaded","optAjaxRequester","xhrsId","expirationDays","expirationDate","setDate","getDate","requester","getMandatedParams","_method","detectSubsampling","img","iw","naturalWidth","ih","naturalHeight","ctx","width","getContext","drawImage","getImageData","detectVerticalSquash","sy","ey","py","alpha","ratio","renderImageToDataURL","doSquash","renderImageToCanvas","maybeCalculateDownsampledDimensions","maxPixels","origHeight","origWidth","newHeight","sqrt","newWidth","modifiedDimensions","save","resize","renderImageToCanvasWithCustomResizer","imageHeight","imageWidth","orientation","targetHeight","targetWidth","transformCoordinate","d","tmpCanvas","vertSquashRatio","dw","dh","dy","tmpCtx","sx","dx","clearRect","restore","qqImageRendered","resizeInfo","sourceCanvas","sourceCanvasContext","targetCanvas","translate","rotate","PI","MegaPixImage","srcImage","errorCallback","Image","URL","createObjectURL","webkitURL","src","listeners","imageLoadListeners","render","imgWidth","imgHeight","opt","optionsKey","optionsValue","oldTargetSrc","onrender","isImg","el","isCanvas","isImgCorsSupported","crossOrigin","isCanvasSupported","determineMimeOfFileName","nameWithPath","pathSegments","isCrossOrigin","targetAnchor","targetProtocol","targetHostname","targetPort","href","protocol","port","hostname","location","registerImgLoadListeners","registerCanvasDrawImageListener","registerThumbnailRenderedListener","registered","draw","drawPreview","Identify","megapixErrorHandler","isPreviewable","dummyExif","exif","Exif","mpImg","Orientation","failureMsg","drawOnCanvasOrImgFromUrl","canvasOrImg","tempImg","tempImgRender","rendered","drawOnImgFromUrlWithCssScaling","drawFromUrl","fileBlobOrUrl","_testing","TAG_IDS","TAG_INFO","274","parseLittleEndian","hex","pow","seekToApp1","offset","theOffset","thePromise","segmentLength","getApp1Offset","isLittleEndian","app1Start","getDirEntryCount","littleEndian","getIfd","dirEntries","getDirEntries","ifdHex","getTagValues","TAG_VAL_OFFSET","tagsToFind","vals","idHex","tagsToFindIdx","tagValHex","tagValLength","parser","onParseFailure","app1Offset","dirEntryCount","tagValues","isIdentifiable","magicBytes","questionableBytes","identifiable","magicBytesEntries","magicBytesArrayEntry","previewable","isPreviewableSync","PREVIEWABLE_MIME_TYPES","fileMime","isRecognizedImage","image/jpeg","image/gif","image/png","image/bmp","image/tiff","hasNonZeroLimits","limits","atLeastOne","limit","getWidthHeight","sizeDetermination","getFailingLimit","dimensions","failingLimit","limitName","limitValue","limitMatcher","dimensionPropName","actualValue","validationEffort","isJsonResponseValid","handleFileItems","fileItems","someItemsIgnored","err","refreshEffort","refreshCompleteCallback","requesterOptions","SessionAjaxRequester","queryServer","responseText","includeOriginal","failedToScaleText","_getSortedSizes","getFileRecords","originalFileUuid","originalFileName","originalBlobOrBlobData","records","originalBlob","sizeRecord","outputType","_determineOutputType","requestedType","refType","_getName","_generateScaledImage","failedText","api","scaledIds","originalId","blobSize","scaledId","qqparentuuid","qqparentsize","param","scalingEffort","scalingOptions","scaler","referenceType","scaledVersionProperties","startOfExt","versionType","scaledName","scaledExt","nameAppendage","sort","a","b","sourceFile","imageGenerator","scaledImageDataUri","signalSuccess","_insertExifHeader","scaledImageDataUriWithExif","originalImage","reader","insertionEffort","originalImageDataUri","ExifRestorer","readAsDataURL","_dataUriToBlob","_createBlob","KEY_STR","encode64","output","chr1","chr2","chr3","enc1","enc2","enc3","enc4","isNaN","origFileBase64","resizedFileBase64","expectedBase64Header","rawImage","decode64","segments","slice2Segments","exifManipulation","exifArray","getExifArray","newImageArray","insertExif","aBuffer","seg","x","imageData","buf","separatePoint","mae","ato","array","rawImageArray","head","endPoint","base64test","perFileProgress","totalLoaded","totalSize","lastLoadedSent","lastTotalSent","callbackProxy","noRetryableFiles","retryable","none","failedId","updateTotalProgress","onNew","newLoaded","newTotal","oldLoaded","oldTotal","detachPasteHandler","isImage","registerPasteHandler","clipboardData","getAsFile","unregisterPasteHandler","startUpload","formEl","_form2Obj","determineNewEndpoint","validateForm","nativeSubmit","checkValidity","maybeUploadOnSubmit","submit","determineFormEl","notIrrelevantType","irrelevantTypes","radioOrCheckbox","ignoreValue","checked","selectValue","select","selected","elements","getIframeContentJson","doc","innerHtml","contentWindow","nodeValue","createForm","responseFromMessage","multipart","addChunkingSpecificParams","allChunksDoneRequester","AllChunksDoneAjaxRequester","createReadyStateChangedHandler","onUploadOrChunkComplete","getChunksCompleteParams","isErrorUploadResponse","parseResponse","sendChunksCompleteRequest","complete","setParamsAndGetEntityToSend","entityToSendParams","xhrOverrides","customParams","defaultParams","xhrOverrideParams","setUploadHeaders","headersOptions","headerOverrides","headerName","headerValue","extraHeaders","uploadChunkParams","toSend","promises","endpointHandler"],"mappings":"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","sourcesContent":[null,"/*globals window, navigator, document, FormData, File, HTMLInputElement, XMLHttpRequest, Blob, Storage, ActiveXObject */\n/* jshint -W079 */\nvar qq = function(element) {\n    \"use strict\";\n\n    return {\n        hide: function() {\n            element.style.display = \"none\";\n            return this;\n        },\n\n        /** Returns the function which detaches attached event */\n        attach: function(type, fn) {\n            if (element.addEventListener) {\n                element.addEventListener(type, fn, false);\n            } else if (element.attachEvent) {\n                element.attachEvent(\"on\" + type, fn);\n            }\n            return function() {\n                qq(element).detach(type, fn);\n            };\n        },\n\n        detach: function(type, fn) {\n            if (element.removeEventListener) {\n                element.removeEventListener(type, fn, false);\n            } else if (element.attachEvent) {\n                element.detachEvent(\"on\" + type, fn);\n            }\n            return this;\n        },\n\n        contains: function(descendant) {\n            // The [W3C spec](http://www.w3.org/TR/domcore/#dom-node-contains)\n            // says a `null` (or ostensibly `undefined`) parameter\n            // passed into `Node.contains` should result in a false return value.\n            // IE7 throws an exception if the parameter is `undefined` though.\n            if (!descendant) {\n                return false;\n            }\n\n            // compareposition returns false in this case\n            if (element === descendant) {\n                return true;\n            }\n\n            if (element.contains) {\n                return element.contains(descendant);\n            } else {\n                /*jslint bitwise: true*/\n                return !!(descendant.compareDocumentPosition(element) & 8);\n            }\n        },\n\n        /**\n         * Insert this element before elementB.\n         */\n        insertBefore: function(elementB) {\n            elementB.parentNode.insertBefore(element, elementB);\n            return this;\n        },\n\n        remove: function() {\n            element.parentNode.removeChild(element);\n            return this;\n        },\n\n        /**\n         * Sets styles for an element.\n         * Fixes opacity in IE6-8.\n         */\n        css: function(styles) {\n            /*jshint eqnull: true*/\n            if (element.style == null) {\n                throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n            }\n\n            /*jshint -W116*/\n            if (styles.opacity != null) {\n                if (typeof element.style.opacity !== \"string\" && typeof (element.filters) !== \"undefined\") {\n                    styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                }\n            }\n            qq.extend(element.style, styles);\n\n            return this;\n        },\n\n        hasClass: function(name, considerParent) {\n            var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n            return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n        },\n\n        addClass: function(name) {\n            if (!qq(element).hasClass(name)) {\n                element.className += \" \" + name;\n            }\n            return this;\n        },\n\n        removeClass: function(name) {\n            var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n            element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n            return this;\n        },\n\n        getByClass: function(className, first) {\n            var candidates,\n                result = [];\n\n            if (first && element.querySelector) {\n                return element.querySelector(\".\" + className);\n            }\n            else if (element.querySelectorAll) {\n                return element.querySelectorAll(\".\" + className);\n            }\n\n            candidates = element.getElementsByTagName(\"*\");\n\n            qq.each(candidates, function(idx, val) {\n                if (qq(val).hasClass(className)) {\n                    result.push(val);\n                }\n            });\n            return first ? result[0] : result;\n        },\n\n        getFirstByClass: function(className) {\n            return qq(element).getByClass(className, true);\n        },\n\n        children: function() {\n            var children = [],\n                child = element.firstChild;\n\n            while (child) {\n                if (child.nodeType === 1) {\n                    children.push(child);\n                }\n                child = child.nextSibling;\n            }\n\n            return children;\n        },\n\n        setText: function(text) {\n            element.innerText = text;\n            element.textContent = text;\n            return this;\n        },\n\n        clearText: function() {\n            return qq(element).setText(\"\");\n        },\n\n        // Returns true if the attribute exists on the element\n        // AND the value of the attribute is NOT \"false\" (case-insensitive)\n        hasAttribute: function(attrName) {\n            var attrVal;\n\n            if (element.hasAttribute) {\n\n                if (!element.hasAttribute(attrName)) {\n                    return false;\n                }\n\n                /*jshint -W116*/\n                return (/^false$/i).exec(element.getAttribute(attrName)) == null;\n            }\n            else {\n                attrVal = element[attrName];\n\n                if (attrVal === undefined) {\n                    return false;\n                }\n\n                /*jshint -W116*/\n                return (/^false$/i).exec(attrVal) == null;\n            }\n        }\n    };\n};\n\n(function() {\n    \"use strict\";\n\n    qq.canvasToBlob = function(canvas, mime, quality) {\n        return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n    };\n\n    qq.dataUriToBlob = function(dataUri) {\n        var arrayBuffer, byteString,\n            createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder ||\n                        window.WebKitBlobBuilder ||\n                        window.MozBlobBuilder ||\n                        window.MSBlobBuilder,\n                    blobBuilder = BlobBuilder && new BlobBuilder();\n\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                }\n                else {\n                    return new Blob([data], {type: mime});\n                }\n            },\n            intArray, mimeString;\n\n        // convert base64 to raw binary data held in a string\n        if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n            byteString = atob(dataUri.split(\",\")[1]);\n        }\n        else {\n            byteString = decodeURI(dataUri.split(\",\")[1]);\n        }\n\n        // extract the MIME\n        mimeString = dataUri.split(\",\")[0]\n            .split(\":\")[1]\n            .split(\";\")[0];\n\n        // write the bytes of the binary string to an ArrayBuffer\n        arrayBuffer = new ArrayBuffer(byteString.length);\n        intArray = new Uint8Array(arrayBuffer);\n        qq.each(byteString, function(idx, character) {\n            intArray[idx] = character.charCodeAt(0);\n        });\n\n        return createBlob(arrayBuffer, mimeString);\n    };\n\n    qq.log = function(message, level) {\n        if (window.console) {\n            if (!level || level === \"info\") {\n                window.console.log(message);\n            }\n            else\n            {\n                if (window.console[level]) {\n                    window.console[level](message);\n                }\n                else {\n                    window.console.log(\"<\" + level + \"> \" + message);\n                }\n            }\n        }\n    };\n\n    qq.isObject = function(variable) {\n        return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n    };\n\n    qq.isFunction = function(variable) {\n        return typeof (variable) === \"function\";\n    };\n\n    /**\n     * Check the type of a value.  Is it an \"array\"?\n     *\n     * @param value value to test.\n     * @returns true if the value is an array or associated with an `ArrayBuffer`\n     */\n    qq.isArray = function(value) {\n        return Object.prototype.toString.call(value) === \"[object Array]\" ||\n            (value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer);\n    };\n\n    // Looks for an object on a `DataTransfer` object that is associated with drop events when utilizing the Filesystem API.\n    qq.isItemList = function(maybeItemList) {\n        return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n    };\n\n    // Looks for an object on a `NodeList` or an `HTMLCollection`|`HTMLFormElement`|`HTMLSelectElement`\n    // object that is associated with collections of Nodes.\n    qq.isNodeList = function(maybeNodeList) {\n        return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" ||\n            // If `HTMLCollection` is the actual type of the object, we must determine this\n            // by checking for expected properties/methods on the object\n            (maybeNodeList.item && maybeNodeList.namedItem);\n    };\n\n    qq.isString = function(maybeString) {\n        return Object.prototype.toString.call(maybeString) === \"[object String]\";\n    };\n\n    qq.trimStr = function(string) {\n        if (String.prototype.trim) {\n            return string.trim();\n        }\n\n        return string.replace(/^\\s+|\\s+$/g, \"\");\n    };\n\n    /**\n     * @param str String to format.\n     * @returns {string} A string, swapping argument values with the associated occurrence of {} in the passed string.\n     */\n    qq.format = function(str) {\n\n        var args =  Array.prototype.slice.call(arguments, 1),\n            newStr = str,\n            nextIdxToReplace = newStr.indexOf(\"{}\");\n\n        qq.each(args, function(idx, val) {\n            var strBefore = newStr.substring(0, nextIdxToReplace),\n                strAfter = newStr.substring(nextIdxToReplace + 2);\n\n            newStr = strBefore + val + strAfter;\n            nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n\n            // End the loop if we have run out of tokens (when the arguments exceed the # of tokens)\n            if (nextIdxToReplace < 0) {\n                return false;\n            }\n        });\n\n        return newStr;\n    };\n\n    qq.isFile = function(maybeFile) {\n        return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n    };\n\n    qq.isFileList = function(maybeFileList) {\n        return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n    };\n\n    qq.isFileOrInput = function(maybeFileOrInput) {\n        return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n    };\n\n    qq.isInput = function(maybeInput, notFile) {\n        var evaluateType = function(type) {\n            var normalizedType = type.toLowerCase();\n\n            if (notFile) {\n                return normalizedType !== \"file\";\n            }\n\n            return normalizedType === \"file\";\n        };\n\n        if (window.HTMLInputElement) {\n            if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                if (maybeInput.type && evaluateType(maybeInput.type)) {\n                    return true;\n                }\n            }\n        }\n        if (maybeInput.tagName) {\n            if (maybeInput.tagName.toLowerCase() === \"input\") {\n                if (maybeInput.type && evaluateType(maybeInput.type)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    qq.isBlob = function(maybeBlob) {\n        if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n            return true;\n        }\n    };\n\n    qq.isXhrUploadSupported = function() {\n        var input = document.createElement(\"input\");\n        input.type = \"file\";\n\n        return (\n            input.multiple !== undefined &&\n                typeof File !== \"undefined\" &&\n                typeof FormData !== \"undefined\" &&\n                typeof (qq.createXhrInstance()).upload !== \"undefined\");\n    };\n\n    // Fall back to ActiveX is native XHR is disabled (possible in any version of IE).\n    qq.createXhrInstance = function() {\n        if (window.XMLHttpRequest) {\n            return new XMLHttpRequest();\n        }\n\n        try {\n            return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n        }\n        catch (error) {\n            qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n            return null;\n        }\n    };\n\n    qq.isFolderDropSupported = function(dataTransfer) {\n        return dataTransfer.items &&\n            dataTransfer.items.length > 0 &&\n            dataTransfer.items[0].webkitGetAsEntry;\n    };\n\n    qq.isFileChunkingSupported = function() {\n        return !qq.androidStock() && //Android's stock browser cannot upload Blobs correctly\n            qq.isXhrUploadSupported() &&\n            (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n    };\n\n    qq.sliceBlob = function(fileOrBlob, start, end) {\n        var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n\n        return slicer.call(fileOrBlob, start, end);\n    };\n\n    qq.arrayBufferToHex = function(buffer) {\n        var bytesAsHex = \"\",\n            bytes = new Uint8Array(buffer);\n\n        qq.each(bytes, function(idx, byt) {\n            var byteAsHexStr = byt.toString(16);\n\n            if (byteAsHexStr.length < 2) {\n                byteAsHexStr = \"0\" + byteAsHexStr;\n            }\n\n            bytesAsHex += byteAsHexStr;\n        });\n\n        return bytesAsHex;\n    };\n\n    qq.readBlobToHex = function(blob, startOffset, length) {\n        var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length),\n            fileReader = new FileReader(),\n            promise = new qq.Promise();\n\n        fileReader.onload = function() {\n            promise.success(qq.arrayBufferToHex(fileReader.result));\n        };\n\n        fileReader.onerror = promise.failure;\n\n        fileReader.readAsArrayBuffer(initialBlob);\n\n        return promise;\n    };\n\n    qq.extend = function(first, second, extendNested) {\n        qq.each(second, function(prop, val) {\n            if (extendNested && qq.isObject(val)) {\n                if (first[prop] === undefined) {\n                    first[prop] = {};\n                }\n                qq.extend(first[prop], val, true);\n            }\n            else {\n                first[prop] = val;\n            }\n        });\n\n        return first;\n    };\n\n    /**\n     * Allow properties in one object to override properties in another,\n     * keeping track of the original values from the target object.\n     *\n     * Note that the pre-overriden properties to be overriden by the source will be passed into the `sourceFn` when it is invoked.\n     *\n     * @param target Update properties in this object from some source\n     * @param sourceFn A function that, when invoked, will return properties that will replace properties with the same name in the target.\n     * @returns {object} The target object\n     */\n    qq.override = function(target, sourceFn) {\n        var super_ = {},\n            source = sourceFn(super_);\n\n        qq.each(source, function(srcPropName, srcPropVal) {\n            if (target[srcPropName] !== undefined) {\n                super_[srcPropName] = target[srcPropName];\n            }\n\n            target[srcPropName] = srcPropVal;\n        });\n\n        return target;\n    };\n\n    /**\n     * Searches for a given element (elt) in the array, returns -1 if it is not present.\n     */\n    qq.indexOf = function(arr, elt, from) {\n        if (arr.indexOf) {\n            return arr.indexOf(elt, from);\n        }\n\n        from = from || 0;\n        var len = arr.length;\n\n        if (from < 0) {\n            from += len;\n        }\n\n        for (; from < len; from += 1) {\n            if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n\n    //this is a version 4 UUID\n    qq.getUniqueId = function() {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n            /*jslint eqeq: true, bitwise: true*/\n            var r = Math.random() * 16 | 0, v = c == \"x\" ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    };\n\n    //\n    // Browsers and platforms detection\n    qq.ie = function() {\n        return navigator.userAgent.indexOf(\"MSIE\") !== -1 ||\n            navigator.userAgent.indexOf(\"Trident\") !== -1;\n    };\n\n    qq.ie7 = function() {\n        return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n    };\n\n    qq.ie8 = function() {\n        return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n    };\n\n    qq.ie10 = function() {\n        return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n    };\n\n    qq.ie11 = function() {\n        return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n    };\n\n    qq.edge = function() {\n        return navigator.userAgent.indexOf(\"Edge\") >= 0;\n    };\n\n    qq.safari = function() {\n        return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n    };\n\n    qq.chrome = function() {\n        return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n    };\n\n    qq.opera = function() {\n        return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n    };\n\n    qq.firefox = function() {\n        return (!qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\");\n    };\n\n    qq.windows = function() {\n        return navigator.platform === \"Win32\";\n    };\n\n    qq.android = function() {\n        return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n    };\n\n    // We need to identify the Android stock browser via the UA string to work around various bugs in this browser,\n    // such as the one that prevents a `Blob` from being uploaded.\n    qq.androidStock = function() {\n        return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n    };\n\n    qq.ios6 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n    };\n\n    qq.ios7 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n    };\n\n    qq.ios8 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n    };\n\n    // iOS 8.0.0\n    qq.ios800 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n    };\n\n    qq.ios = function() {\n        /*jshint -W014 */\n        return navigator.userAgent.indexOf(\"iPad\") !== -1\n            || navigator.userAgent.indexOf(\"iPod\") !== -1\n            || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n    };\n\n    qq.iosChrome = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n    };\n\n    qq.iosSafari = function() {\n        return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n    };\n\n    qq.iosSafariWebView = function() {\n        return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n    };\n\n    //\n    // Events\n\n    qq.preventDefault = function(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n    };\n\n    /**\n     * Creates and returns element from html string\n     * Uses innerHTML to create an element\n     */\n    qq.toElement = (function() {\n        var div = document.createElement(\"div\");\n        return function(html) {\n            div.innerHTML = html;\n            var element = div.firstChild;\n            div.removeChild(element);\n            return element;\n        };\n    }());\n\n    //key and value are passed to callback for each entry in the iterable item\n    qq.each = function(iterableItem, callback) {\n        var keyOrIndex, retVal;\n\n        if (iterableItem) {\n            // Iterate through [`Storage`](http://www.w3.org/TR/webstorage/#the-storage-interface) items\n            if (window.Storage && iterableItem.constructor === window.Storage) {\n                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                    retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                    if (retVal === false) {\n                        break;\n                    }\n                }\n            }\n            // `DataTransferItemList` & `NodeList` objects are array-like and should be treated as arrays\n            // when iterating over items inside the object.\n            else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                    retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                    if (retVal === false) {\n                        break;\n                    }\n                }\n            }\n            else if (qq.isString(iterableItem)) {\n                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                    retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                    if (retVal === false) {\n                        break;\n                    }\n                }\n            }\n            else {\n                for (keyOrIndex in iterableItem) {\n                    if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    //include any args that should be passed to the new function after the context arg\n    qq.bind = function(oldFunc, context) {\n        if (qq.isFunction(oldFunc)) {\n            var args =  Array.prototype.slice.call(arguments, 2);\n\n            return function() {\n                var newArgs = qq.extend([], args);\n                if (arguments.length) {\n                    newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                }\n                return oldFunc.apply(context, newArgs);\n            };\n        }\n\n        throw new Error(\"first parameter must be a function!\");\n    };\n\n    /**\n     * obj2url() takes a json-object as argument and generates\n     * a querystring. pretty much like jQuery.param()\n     *\n     * how to use:\n     *\n     *    `qq.obj2url({a:'b',c:'d'},'http://any.url/upload?otherParam=value');`\n     *\n     * will result in:\n     *\n     *    `http://any.url/upload?otherParam=value&a=b&c=d`\n     *\n     * @param  Object JSON-Object\n     * @param  String current querystring-part\n     * @return String encoded querystring\n     */\n    qq.obj2url = function(obj, temp, prefixDone) {\n        /*jshint laxbreak: true*/\n        var uristrings = [],\n            prefix = \"&\",\n            add = function(nextObj, i) {\n                var nextTemp = temp\n                    ? (/\\[\\]$/.test(temp)) // prevent double-encoding\n                    ? temp\n                    : temp + \"[\" + i + \"]\"\n                    : i;\n                if ((nextTemp !== \"undefined\") && (i !== \"undefined\")) {\n                    uristrings.push(\n                        (typeof nextObj === \"object\")\n                            ? qq.obj2url(nextObj, nextTemp, true)\n                            : (Object.prototype.toString.call(nextObj) === \"[object Function]\")\n                            ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj())\n                            : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj)\n                    );\n                }\n            };\n\n        if (!prefixDone && temp) {\n            prefix = (/\\?/.test(temp)) ? (/\\?$/.test(temp)) ? \"\" : \"&\" : \"?\";\n            uristrings.push(temp);\n            uristrings.push(qq.obj2url(obj));\n        } else if ((Object.prototype.toString.call(obj) === \"[object Array]\") && (typeof obj !== \"undefined\")) {\n            qq.each(obj, function(idx, val) {\n                add(val, idx);\n            });\n        } else if ((typeof obj !== \"undefined\") && (obj !== null) && (typeof obj === \"object\")) {\n            qq.each(obj, function(prop, val) {\n                add(val, prop);\n            });\n        } else {\n            uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n        }\n\n        if (temp) {\n            return uristrings.join(prefix);\n        } else {\n            return uristrings.join(prefix)\n                .replace(/^&/, \"\")\n                .replace(/%20/g, \"+\");\n        }\n    };\n\n    qq.obj2FormData = function(obj, formData, arrayKeyName) {\n        if (!formData) {\n            formData = new FormData();\n        }\n\n        qq.each(obj, function(key, val) {\n            key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n\n            if (qq.isObject(val)) {\n                qq.obj2FormData(val, formData, key);\n            }\n            else if (qq.isFunction(val)) {\n                formData.append(key, val());\n            }\n            else {\n                formData.append(key, val);\n            }\n        });\n\n        return formData;\n    };\n\n    qq.obj2Inputs = function(obj, form) {\n        var input;\n\n        if (!form) {\n            form = document.createElement(\"form\");\n        }\n\n        qq.obj2FormData(obj, {\n            append: function(key, val) {\n                input = document.createElement(\"input\");\n                input.setAttribute(\"name\", key);\n                input.setAttribute(\"value\", val);\n                form.appendChild(input);\n            }\n        });\n\n        return form;\n    };\n\n    /**\n     * Not recommended for use outside of Fine Uploader since this falls back to an unchecked eval if JSON.parse is not\n     * implemented.  For a more secure JSON.parse polyfill, use Douglas Crockford's json2.js.\n     */\n    qq.parseJson = function(json) {\n        /*jshint evil: true*/\n        if (window.JSON && qq.isFunction(JSON.parse)) {\n            return JSON.parse(json);\n        } else {\n            return eval(\"(\" + json + \")\");\n        }\n    };\n\n    /**\n     * Retrieve the extension of a file, if it exists.\n     *\n     * @param filename\n     * @returns {string || undefined}\n     */\n    qq.getExtension = function(filename) {\n        var extIdx = filename.lastIndexOf(\".\") + 1;\n\n        if (extIdx > 0) {\n            return filename.substr(extIdx, filename.length - extIdx);\n        }\n    };\n\n    qq.getFilename = function(blobOrFileInput) {\n        /*jslint regexp: true*/\n\n        if (qq.isInput(blobOrFileInput)) {\n            // get input value and remove path to normalize\n            return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n        }\n        else if (qq.isFile(blobOrFileInput)) {\n            if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                return blobOrFileInput.fileName;\n            }\n        }\n\n        return blobOrFileInput.name;\n    };\n\n    /**\n     * A generic module which supports object disposing in dispose() method.\n     * */\n    qq.DisposeSupport = function() {\n        var disposers = [];\n\n        return {\n            /** Run all registered disposers */\n            dispose: function() {\n                var disposer;\n                do {\n                    disposer = disposers.shift();\n                    if (disposer) {\n                        disposer();\n                    }\n                }\n                while (disposer);\n            },\n\n            /** Attach event handler and register de-attacher as a disposer */\n            attach: function() {\n                var args = arguments;\n                /*jslint undef:true*/\n                this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n            },\n\n            /** Add disposer to the collection */\n            addDisposer: function(disposeFunction) {\n                disposers.push(disposeFunction);\n            }\n        };\n    };\n}());\n","/* globals define, module, global, qq */\n(function() {\n    \"use strict\";\n    if (typeof define === \"function\" && define.amd) {\n        define(function() {\n            return qq;\n        });\n    }\n    else if (typeof module !== \"undefined\" && module.exports) {\n        module.exports = qq;\n    }\n    else {\n        global.qq = qq;\n    }\n}());\n","/* globals qq */\n/**\n * Fine Uploader top-level Error container.  Inherits from `Error`.\n */\n(function() {\n    \"use strict\";\n\n    qq.Error = function(message) {\n        this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n    };\n\n    qq.Error.prototype = new Error();\n}());\n","/*global qq */\nqq.version = \"5.16.2\";\n","/* globals qq */\nqq.supportedFeatures = (function() {\n    \"use strict\";\n\n    var supportsUploading,\n        supportsUploadingBlobs,\n        supportsFileDrop,\n        supportsAjaxFileUploading,\n        supportsFolderDrop,\n        supportsChunking,\n        supportsResume,\n        supportsUploadViaPaste,\n        supportsUploadCors,\n        supportsDeleteFileXdr,\n        supportsDeleteFileCorsXhr,\n        supportsDeleteFileCors,\n        supportsFolderSelection,\n        supportsImagePreviews,\n        supportsUploadProgress;\n\n    function testSupportsFileInputElement() {\n        var supported = true,\n            tempInput;\n\n        try {\n            tempInput = document.createElement(\"input\");\n            tempInput.type = \"file\";\n            qq(tempInput).hide();\n\n            if (tempInput.disabled) {\n                supported = false;\n            }\n        }\n        catch (ex) {\n            supported = false;\n        }\n\n        return supported;\n    }\n\n    //only way to test for complete Clipboard API support at this time\n    function isChrome14OrHigher() {\n        return (qq.chrome() || qq.opera()) &&\n            navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n    }\n\n    //Ensure we can send cross-origin `XMLHttpRequest`s\n    function isCrossOriginXhrSupported() {\n        if (window.XMLHttpRequest) {\n            var xhr = qq.createXhrInstance();\n\n            //Commonly accepted test for XHR CORS support.\n            return xhr.withCredentials !== undefined;\n        }\n\n        return false;\n    }\n\n    //Test for (terrible) cross-origin ajax transport fallback for IE9 and IE8\n    function isXdrSupported() {\n        return window.XDomainRequest !== undefined;\n    }\n\n    // CORS Ajax requests are supported if it is either possible to send credentialed `XMLHttpRequest`s,\n    // or if `XDomainRequest` is an available alternative.\n    function isCrossOriginAjaxSupported() {\n        if (isCrossOriginXhrSupported()) {\n            return true;\n        }\n\n        return isXdrSupported();\n    }\n\n    function isFolderSelectionSupported() {\n        // We know that folder selection is only supported in Chrome via this proprietary attribute for now\n        return document.createElement(\"input\").webkitdirectory !== undefined;\n    }\n\n    function isLocalStorageSupported() {\n        try {\n            return !!window.localStorage &&\n                // unpatched versions of IE10/11 have buggy impls of localStorage where setItem is a string\n                qq.isFunction(window.localStorage.setItem);\n        }\n        catch (error) {\n            // probably caught a security exception, so no localStorage for you\n            return false;\n        }\n    }\n\n    function isDragAndDropSupported() {\n        var span = document.createElement(\"span\");\n\n        return (\"draggable\" in span || (\"ondragstart\" in span && \"ondrop\" in span)) &&\n            !qq.android() && !qq.ios();\n    }\n\n    supportsUploading = testSupportsFileInputElement();\n\n    supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n\n    supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n\n    supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n\n    // adapted from https://stackoverflow.com/a/23278460/486979\n    supportsFolderDrop = supportsFileDrop && (function() {\n        var input = document.createElement(\"input\");\n\n        input.type = \"file\";\n        return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n    }());\n\n    supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n\n    supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n\n    supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n\n    supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n\n    supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n\n    supportsDeleteFileXdr = isXdrSupported();\n\n    supportsDeleteFileCors = isCrossOriginAjaxSupported();\n\n    supportsFolderSelection = isFolderSelectionSupported();\n\n    supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n\n    supportsUploadProgress = (function() {\n        if (supportsAjaxFileUploading) {\n            return !qq.androidStock() && !qq.iosChrome();\n        }\n        return false;\n    }());\n\n    return {\n        ajaxUploading: supportsAjaxFileUploading,\n        blobUploading: supportsUploadingBlobs,\n        canDetermineSize: supportsAjaxFileUploading,\n        chunking: supportsChunking,\n        deleteFileCors: supportsDeleteFileCors,\n        deleteFileCorsXdr: supportsDeleteFileXdr, //NOTE: will also return true in IE10, where XDR is also supported\n        deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n        dialogElement: !!window.HTMLDialogElement,\n        fileDrop: supportsFileDrop,\n        folderDrop: supportsFolderDrop,\n        folderSelection: supportsFolderSelection,\n        imagePreviews: supportsImagePreviews,\n        imageValidation: supportsImagePreviews,\n        itemSizeValidation: supportsAjaxFileUploading,\n        pause: supportsChunking,\n        progressBar: supportsUploadProgress,\n        resume: supportsResume,\n        scaling: supportsImagePreviews && supportsUploadingBlobs,\n        tiffPreviews: qq.safari(), // Not the best solution, but simple and probably accurate enough (for now)\n        unlimitedScaledImageSize: !qq.ios(), // false simply indicates that there is some known limit\n        uploading: supportsUploading,\n        uploadCors: supportsUploadCors,\n        uploadCustomHeaders: supportsAjaxFileUploading,\n        uploadNonMultipart: supportsAjaxFileUploading,\n        uploadViaPaste: supportsUploadViaPaste\n    };\n\n}());\n","/*globals qq*/\n\n// Is the passed object a promise instance?\nqq.isGenericPromise = function(maybePromise) {\n    \"use strict\";\n    return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n};\n\nqq.Promise = function() {\n    \"use strict\";\n\n    var successArgs, failureArgs,\n        successCallbacks = [],\n        failureCallbacks = [],\n        doneCallbacks = [],\n        state = 0;\n\n    qq.extend(this, {\n        then: function(onSuccess, onFailure) {\n            if (state === 0) {\n                if (onSuccess) {\n                    successCallbacks.push(onSuccess);\n                }\n                if (onFailure) {\n                    failureCallbacks.push(onFailure);\n                }\n            }\n            else if (state === -1) {\n                onFailure && onFailure.apply(null, failureArgs);\n            }\n            else if (onSuccess) {\n                onSuccess.apply(null, successArgs);\n            }\n\n            return this;\n        },\n\n        done: function(callback) {\n            if (state === 0) {\n                doneCallbacks.push(callback);\n            }\n            else {\n                callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n            }\n\n            return this;\n        },\n\n        success: function() {\n            state = 1;\n            successArgs = arguments;\n\n            if (successCallbacks.length) {\n                qq.each(successCallbacks, function(idx, callback) {\n                    callback.apply(null, successArgs);\n                });\n            }\n\n            if (doneCallbacks.length) {\n                qq.each(doneCallbacks, function(idx, callback) {\n                    callback.apply(null, successArgs);\n                });\n            }\n\n            return this;\n        },\n\n        failure: function() {\n            state = -1;\n            failureArgs = arguments;\n\n            if (failureCallbacks.length) {\n                qq.each(failureCallbacks, function(idx, callback) {\n                    callback.apply(null, failureArgs);\n                });\n            }\n\n            if (doneCallbacks.length) {\n                qq.each(doneCallbacks, function(idx, callback) {\n                    callback.apply(null, failureArgs);\n                });\n            }\n\n            return this;\n        }\n    });\n};\n","/* globals qq */\n/**\n * Placeholder for a Blob that will be generated on-demand.\n *\n * @param referenceBlob Parent of the generated blob\n * @param onCreate Function to invoke when the blob must be created.  Must be promissory.\n * @constructor\n */\nqq.BlobProxy = function(referenceBlob, onCreate) {\n    \"use strict\";\n\n    qq.extend(this, {\n        referenceBlob: referenceBlob,\n\n        create: function() {\n            return onCreate(referenceBlob);\n        }\n    });\n};\n","/*globals qq*/\n\n/**\n * This module represents an upload or \"Select File(s)\" button.  It's job is to embed an opaque `<input type=\"file\">`\n * element as a child of a provided \"container\" element.  This \"container\" element (`options.element`) is used to provide\n * a custom style for the `<input type=\"file\">` element.  The ability to change the style of the container element is also\n * provided here by adding CSS classes to the container on hover/focus.\n *\n * TODO Eliminate the mouseover and mouseout event handlers since the :hover CSS pseudo-class should now be\n * available on all supported browsers.\n *\n * @param o Options to override the default values\n */\nqq.UploadButton = function(o) {\n    \"use strict\";\n\n    var self = this,\n\n        disposeSupport = new qq.DisposeSupport(),\n\n        options = {\n            // Corresponds to the `accept` attribute on the associated `<input type=\"file\">`\n            acceptFiles: null,\n\n            // \"Container\" element\n            element: null,\n\n            focusClass: \"qq-upload-button-focus\",\n\n            // A true value allows folders to be selected, if supported by the UA\n            folders: false,\n\n            // **This option will be removed** in the future as the :hover CSS pseudo-class is available on all supported browsers\n            hoverClass: \"qq-upload-button-hover\",\n\n            ios8BrowserCrashWorkaround: false,\n\n            // If true adds `multiple` attribute to `<input type=\"file\">`\n            multiple: false,\n\n            // `name` attribute of `<input type=\"file\">`\n            name: \"qqfile\",\n\n            // Called when the browser invokes the onchange handler on the `<input type=\"file\">`\n            onChange: function(input) {},\n\n            title: null\n        },\n        input, buttonId;\n\n    // Overrides any of the default option values with any option values passed in during construction.\n    qq.extend(options, o);\n\n    buttonId = qq.getUniqueId();\n\n    // Embed an opaque `<input type=\"file\">` element as a child of `options.element`.\n    function createInput() {\n        var input = document.createElement(\"input\");\n\n        input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n        input.setAttribute(\"title\", options.title);\n\n        self.setMultiple(options.multiple, input);\n\n        if (options.folders && qq.supportedFeatures.folderSelection) {\n            // selecting directories is only possible in Chrome now, via a vendor-specific prefixed attribute\n            input.setAttribute(\"webkitdirectory\", \"\");\n        }\n\n        if (options.acceptFiles) {\n            input.setAttribute(\"accept\", options.acceptFiles);\n        }\n\n        input.setAttribute(\"type\", \"file\");\n        input.setAttribute(\"name\", options.name);\n\n        qq(input).css({\n            position: \"absolute\",\n            // in Opera only 'browse' button\n            // is clickable and it is located at\n            // the right side of the input\n            right: 0,\n            top: 0,\n            fontFamily: \"Arial\",\n            // It's especially important to make this an arbitrarily large value\n            // to ensure the rendered input button in IE takes up the entire\n            // space of the container element.  Otherwise, the left side of the\n            // button will require a double-click to invoke the file chooser.\n            // In other browsers, this might cause other issues, so a large font-size\n            // is only used in IE.  There is a bug in IE8 where the opacity style is  ignored\n            // in some cases when the font-size is large.  So, this workaround is not applied\n            // to IE8.\n            fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n            margin: 0,\n            padding: 0,\n            cursor: \"pointer\",\n            opacity: 0\n        });\n\n        // Setting the file input's height to 100% in IE7 causes\n        // most of the visible button to be unclickable.\n        !qq.ie7() && qq(input).css({height: \"100%\"});\n\n        options.element.appendChild(input);\n\n        disposeSupport.attach(input, \"change\", function() {\n            options.onChange(input);\n        });\n\n        // **These event handlers will be removed** in the future as the :hover CSS pseudo-class is available on all supported browsers\n        disposeSupport.attach(input, \"mouseover\", function() {\n            qq(options.element).addClass(options.hoverClass);\n        });\n        disposeSupport.attach(input, \"mouseout\", function() {\n            qq(options.element).removeClass(options.hoverClass);\n        });\n\n        disposeSupport.attach(input, \"focus\", function() {\n            qq(options.element).addClass(options.focusClass);\n        });\n        disposeSupport.attach(input, \"blur\", function() {\n            qq(options.element).removeClass(options.focusClass);\n        });\n\n        return input;\n    }\n\n    // Make button suitable container for input\n    qq(options.element).css({\n        position: \"relative\",\n        overflow: \"hidden\",\n        // Make sure browse button is in the right side in Internet Explorer\n        direction: \"ltr\"\n    });\n\n    // Exposed API\n    qq.extend(this, {\n        getInput: function() {\n            return input;\n        },\n\n        getButtonId: function() {\n            return buttonId;\n        },\n\n        setMultiple: function(isMultiple, optInput) {\n            var input = optInput || this.getInput();\n\n            // Temporary workaround for bug in in iOS8 UIWebView that causes the browser to crash\n            // before the file chooser appears if the file input doesn't contain a multiple attribute.\n            // See #1283.\n            if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                input.setAttribute(\"multiple\", \"\");\n            }\n\n            else {\n                if (isMultiple) {\n                    input.setAttribute(\"multiple\", \"\");\n                }\n                else {\n                    input.removeAttribute(\"multiple\");\n                }\n            }\n        },\n\n        setAcceptFiles: function(acceptFiles) {\n            if (acceptFiles !== options.acceptFiles) {\n                input.setAttribute(\"accept\", acceptFiles);\n            }\n        },\n\n        reset: function() {\n            if (input.parentNode) {\n                qq(input).remove();\n            }\n\n            qq(options.element).removeClass(options.focusClass);\n            input = null;\n            input = createInput();\n        }\n    });\n\n    input = createInput();\n};\n\nqq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n","/*globals qq */\nqq.UploadData = function(uploaderProxy) {\n    \"use strict\";\n\n    var data = [],\n        byUuid = {},\n        byStatus = {},\n        byProxyGroupId = {},\n        byBatchId = {};\n\n    function getDataByIds(idOrIds) {\n        if (qq.isArray(idOrIds)) {\n            var entries = [];\n\n            qq.each(idOrIds, function(idx, id) {\n                entries.push(data[id]);\n            });\n\n            return entries;\n        }\n\n        return data[idOrIds];\n    }\n\n    function getDataByUuids(uuids) {\n        if (qq.isArray(uuids)) {\n            var entries = [];\n\n            qq.each(uuids, function(idx, uuid) {\n                entries.push(data[byUuid[uuid]]);\n            });\n\n            return entries;\n        }\n\n        return data[byUuid[uuids]];\n    }\n\n    function getDataByStatus(status) {\n        var statusResults = [],\n            statuses = [].concat(status);\n\n        qq.each(statuses, function(index, statusEnum) {\n            var statusResultIndexes = byStatus[statusEnum];\n\n            if (statusResultIndexes !== undefined) {\n                qq.each(statusResultIndexes, function(i, dataIndex) {\n                    statusResults.push(data[dataIndex]);\n                });\n            }\n        });\n\n        return statusResults;\n    }\n\n    qq.extend(this, {\n        /**\n         * Adds a new file to the data cache for tracking purposes.\n         *\n         * @param spec Data that describes this file.  Possible properties are:\n         *\n         * - uuid: Initial UUID for this file.\n         * - name: Initial name of this file.\n         * - size: Size of this file, omit if this cannot be determined\n         * - status: Initial `qq.status` for this file.  Omit for `qq.status.SUBMITTING`.\n         * - batchId: ID of the batch this file belongs to\n         * - proxyGroupId: ID of the proxy group associated with this file\n         * - onBeforeStatusChange(fileId): callback that is executed before the status change is broadcast\n         *\n         * @returns {number} Internal ID for this file.\n         */\n        addFile: function(spec) {\n            var status = spec.status || qq.status.SUBMITTING,\n                id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status,\n                    file: spec.file\n                }) - 1;\n\n            if (spec.batchId) {\n                data[id].batchId = spec.batchId;\n\n                if (byBatchId[spec.batchId] === undefined) {\n                    byBatchId[spec.batchId] = [];\n                }\n                byBatchId[spec.batchId].push(id);\n            }\n\n            if (spec.proxyGroupId) {\n                data[id].proxyGroupId = spec.proxyGroupId;\n\n                if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                    byProxyGroupId[spec.proxyGroupId] = [];\n                }\n                byProxyGroupId[spec.proxyGroupId].push(id);\n            }\n\n            data[id].id = id;\n            byUuid[spec.uuid] = id;\n\n            if (byStatus[status] === undefined) {\n                byStatus[status] = [];\n            }\n            byStatus[status].push(id);\n\n            spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n            uploaderProxy.onStatusChange(id, null, status);\n\n            return id;\n        },\n\n        retrieve: function(optionalFilter) {\n            if (qq.isObject(optionalFilter) && data.length)  {\n                if (optionalFilter.id !== undefined) {\n                    return getDataByIds(optionalFilter.id);\n                }\n\n                else if (optionalFilter.uuid !== undefined) {\n                    return getDataByUuids(optionalFilter.uuid);\n                }\n\n                else if (optionalFilter.status) {\n                    return getDataByStatus(optionalFilter.status);\n                }\n            }\n            else {\n                return qq.extend([], data, true);\n            }\n        },\n\n        removeFileRef: function(id) {\n            var record = getDataByIds(id);\n\n            if (record) {\n                delete record.file;\n            }\n        },\n\n        reset: function() {\n            data = [];\n            byUuid = {};\n            byStatus = {};\n            byBatchId = {};\n        },\n\n        setStatus: function(id, newStatus) {\n            var oldStatus = data[id].status,\n                byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n\n            byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n\n            data[id].status = newStatus;\n\n            if (byStatus[newStatus] === undefined) {\n                byStatus[newStatus] = [];\n            }\n            byStatus[newStatus].push(id);\n\n            uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n        },\n\n        uuidChanged: function(id, newUuid) {\n            var oldUuid = data[id].uuid;\n\n            data[id].uuid = newUuid;\n            byUuid[newUuid] = id;\n            delete byUuid[oldUuid];\n        },\n\n        updateName: function(id, newName) {\n            data[id].name = newName;\n        },\n\n        updateSize: function(id, newSize) {\n            data[id].size = newSize;\n        },\n\n        // Only applicable if this file has a parent that we may want to reference later.\n        setParentId: function(targetId, parentId) {\n            data[targetId].parentId = parentId;\n        },\n\n        getIdsInProxyGroup: function(id) {\n            var proxyGroupId = data[id].proxyGroupId;\n\n            if (proxyGroupId) {\n                return byProxyGroupId[proxyGroupId];\n            }\n            return [];\n        },\n\n        getIdsInBatch: function(id) {\n            var batchId = data[id].batchId;\n\n            return byBatchId[batchId];\n        }\n    });\n};\n\nqq.status = {\n    SUBMITTING: \"submitting\",\n    SUBMITTED: \"submitted\",\n    REJECTED: \"rejected\",\n    QUEUED: \"queued\",\n    CANCELED: \"canceled\",\n    PAUSED: \"paused\",\n    UPLOADING: \"uploading\",\n    UPLOAD_FINALIZING: \"upload finalizing\",\n    UPLOAD_RETRYING: \"retrying upload\",\n    UPLOAD_SUCCESSFUL: \"upload successful\",\n    UPLOAD_FAILED: \"upload failed\",\n    DELETE_FAILED: \"delete failed\",\n    DELETING: \"deleting\",\n    DELETED: \"deleted\"\n};\n","/*globals qq*/\n/**\n * Defines the public API for FineUploaderBasic mode.\n */\n(function() {\n    \"use strict\";\n\n    qq.basePublicApi = {\n        // DEPRECATED - TODO REMOVE IN NEXT MAJOR RELEASE (replaced by addFiles)\n        addBlobs: function(blobDataOrArray, params, endpoint) {\n            this.addFiles(blobDataOrArray, params, endpoint);\n        },\n\n        addInitialFiles: function(cannedFileList) {\n            var self = this;\n\n            qq.each(cannedFileList, function(index, cannedFile) {\n                self._addCannedFile(cannedFile);\n            });\n        },\n\n        addFiles: function(data, params, endpoint) {\n            this._maybeHandleIos8SafariWorkaround();\n\n            var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId,\n\n                processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this),\n\n                processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this),\n\n                processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this),\n\n                processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100,\n                        blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this),\n\n                processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files),\n                            self = this;\n\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    }\n                    else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this),\n\n                normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                },\n\n                self = this,\n                verifiedFiles = [];\n\n            this._currentBatchId = batchId;\n\n            if (data) {\n                normalizeData();\n\n                qq.each(data, function(idx, fileContainer) {\n                    if (qq.isFileOrInput(fileContainer)) {\n                        processFileOrInput(fileContainer);\n                    }\n                    else if (qq.isBlob(fileContainer)) {\n                        processBlob(fileContainer);\n                    }\n                    else if (qq.isObject(fileContainer)) {\n                        if (fileContainer.blob && fileContainer.name) {\n                            processBlobData(fileContainer);\n                        }\n                        else if (fileContainer.canvas && fileContainer.name) {\n                            processCanvasData(fileContainer);\n                        }\n                    }\n                    else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                        processCanvas(fileContainer);\n                    }\n                    else {\n                        self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                    }\n                });\n\n                this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n            }\n        },\n\n        cancel: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n                this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n            }\n            else {\n                this._handler.cancel(id);\n            }\n        },\n\n        cancelAll: function() {\n            var storedIdsCopy = [],\n                self = this;\n\n            qq.extend(storedIdsCopy, this._storedIds);\n            qq.each(storedIdsCopy, function(idx, storedFileId) {\n                self.cancel(storedFileId);\n            });\n\n            this._handler.cancelAll();\n        },\n\n        clearStoredFiles: function() {\n            this._storedIds = [];\n        },\n\n        continueUpload: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                return false;\n            }\n\n            if (uploadData.status === qq.status.PAUSED) {\n                this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                this._uploadFile(id);\n                return true;\n            }\n            else {\n                this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n            }\n\n            return false;\n        },\n\n        deleteFile: function(id) {\n            return this._onSubmitDelete(id);\n        },\n\n        // TODO document?\n        doesExist: function(fileOrBlobId) {\n            return this._handler.isValid(fileOrBlobId);\n        },\n\n        // Generate a variable size thumbnail on an img or canvas,\n        // returning a promise that is fulfilled when the attempt completes.\n        // Thumbnail can either be based off of a URL for an image returned\n        // by the server in the upload response, or the associated `Blob`.\n        drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n            var promiseToReturn = new qq.Promise(),\n                fileOrUrl, options;\n\n            if (this._imageGenerator) {\n                fileOrUrl = this._thumbnailUrls[fileId];\n                options = {\n                    customResizeFunction: customResizeFunction,\n                    maxSize: maxSize > 0 ? maxSize : null,\n                    scale: maxSize > 0\n                };\n\n                // If client-side preview generation is possible\n                // and we are not specifically looking for the image URl returned by the server...\n                if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                    fileOrUrl = this.getFile(fileId);\n                }\n\n                /* jshint eqeqeq:false,eqnull:true */\n                if (fileOrUrl == null) {\n                    promiseToReturn.failure({container: imgOrCanvas, error: \"File or URL not found.\"});\n                }\n                else {\n                    this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(\n                        function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        },\n\n                        function failure(container, reason) {\n                            promiseToReturn.failure({container: container, error: reason || \"Problem generating thumbnail\"});\n                        }\n                    );\n                }\n            }\n            else {\n                promiseToReturn.failure({container: imgOrCanvas, error: \"Missing image generator module\"});\n            }\n\n            return promiseToReturn;\n        },\n\n        getButton: function(fileId) {\n            return this._getButton(this._buttonIdsForFileIds[fileId]);\n        },\n\n        getEndpoint: function(fileId) {\n            return this._endpointStore.get(fileId);\n        },\n\n        getFile: function(fileOrBlobId) {\n            var file = this._handler.getFile(fileOrBlobId);\n            var uploadDataRecord;\n\n            if (!file) {\n                uploadDataRecord = this._uploadData.retrieve({id: fileOrBlobId});\n\n                if (uploadDataRecord) {\n                    file = uploadDataRecord.file;\n                }\n            }\n\n            return file || null;\n        },\n\n        getInProgress: function() {\n            return this._uploadData.retrieve({\n                status: [\n                    qq.status.UPLOADING,\n                    qq.status.UPLOAD_RETRYING,\n                    qq.status.QUEUED\n                ]\n            }).length;\n        },\n\n        getName: function(id) {\n            return this._uploadData.retrieve({id: id}).name;\n        },\n\n        // Parent ID for a specific file, or null if this is the parent, or if it has no parent.\n        getParentId: function(id) {\n            var uploadDataEntry = this.getUploads({id: id}),\n                parentId = null;\n\n            if (uploadDataEntry) {\n                if (uploadDataEntry.parentId !== undefined) {\n                    parentId = uploadDataEntry.parentId;\n                }\n            }\n\n            return parentId;\n        },\n\n        getResumableFilesData: function() {\n            return this._handler.getResumableFilesData();\n        },\n\n        getSize: function(id) {\n            return this._uploadData.retrieve({id: id}).size;\n        },\n\n        getNetUploads: function() {\n            return this._netUploaded;\n        },\n\n        getRemainingAllowedItems: function() {\n            var allowedItems = this._currentItemLimit;\n\n            if (allowedItems > 0) {\n                return allowedItems - this._netUploadedOrQueued;\n            }\n\n            return null;\n        },\n\n        getUploads: function(optionalFilter) {\n            return this._uploadData.retrieve(optionalFilter);\n        },\n\n        getUuid: function(id) {\n            return this._uploadData.retrieve({id: id}).uuid;\n        },\n\n        isResumable: function(id) {\n            return this._handler.hasResumeRecord(id);\n        },\n\n        log: function(str, level) {\n            if (this._options.debug && (!level || level === \"info\")) {\n                qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n            }\n            else if (level && level !== \"info\") {\n                qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n\n            }\n        },\n\n        pauseUpload: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                return false;\n            }\n\n            // Pause only really makes sense if the file is uploading or retrying\n            if (qq.indexOf([qq.status.UPLOADING, qq.status.UPLOAD_RETRYING], uploadData.status) >= 0) {\n                if (this._handler.pause(id)) {\n                    this._uploadData.setStatus(id, qq.status.PAUSED);\n                    return true;\n                }\n                else {\n                    this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                }\n            }\n            else {\n                this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n            }\n\n            return false;\n        },\n\n        removeFileRef: function(id) {\n            this._handler.expunge(id);\n            this._uploadData.removeFileRef(id);\n        },\n\n        reset: function() {\n            this.log(\"Resetting uploader...\");\n\n            this._handler.reset();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n\n            qq.each(this._buttons, function(idx, button) {\n                button.reset();\n            });\n\n            this._paramsStore.reset();\n            this._endpointStore.reset();\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData.reset();\n            this._buttonIdsForFileIds = [];\n\n            this._pasteHandler && this._pasteHandler.reset();\n            this._options.session.refreshOnReset && this._refreshSessionData();\n\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n\n            this._totalProgress && this._totalProgress.reset();\n\n            this._customResumeDataStore.reset();\n        },\n\n        retry: function(id) {\n            return this._manualRetry(id);\n        },\n\n        scaleImage: function(id, specs) {\n            var self = this;\n\n            return qq.Scaler.prototype.scaleImage(id, specs, {\n                log: qq.bind(self.log, self),\n                getFile: qq.bind(self.getFile, self),\n                uploadData: self._uploadData\n            });\n        },\n\n        setCustomHeaders: function(headers, id) {\n            this._customHeadersStore.set(headers, id);\n        },\n\n        setCustomResumeData: function(id, data) {\n            this._customResumeDataStore.set(data, id);\n        },\n\n        setDeleteFileCustomHeaders: function(headers, id) {\n            this._deleteFileCustomHeadersStore.set(headers, id);\n        },\n\n        setDeleteFileEndpoint: function(endpoint, id) {\n            this._deleteFileEndpointStore.set(endpoint, id);\n        },\n\n        setDeleteFileParams: function(params, id) {\n            this._deleteFileParamsStore.set(params, id);\n        },\n\n        // Re-sets the default endpoint, an endpoint for a specific file, or an endpoint for a specific button\n        setEndpoint: function(endpoint, id) {\n            this._endpointStore.set(endpoint, id);\n        },\n\n        setForm: function(elementOrId) {\n            this._updateFormSupportAndParams(elementOrId);\n        },\n\n        setItemLimit: function(newItemLimit) {\n            this._currentItemLimit = newItemLimit;\n        },\n\n        setName: function(id, newName) {\n            this._uploadData.updateName(id, newName);\n        },\n\n        setParams: function(params, id) {\n            this._paramsStore.set(params, id);\n        },\n\n        setUuid: function(id, newUuid) {\n            return this._uploadData.uuidChanged(id, newUuid);\n        },\n\n        /**\n         * Expose the internal status of a file id to the public api for manual state changes\n         * @public\n         *\n         * @param {Number} id,\n         * @param {String} newStatus\n         *\n         * @todo Implement the remaining methods\n         */\n        setStatus: function(id, newStatus) {\n            var fileRecord = this.getUploads({id: id});\n            if (!fileRecord) {\n                throw new qq.Error(id + \" is not a valid file ID.\");\n            }\n\n            switch (newStatus) {\n                case qq.status.DELETED:\n                    this._onDeleteComplete(id, null, false);\n                    break;\n                case qq.status.DELETE_FAILED:\n                    this._onDeleteComplete(id, null, true);\n                    break;\n                default:\n                    var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n                    this.log(errorMessage);\n                    throw new qq.Error(errorMessage);\n            }\n        },\n\n        uploadStoredFiles: function() {\n            if (this._storedIds.length === 0) {\n                this._itemError(\"noFilesError\");\n            }\n            else {\n                this._uploadStoredFiles();\n            }\n        }\n    };\n\n    /**\n     * Defines the private (internal) API for FineUploaderBasic mode.\n     */\n    qq.basePrivateApi = {\n        // Updates internal state with a file record (not backed by a live file).  Returns the assigned ID.\n        _addCannedFile: function(sessionData) {\n            var self = this;\n\n            return this._uploadData.addFile({\n                uuid: sessionData.uuid,\n                name: sessionData.name,\n                size: sessionData.size,\n                status: qq.status.UPLOAD_SUCCESSFUL,\n                onBeforeStatusChange: function(id) {\n                    sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                    sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n\n                    if (sessionData.thumbnailUrl) {\n                        self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                    }\n\n                    self._netUploaded++;\n                    self._netUploadedOrQueued++;\n                }\n            });\n        },\n\n        _annotateWithButtonId: function(file, associatedInput) {\n            if (qq.isFile(file)) {\n                file.qqButtonId = this._getButtonId(associatedInput);\n            }\n        },\n\n        _batchError: function(message) {\n            this._options.callbacks.onError(null, null, message, undefined);\n        },\n\n        _createDeleteHandler: function() {\n            var self = this;\n\n            return new qq.DeleteFileAjaxRequester({\n                method: this._options.deleteFile.method.toUpperCase(),\n                maxConnections: this._options.maxConnections,\n                uuidParamName: this._options.request.uuidName,\n                customHeaders: this._deleteFileCustomHeadersStore,\n                paramsStore: this._deleteFileParamsStore,\n                endpointStore: this._deleteFileEndpointStore,\n                cors: this._options.cors,\n                log: qq.bind(self.log, self),\n                onDelete: function(id) {\n                    self._onDelete(id);\n                    self._options.callbacks.onDelete(id);\n                },\n                onDeleteComplete: function(id, xhrOrXdr, isError) {\n                    self._onDeleteComplete(id, xhrOrXdr, isError);\n                    self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                }\n\n            });\n        },\n\n        _createPasteHandler: function() {\n            var self = this;\n\n            return new qq.PasteSupport({\n                targetElement: this._options.paste.targetElement,\n                callbacks: {\n                    log: qq.bind(self.log, self),\n                    pasteReceived: function(blob) {\n                        self._handleCheckedCallback({\n                            name: \"onPasteReceived\",\n                            callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                            onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                            identifier: \"pasted image\"\n                        });\n                    }\n                }\n            });\n        },\n\n        _createStore: function(initialValue, _readOnlyValues_) {\n            var store = {},\n                catchall = initialValue,\n                perIdReadOnlyValues = {},\n                readOnlyValues = _readOnlyValues_,\n                copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                },\n                getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                },\n                includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n\n            return {\n                set: function(val, id) {\n                    /*jshint eqeqeq: true, eqnull: true*/\n                    if (id == null) {\n                        store = {};\n                        catchall = copy(val);\n                    }\n                    else {\n                        store[id] = copy(val);\n                    }\n                },\n\n                get: function(id) {\n                    var values;\n\n                    /*jshint eqeqeq: true, eqnull: true*/\n                    if (id != null && store[id]) {\n                        values = store[id];\n                    }\n                    else {\n                        values = copy(catchall);\n                    }\n\n                    includeReadOnlyValues(id, values);\n\n                    return copy(values);\n                },\n\n                addReadOnly: function(id, values) {\n                    // Only applicable to Object stores\n                    if (qq.isObject(store)) {\n                        // If null ID, apply readonly values to all files\n                        if (id === null) {\n                            if (qq.isFunction(values)) {\n                                readOnlyValues = values;\n                            }\n                            else {\n                                readOnlyValues = readOnlyValues || {};\n                                qq.extend(readOnlyValues, values);\n                            }\n                        }\n                        else {\n                            perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                            qq.extend(perIdReadOnlyValues[id], values);\n                        }\n                    }\n                },\n\n                remove: function(fileId) {\n                    return delete store[fileId];\n                },\n\n                reset: function() {\n                    store = {};\n                    perIdReadOnlyValues = {};\n                    catchall = initialValue;\n                }\n            };\n        },\n\n        _createUploadDataTracker: function() {\n            var self = this;\n\n            return new qq.UploadData({\n                getName: function(id) {\n                    return self.getName(id);\n                },\n                getUuid: function(id) {\n                    return self.getUuid(id);\n                },\n                getSize: function(id) {\n                    return self.getSize(id);\n                },\n                onStatusChange: function(id, oldStatus, newStatus) {\n                    self._onUploadStatusChange(id, oldStatus, newStatus);\n                    self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                    self._maybeAllComplete(id, newStatus);\n\n                    if (self._totalProgress) {\n                        setTimeout(function() {\n                            self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                        }, 0);\n                    }\n                }\n            });\n        },\n\n        /**\n         * Generate a tracked upload button.\n         *\n         * @param spec Object containing a required `element` property\n         * along with optional `multiple`, `accept`, and `folders`.\n         * @returns {qq.UploadButton}\n         * @private\n         */\n        _createUploadButton: function(spec) {\n            var self = this,\n                acceptFiles = spec.accept || this._options.validation.acceptFiles,\n                allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions,\n                button;\n\n            function allowMultiple() {\n                if (qq.supportedFeatures.ajaxUploading) {\n                    // Workaround for bug in iOS7+ (see #1039)\n                    if (self._options.workarounds.iosEmptyVideos &&\n                        qq.ios() &&\n                        !qq.ios6() &&\n                        self._isAllowedExtension(allowedExtensions, \".mov\")) {\n\n                        return false;\n                    }\n\n                    if (spec.multiple === undefined) {\n                        return self._options.multiple;\n                    }\n\n                    return spec.multiple;\n                }\n\n                return false;\n            }\n\n            button = new qq.UploadButton({\n                acceptFiles: acceptFiles,\n                element: spec.element,\n                focusClass: this._options.classes.buttonFocus,\n                folders: spec.folders,\n                hoverClass: this._options.classes.buttonHover,\n                ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                multiple: allowMultiple(),\n                name: this._options.request.inputName,\n                onChange: function(input) {\n                    self._onInputChange(input);\n                },\n                title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n            });\n\n            this._disposeSupport.addDisposer(function() {\n                button.dispose();\n            });\n\n            self._buttons.push(button);\n\n            return button;\n        },\n\n        _createUploadHandler: function(additionalOptions, namespace) {\n            var self = this,\n                lastOnProgress = {},\n                options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        }\n                        else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n\n                        lastOnProgress[id] = {loaded: loaded, total: total};\n\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n\n                        var status = self.getUploads({id: id}).status,\n                            retVal;\n\n                        // This is to deal with some observed cases where the XHR readyStateChange handler is\n                        // invoked by the browser multiple times for the same XHR instance with the same state\n                        // readyState value.  Higher level: don't invoke complete-related code if we've already\n                        // done this.\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n\n                        retVal = self._onComplete(id, name, result, xhr);\n\n                        // If the internal `_onComplete` handler returns a promise, don't invoke the `onComplete` callback\n                        // until the promise has been fulfilled.\n                        if (retVal instanceof  qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        }\n                        else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        var onUploadResult = self._options.callbacks.onUpload(id, name);\n\n                        if (qq.isGenericPromise(onUploadResult)) {\n                            self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n                            return onUploadResult;\n                        }\n\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n\n                        if (qq.isGenericPromise(onUploadChunkResult)) {\n                            self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n                            return onUploadChunkResult;\n                        }\n\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._onUploadChunkSuccess(id, chunkData);\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData, customResumeData) {\n                        return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({uuid: uuid});\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({id: id}).status;\n                        return status === qq.status.QUEUED ||\n                            status === qq.status.SUBMITTED ||\n                            status === qq.status.UPLOAD_RETRYING ||\n                            status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch,\n                    isInProgress: function(id) {\n                        return self.getUploads({id: id}).status === qq.status.UPLOADING;\n                    },\n                    getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n                    setStatus: function(id, status) {\n                        self._uploadData.setStatus(id, status);\n                    }\n                };\n\n            qq.each(this._options.request, function(prop, val) {\n                options[prop] = val;\n            });\n\n            options.customHeaders = this._customHeadersStore;\n\n            if (additionalOptions) {\n                qq.each(additionalOptions, function(key, val) {\n                    options[key] = val;\n                });\n            }\n\n            return new qq.UploadHandlerController(options, namespace);\n        },\n\n        _fileOrBlobRejected: function(id) {\n            this._netUploadedOrQueued--;\n            this._uploadData.setStatus(id, qq.status.REJECTED);\n        },\n\n        _formatSize: function(bytes) {\n            if (bytes === 0) {\n                return bytes + this._options.text.sizeSymbols[0];\n            }\n            var i = -1;\n            do {\n                bytes = bytes / 1000;\n                i++;\n            } while (bytes > 999);\n\n            return Math.max(bytes, 0.1).toFixed(1) + this._options.text.sizeSymbols[i];\n        },\n\n        // Creates an internal object that tracks various properties of each extra button,\n        // and then actually creates the extra button.\n        _generateExtraButtonSpecs: function() {\n            var self = this;\n\n            this._extraButtonSpecs = {};\n\n            qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                var multiple = extraButtonOptionEntry.multiple,\n                    validation = qq.extend({}, self._options.validation, true),\n                    extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n\n                if (multiple === undefined) {\n                    multiple = self._options.multiple;\n                }\n\n                if (extraButtonSpec.validation) {\n                    qq.extend(validation, extraButtonOptionEntry.validation, true);\n                }\n\n                qq.extend(extraButtonSpec, {\n                    multiple: multiple,\n                    validation: validation\n                }, true);\n\n                self._initExtraButton(extraButtonSpec);\n            });\n        },\n\n        _getButton: function(buttonId) {\n            var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n\n            if (extraButtonsSpec) {\n                return extraButtonsSpec.element;\n            }\n            else if (buttonId === this._defaultButtonId) {\n                return this._options.button;\n            }\n        },\n\n        /**\n         * Gets the internally used tracking ID for a button.\n         *\n         * @param buttonOrFileInputOrFile `File`, `<input type=\"file\">`, or a button container element\n         * @returns {*} The button's ID, or undefined if no ID is recoverable\n         * @private\n         */\n        _getButtonId: function(buttonOrFileInputOrFile) {\n            var inputs, fileInput,\n                fileBlobOrInput = buttonOrFileInputOrFile;\n\n            // We want the reference file/blob here if this is a proxy (a file that will be generated on-demand later)\n            if (fileBlobOrInput instanceof qq.BlobProxy) {\n                fileBlobOrInput = fileBlobOrInput.referenceBlob;\n            }\n\n            // If the item is a `Blob` it will never be associated with a button or drop zone.\n            if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                if (qq.isFile(fileBlobOrInput)) {\n                    return fileBlobOrInput.qqButtonId;\n                }\n                else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" &&\n                    fileBlobOrInput.type.toLowerCase() === \"file\") {\n\n                    return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                }\n\n                inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n\n                qq.each(inputs, function(idx, input) {\n                    if (input.getAttribute(\"type\") === \"file\") {\n                        fileInput = input;\n                        return false;\n                    }\n                });\n\n                if (fileInput) {\n                    return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                }\n            }\n        },\n\n        _getCustomResumeData: function(fileId) {\n            return this._customResumeDataStore.get(fileId);\n        },\n\n        _getNotFinished: function() {\n            return this._uploadData.retrieve({\n                status: [\n                    qq.status.UPLOADING,\n                    qq.status.UPLOAD_RETRYING,\n                    qq.status.QUEUED,\n                    qq.status.SUBMITTING,\n                    qq.status.SUBMITTED,\n                    qq.status.PAUSED\n                ]\n            }).length;\n        },\n\n        // Get the validation options for this button.  Could be the default validation option\n        // or a specific one assigned to this particular button.\n        _getValidationBase: function(buttonId) {\n            var extraButtonSpec = this._extraButtonSpecs[buttonId];\n\n            return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n        },\n\n        _getValidationDescriptor: function(fileWrapper) {\n            if (fileWrapper.file instanceof qq.BlobProxy) {\n                return {\n                    name: qq.getFilename(fileWrapper.file.referenceBlob),\n                    size: fileWrapper.file.referenceBlob.size\n                };\n            }\n\n            return {\n                name: this.getUploads({id: fileWrapper.id}).name,\n                size: this.getUploads({id: fileWrapper.id}).size\n            };\n        },\n\n        _getValidationDescriptors: function(fileWrappers) {\n            var self = this,\n                fileDescriptors = [];\n\n            qq.each(fileWrappers, function(idx, fileWrapper) {\n                fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n            });\n\n            return fileDescriptors;\n        },\n\n        // Allows camera access on either the default or an extra button for iOS devices.\n        _handleCameraAccess: function() {\n            if (this._options.camera.ios && qq.ios()) {\n                var acceptIosCamera = \"image/*;capture=camera\",\n                    button = this._options.camera.button,\n                    buttonId = button ? this._getButtonId(button) : this._defaultButtonId,\n                    optionRoot = this._options;\n\n                // If we are not targeting the default button, it is an \"extra\" button\n                if (buttonId && buttonId !== this._defaultButtonId) {\n                    optionRoot = this._extraButtonSpecs[buttonId];\n                }\n\n                // Camera access won't work in iOS if the `multiple` attribute is present on the file input\n                optionRoot.multiple = false;\n\n                // update the options\n                if (optionRoot.validation.acceptFiles === null) {\n                    optionRoot.validation.acceptFiles = acceptIosCamera;\n                }\n                else {\n                    optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                }\n\n                // update the already-created button\n                qq.each(this._buttons, function(idx, button) {\n                    if (button.getButtonId() === buttonId) {\n                        button.setMultiple(optionRoot.multiple);\n                        button.setAcceptFiles(optionRoot.acceptFiles);\n\n                        return false;\n                    }\n                });\n            }\n        },\n\n        _handleCheckedCallback: function(details) {\n            var self = this,\n                callbackRetVal = details.callback();\n\n            if (qq.isGenericPromise(callbackRetVal)) {\n                this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                return callbackRetVal.then(\n                    function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    },\n                    function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        }\n                        else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n            }\n\n            if (callbackRetVal !== false) {\n                details.onSuccess(callbackRetVal);\n            }\n            else {\n                if (details.onFailure) {\n                    this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                    details.onFailure();\n                }\n                else {\n                    this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                }\n            }\n\n            return callbackRetVal;\n        },\n\n        // Updates internal state when a new file has been received, and adds it along with its ID to a passed array.\n        _handleNewFile: function(file, batchId, newFileWrapperList) {\n            var self = this,\n                uuid = qq.getUniqueId(),\n                size = -1,\n                name = qq.getFilename(file),\n                actualFile = file.blob || file,\n                handler = this._customNewFileHandler ?\n                    this._customNewFileHandler :\n                    qq.bind(self._handleNewFileGeneric, self);\n\n            if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                size = actualFile.size;\n            }\n\n            handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                uploadData: self._uploadData,\n                paramsStore: self._paramsStore,\n                addFileToHandler: function(id, file) {\n                    self._handler.add(id, file);\n                    self._netUploadedOrQueued++;\n                    self._trackButton(id);\n                }\n            });\n        },\n\n        _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n            var id = this._uploadData.addFile({\n                uuid: uuid,\n                name: name,\n                size: size,\n                batchId: batchId,\n                file: file\n            });\n\n            this._handler.add(id, file);\n\n            this._trackButton(id);\n\n            this._netUploadedOrQueued++;\n\n            fileList.push({id: id, file: file});\n        },\n\n        _handlePasteSuccess: function(blob, extSuppliedName) {\n            var extension = blob.type.split(\"/\")[1],\n                name = extSuppliedName;\n\n            /*jshint eqeqeq: true, eqnull: true*/\n            if (name == null) {\n                name = this._options.paste.defaultName;\n            }\n\n            name += \".\" + extension;\n\n            this.addFiles({\n                name: name,\n                blob: blob\n            });\n        },\n\n        _handleDeleteSuccess: function(id) {\n            if (this.getUploads({id: id}).status !== qq.status.DELETED) {\n                var name = this.getName(id);\n\n                this._netUploadedOrQueued--;\n                this._netUploaded--;\n                this._handler.expunge(id);\n                this._uploadData.setStatus(id, qq.status.DELETED);\n                this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n            }\n        },\n\n        _handleDeleteFailed: function(id, xhrOrXdr) {\n            var name = this.getName(id);\n\n            this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n            this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n\n            // Check first if xhrOrXdr is actually passed or valid\n            // For error reporting, we only have access to the response status if this is not\n            // an `XDomainRequest`.\n            if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n                this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n            }\n            else {\n                this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n            }\n        },\n\n        // Creates an extra button element\n        _initExtraButton: function(spec) {\n            var button = this._createUploadButton({\n                accept: spec.validation.acceptFiles,\n                allowedExtensions: spec.validation.allowedExtensions,\n                element: spec.element,\n                folders: spec.folders,\n                multiple: spec.multiple,\n                title: spec.fileInputTitle\n            });\n\n            this._extraButtonSpecs[button.getButtonId()] = spec;\n        },\n\n        _initFormSupportAndParams: function() {\n            this._formSupport = qq.FormSupport && new qq.FormSupport(\n                this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this)\n            );\n\n            if (this._formSupport && this._formSupport.attachedToForm) {\n                this._paramsStore = this._createStore(\n                    this._options.request.params,  this._formSupport.getFormInputsAsObject\n                );\n\n                this._options.autoUpload = this._formSupport.newAutoUpload;\n                if (this._formSupport.newEndpoint) {\n                    this._options.request.endpoint = this._formSupport.newEndpoint;\n                }\n            }\n            else {\n                this._paramsStore = this._createStore(this._options.request.params);\n            }\n        },\n\n        _isDeletePossible: function() {\n            if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                return false;\n            }\n\n            if (this._options.cors.expected) {\n                if (qq.supportedFeatures.deleteFileCorsXhr) {\n                    return true;\n                }\n\n                if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            return true;\n        },\n\n        _isAllowedExtension: function(allowed, fileName) {\n            var valid = false;\n\n            if (!allowed.length) {\n                return true;\n            }\n\n            qq.each(allowed, function(idx, allowedExt) {\n                /**\n                 * If an argument is not a string, ignore it.  Added when a possible issue with MooTools hijacking the\n                 * `allowedExtensions` array was discovered.  See case #735 in the issue tracker for more details.\n                 */\n                if (qq.isString(allowedExt)) {\n                    /*jshint eqeqeq: true, eqnull: true*/\n                    var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n\n                    if (fileName.match(extRegex) != null) {\n                        valid = true;\n                        return false;\n                    }\n                }\n            });\n\n            return valid;\n        },\n\n        /**\n         * Constructs and returns a message that describes an item/file error.  Also calls `onError` callback.\n         *\n         * @param code REQUIRED - a code that corresponds to a stock message describing this type of error\n         * @param maybeNameOrNames names of the items that have failed, if applicable\n         * @param item `File`, `Blob`, or `<input type=\"file\">`\n         * @private\n         */\n        _itemError: function(code, maybeNameOrNames, item) {\n            var message = this._options.messages[code],\n                allowedExtensions = [],\n                names = [].concat(maybeNameOrNames),\n                name = names[0],\n                buttonId = this._getButtonId(item),\n                validationBase = this._getValidationBase(buttonId),\n                extensionsForMessage, placeholderMatch;\n\n            function r(name, replacement) { message = message.replace(name, replacement); }\n\n            qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                /**\n                 * If an argument is not a string, ignore it.  Added when a possible issue with MooTools hijacking the\n                 * `allowedExtensions` array was discovered.  See case #735 in the issue tracker for more details.\n                 */\n                if (qq.isString(allowedExtension)) {\n                    allowedExtensions.push(allowedExtension);\n                }\n            });\n\n            extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n\n            r(\"{file}\", this._options.formatFileName(name));\n            r(\"{extensions}\", extensionsForMessage);\n            r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n            r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n\n            placeholderMatch = message.match(/(\\{\\w+\\})/g);\n            if (placeholderMatch !== null) {\n                qq.each(placeholderMatch, function(idx, placeholder) {\n                    r(placeholder, names[idx]);\n                });\n            }\n\n            this._options.callbacks.onError(null, name, message, undefined);\n\n            return message;\n        },\n\n        /**\n         * Conditionally orders a manual retry of a failed upload.\n         *\n         * @param id File ID of the failed upload\n         * @param callback Optional callback to invoke if a retry is prudent.\n         * In lieu of asking the upload handler to retry.\n         * @returns {boolean} true if a manual retry will occur\n         * @private\n         */\n        _manualRetry: function(id, callback) {\n            if (this._onBeforeManualRetry(id)) {\n                this._netUploadedOrQueued++;\n                this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n\n                if (callback) {\n                    callback(id);\n                }\n                else {\n                    this._handler.retry(id);\n                }\n\n                return true;\n            }\n        },\n\n        _maybeAllComplete: function(id, status) {\n            var self = this,\n                notFinished = this._getNotFinished();\n\n            if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                this._succeededSinceLastAllComplete.push(id);\n            }\n            else if (status === qq.status.UPLOAD_FAILED) {\n                this._failedSinceLastAllComplete.push(id);\n            }\n\n            if (notFinished === 0 &&\n                (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                // Attempt to ensure onAllComplete is not invoked before other callbacks, such as onCancel & onComplete\n                setTimeout(function() {\n                    self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                }, 0);\n            }\n        },\n\n        _maybeHandleIos8SafariWorkaround: function() {\n            var self = this;\n\n            if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                setTimeout(function() {\n                    window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                }, 0);\n                throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n            }\n        },\n\n        _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n            // Assuming no one will actually set the response code to something other than 200\n            // and still set 'success' to true...\n            if (!response.success) {\n                if (xhr && xhr.status !== 200 && !response.error) {\n                    this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                }\n                else {\n                    var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                    this._options.callbacks.onError(id, name, errorReason, xhr);\n                }\n            }\n        },\n\n        _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n            var self = this;\n\n            if (items.length > index) {\n                if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                    //use setTimeout to prevent a stack overflow with a large number of files in the batch & non-promissory callbacks\n                    setTimeout(function() {\n                        var validationDescriptor = self._getValidationDescriptor(items[index]),\n                            buttonId = self._getButtonId(items[index].file),\n                            button = self._getButton(buttonId);\n\n                        self._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                            onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                            onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                            identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                        });\n                    }, 0);\n                }\n                else if (!validItem) {\n                    for (; index < items.length; index++) {\n                        self._fileOrBlobRejected(items[index].id);\n                    }\n                }\n            }\n        },\n\n        _onAllComplete: function(successful, failed) {\n            this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n\n            this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n        },\n\n        /**\n         * Attempt to automatically retry a failed upload.\n         *\n         * @param id The file ID of the failed upload\n         * @param name The name of the file associated with the failed upload\n         * @param responseJSON Response from the server, parsed into a javascript object\n         * @param xhr Ajax transport used to send the failed request\n         * @param callback Optional callback to be invoked if a retry is prudent.\n         * Invoked in lieu of asking the upload handler to retry.\n         * @returns {boolean} true if an auto-retry will occur\n         * @private\n         */\n        _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n            var self = this;\n\n            self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n\n            if (self._shouldAutoRetry(id)) {\n                var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1000;\n\n                self._maybeParseAndSendUploadError.apply(self, arguments);\n                self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                self._onBeforeAutoRetry(id, name);\n\n                self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                self._retryTimeouts[id] = setTimeout(function() {\n                    self.log(\"Starting retry for \" + name + \"...\");\n\n                    if (callback) {\n                        callback(id);\n                    }\n                    else {\n                        self._handler.retry(id);\n                    }\n                }, retryWaitPeriod);\n\n                return true;\n            }\n        },\n\n        _onBeforeAutoRetry: function(id, name) {\n            this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n        },\n\n        //return false if we should not attempt the requested retry\n        _onBeforeManualRetry: function(id) {\n            var itemLimit = this._currentItemLimit,\n                fileName;\n\n            if (this._preventRetries[id]) {\n                this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                return false;\n            }\n            else if (this._handler.isValid(id)) {\n                fileName = this.getName(id);\n\n                if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                    return false;\n                }\n\n                if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                    this._itemError(\"retryFailTooManyItems\");\n                    return false;\n                }\n\n                this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                return true;\n            }\n            else {\n                this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                return false;\n            }\n        },\n\n        _onCancel: function(id, name) {\n            this._netUploadedOrQueued--;\n\n            clearTimeout(this._retryTimeouts[id]);\n\n            var storedItemIndex = qq.indexOf(this._storedIds, id);\n            if (!this._options.autoUpload && storedItemIndex >= 0) {\n                this._storedIds.splice(storedItemIndex, 1);\n            }\n\n            this._uploadData.setStatus(id, qq.status.CANCELED);\n        },\n\n        _onComplete: function(id, name, result, xhr) {\n            if (!result.success) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n\n                if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                    this._preventRetries[id] = true;\n                }\n            }\n            else {\n                if (result.thumbnailUrl) {\n                    this._thumbnailUrls[id] = result.thumbnailUrl;\n                }\n\n                this._netUploaded++;\n                this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n            }\n\n            this._maybeParseAndSendUploadError(id, name, result, xhr);\n\n            return result.success ? true : false;\n        },\n\n        _onDelete: function(id) {\n            this._uploadData.setStatus(id, qq.status.DELETING);\n        },\n\n        _onDeleteComplete: function(id, xhrOrXdr, isError) {\n            var name = this.getName(id);\n\n            if (isError) {\n                this._handleDeleteFailed(id, xhrOrXdr);\n            }\n            else {\n                this._handleDeleteSuccess(id);\n            }\n        },\n\n        _onInputChange: function(input) {\n            var fileIndex;\n\n            if (qq.supportedFeatures.ajaxUploading) {\n                for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                    this._annotateWithButtonId(input.files[fileIndex], input);\n                }\n\n                this.addFiles(input.files);\n            }\n            // Android 2.3.x will fire `onchange` even if no file has been selected\n            else if (input.value.length > 0) {\n                this.addFiles(input);\n            }\n\n            qq.each(this._buttons, function(idx, button) {\n                button.reset();\n            });\n        },\n\n        _onProgress: function(id, name, loaded, total) {\n            this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n        },\n\n        _onSubmit: function(id, name) {\n            //nothing to do yet in core uploader\n        },\n\n        _onSubmitCallbackSuccess: function(id, name) {\n            this._onSubmit.apply(this, arguments);\n            this._uploadData.setStatus(id, qq.status.SUBMITTED);\n            this._onSubmitted.apply(this, arguments);\n\n            if (this._options.autoUpload) {\n                this._options.callbacks.onSubmitted.apply(this, arguments);\n                this._uploadFile(id);\n            }\n            else {\n                this._storeForLater(id);\n                this._options.callbacks.onSubmitted.apply(this, arguments);\n            }\n        },\n\n        _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n            var uuid = this.getUuid(id),\n                adjustedOnSuccessCallback;\n\n            if (onSuccessCallback) {\n                adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n            }\n\n            if (this._isDeletePossible()) {\n                this._handleCheckedCallback({\n                    name: \"onSubmitDelete\",\n                    callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                    onSuccess: adjustedOnSuccessCallback ||\n                        qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                    identifier: id\n                });\n                return true;\n            }\n            else {\n                this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" +\n                    \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                return false;\n            }\n        },\n\n        _onSubmitted: function(id) {\n            //nothing to do in the base uploader\n        },\n\n        _onTotalProgress: function(loaded, total) {\n            this._options.callbacks.onTotalProgress(loaded, total);\n        },\n\n        _onUploadPrep: function(id) {\n            // nothing to do in the core uploader for now\n        },\n\n        _onUpload: function(id, name) {\n            this._uploadData.setStatus(id, qq.status.UPLOADING);\n        },\n\n        _onUploadChunk: function(id, chunkData) {\n            //nothing to do in the base uploader\n        },\n\n        _onUploadChunkSuccess: function(id, chunkData) {\n            if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n                this._autoRetries[id] = 0;\n            }\n        },\n\n        _onUploadStatusChange: function(id, oldStatus, newStatus) {\n            // Make sure a \"queued\" retry attempt is canceled if the upload has been paused\n            if (newStatus === qq.status.PAUSED) {\n                clearTimeout(this._retryTimeouts[id]);\n            }\n        },\n\n        _onValidateBatchCallbackFailure: function(fileWrappers) {\n            var self = this;\n\n            qq.each(fileWrappers, function(idx, fileWrapper) {\n                self._fileOrBlobRejected(fileWrapper.id);\n            });\n        },\n\n        _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n            var errorMessage,\n                itemLimit = this._currentItemLimit,\n                proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n\n            if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                if (items.length > 0) {\n                    this._handleCheckedCallback({\n                        name: \"onValidate\",\n                        callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                        onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                        onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                        identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                    });\n                }\n                else {\n                    this._itemError(\"noFilesError\");\n                }\n            }\n            else {\n                this._onValidateBatchCallbackFailure(items);\n                errorMessage = this._options.messages.tooManyItemsError\n                    .replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued)\n                    .replace(/\\{itemLimit\\}/g, itemLimit);\n                this._batchError(errorMessage);\n            }\n        },\n\n        _onValidateCallbackFailure: function(items, index, params, endpoint) {\n            var nextIndex = index + 1;\n\n            this._fileOrBlobRejected(items[index].id, items[index].file.name);\n\n            this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n        },\n\n        _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n            var self = this,\n                nextIndex = index + 1,\n                validationDescriptor = this._getValidationDescriptor(items[index]);\n\n            this._validateFileOrBlobData(items[index], validationDescriptor)\n                .then(\n                function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                },\n                function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                }\n            );\n        },\n\n        _prepareItemsForUpload: function(items, params, endpoint) {\n            if (items.length === 0) {\n                this._itemError(\"noFilesError\");\n                return;\n            }\n\n            var validationDescriptors = this._getValidationDescriptors(items),\n                buttonId = this._getButtonId(items[0].file),\n                button = this._getButton(buttonId);\n\n            this._handleCheckedCallback({\n                name: \"onValidateBatch\",\n                callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                identifier: \"batch validation\"\n            });\n        },\n\n        _preventLeaveInProgress: function() {\n            var self = this;\n\n            this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                if (self.getInProgress()) {\n                    e = e || window.event;\n                    // for ie, ff\n                    e.returnValue = self._options.messages.onLeave;\n                    // for webkit\n                    return self._options.messages.onLeave;\n                }\n            });\n        },\n\n        // Attempts to refresh session data only if the `qq.Session` module exists\n        // and a session endpoint has been specified.  The `onSessionRequestComplete`\n        // callback will be invoked once the refresh is complete.\n        _refreshSessionData: function() {\n            var self = this,\n                options = this._options.session;\n\n            /* jshint eqnull:true */\n            if (qq.Session && this._options.session.endpoint != null) {\n                if (!this._session) {\n                    qq.extend(options, {cors: this._options.cors});\n\n                    options.log = qq.bind(this.log, this);\n                    options.addFileRecord = qq.bind(this._addCannedFile, this);\n\n                    this._session = new qq.Session(options);\n                }\n\n                setTimeout(function() {\n                    self._session.refresh().then(function(response, xhrOrXdr) {\n                        self._sessionRequestComplete();\n                        self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n\n                    }, function(response, xhrOrXdr) {\n\n                        self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                    });\n                }, 0);\n            }\n        },\n\n        _sessionRequestComplete: function() {},\n\n        _setSize: function(id, newSize) {\n            this._uploadData.updateSize(id, newSize);\n            this._totalProgress && this._totalProgress.onNewSize(id);\n        },\n\n        _shouldAutoRetry: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            /*jshint laxbreak: true */\n            if (!this._preventRetries[id]\n                && this._options.retry.enableAuto\n                && uploadData.status !== qq.status.PAUSED) {\n\n                if (this._autoRetries[id] === undefined) {\n                    this._autoRetries[id] = 0;\n                }\n\n                if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                    this._autoRetries[id] += 1;\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        _storeForLater: function(id) {\n            this._storedIds.push(id);\n        },\n\n        // Maps a file with the button that was used to select it.\n        _trackButton: function(id) {\n            var buttonId;\n\n            if (qq.supportedFeatures.ajaxUploading) {\n                buttonId = this._handler.getFile(id).qqButtonId;\n            }\n            else {\n                buttonId = this._getButtonId(this._handler.getInput(id));\n            }\n\n            if (buttonId) {\n                this._buttonIdsForFileIds[id] = buttonId;\n            }\n        },\n\n        _updateFormSupportAndParams: function(formElementOrId) {\n            this._options.form.element = formElementOrId;\n\n            this._formSupport = qq.FormSupport && new qq.FormSupport(\n                    this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this)\n                );\n\n            if (this._formSupport && this._formSupport.attachedToForm) {\n                this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n\n                this._options.autoUpload = this._formSupport.newAutoUpload;\n                if (this._formSupport.newEndpoint) {\n                    this.setEndpoint(this._formSupport.newEndpoint);\n                }\n            }\n        },\n\n        _upload: function(id, params, endpoint) {\n            var name = this.getName(id);\n\n            if (params) {\n                this.setParams(params, id);\n            }\n\n            if (endpoint) {\n                this.setEndpoint(endpoint, id);\n            }\n\n            this._handleCheckedCallback({\n                name: \"onSubmit\",\n                callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                identifier: id\n            });\n        },\n\n        _uploadFile: function(id) {\n            if (!this._handler.upload(id)) {\n                this._uploadData.setStatus(id, qq.status.QUEUED);\n            }\n        },\n\n        _uploadStoredFiles: function() {\n            var idToUpload, stillSubmitting,\n                self = this;\n\n            while (this._storedIds.length) {\n                idToUpload = this._storedIds.shift();\n                this._uploadFile(idToUpload);\n            }\n\n            // If we are still waiting for some files to clear validation, attempt to upload these again in a bit\n            stillSubmitting = this.getUploads({status: qq.status.SUBMITTING}).length;\n            if (stillSubmitting) {\n                qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                setTimeout(function() {\n                    self._uploadStoredFiles();\n                }, 1000);\n            }\n        },\n\n        /**\n         * Performs some internal validation checks on an item, defined in the `validation` option.\n         *\n         * @param fileWrapper Wrapper containing a `file` along with an `id`\n         * @param validationDescriptor Normalized information about the item (`size`, `name`).\n         * @returns qq.Promise with appropriate callbacks invoked depending on the validity of the file\n         * @private\n         */\n        _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n            var self = this,\n                file = (function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }()),\n                name = validationDescriptor.name,\n                size = validationDescriptor.size,\n                buttonId = this._getButtonId(fileWrapper.file),\n                validationBase = this._getValidationBase(buttonId),\n                validityChecker = new qq.Promise();\n\n            validityChecker.then(\n                function() {},\n                function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n\n            if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                this._itemError(\"typeError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (!this._options.validation.allowEmpty && size === 0) {\n                this._itemError(\"emptyError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                this._itemError(\"sizeError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (size > 0 && size < validationBase.minSizeLimit) {\n                this._itemError(\"minSizeError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(\n                    validityChecker.success,\n                    function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    }\n                );\n            }\n            else {\n                validityChecker.success();\n            }\n\n            return validityChecker;\n        },\n\n        _wrapCallbacks: function() {\n            var self, safeCallback, prop;\n\n            self = this;\n\n            safeCallback = function(name, callback, args) {\n                var errorMsg;\n\n                try {\n                    return callback.apply(self, args);\n                }\n                catch (exception) {\n                    errorMsg = exception.message || exception.toString();\n                    self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                }\n            };\n\n            /* jshint forin: false, loopfunc: true */\n            for (prop in this._options.callbacks) {\n                (function() {\n                    var callbackName, callbackFunc;\n                    callbackName = prop;\n                    callbackFunc = self._options.callbacks[callbackName];\n                    self._options.callbacks[callbackName] = function() {\n                        return safeCallback(callbackName, callbackFunc, arguments);\n                    };\n                }());\n            }\n        }\n    };\n}());\n","/*globals qq*/\n(function() {\n    \"use strict\";\n\n    qq.FineUploaderBasic = function(o) {\n        var self = this;\n\n        // These options define FineUploaderBasic mode.\n        this._options = {\n            debug: false,\n            button: null,\n            multiple: true,\n            maxConnections: 3,\n            disableCancelForFormUploads: false,\n            autoUpload: true,\n            warnBeforeUnload: true,\n\n            request: {\n                customHeaders: {},\n                endpoint: \"/server/upload\",\n                filenameParam: \"qqfilename\",\n                forceMultipart: true,\n                inputName: \"qqfile\",\n                method: \"POST\",\n                omitDefaultParams: false,\n                params: {},\n                paramsInBody: true,\n                requireSuccessJson: true,\n                totalFileSizeName: \"qqtotalfilesize\",\n                uuidName: \"qquuid\"\n            },\n\n            validation: {\n                allowedExtensions: [],\n                sizeLimit: 0,\n                minSizeLimit: 0,\n                itemLimit: 0,\n                stopOnFirstInvalidFile: true,\n                acceptFiles: null,\n                image: {\n                    maxHeight: 0,\n                    maxWidth: 0,\n                    minHeight: 0,\n                    minWidth: 0\n                },\n                allowEmpty: false\n            },\n\n            callbacks: {\n                onSubmit: function(id, name) {},\n                onSubmitted: function(id, name) {},\n                onComplete: function(id, name, responseJSON, maybeXhr) {},\n                onAllComplete: function(successful, failed) {},\n                onCancel: function(id, name) {},\n                onUpload: function(id, name) {},\n                onUploadChunk: function(id, name, chunkData) {},\n                onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                onResume: function(id, fileName, chunkData, customResumeData) {},\n                onProgress: function(id, name, loaded, total) {},\n                onTotalProgress: function(loaded, total) {},\n                onError: function(id, name, reason, maybeXhrOrXdr) {},\n                onAutoRetry: function(id, name, attemptNumber) {},\n                onManualRetry: function(id, name) {},\n                onValidateBatch: function(fileOrBlobData) {},\n                onValidate: function(fileOrBlobData) {},\n                onSubmitDelete: function(id) {},\n                onDelete: function(id) {},\n                onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                onPasteReceived: function(blob) {},\n                onStatusChange: function(id, oldStatus, newStatus) {},\n                onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n            },\n\n            messages: {\n                typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                emptyError: \"{file} is empty, please select files again without it.\",\n                noFilesError: \"No files to upload.\",\n                tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                maxHeightImageError: \"Image is too tall.\",\n                maxWidthImageError: \"Image is too wide.\",\n                minHeightImageError: \"Image is not tall enough.\",\n                minWidthImageError: \"Image is not wide enough.\",\n                retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n            },\n\n            retry: {\n                enableAuto: false,\n                maxAutoAttempts: 3,\n                autoAttemptDelay: 5,\n                preventRetryResponseProperty: \"preventRetry\"\n            },\n\n            classes: {\n                buttonHover: \"qq-upload-button-hover\",\n                buttonFocus: \"qq-upload-button-focus\"\n            },\n\n            chunking: {\n                enabled: false,\n                concurrent: {\n                    enabled: false\n                },\n                mandatory: false,\n                paramNames: {\n                    partIndex: \"qqpartindex\",\n                    partByteOffset: \"qqpartbyteoffset\",\n                    chunkSize: \"qqchunksize\",\n                    totalFileSize: \"qqtotalfilesize\",\n                    totalParts: \"qqtotalparts\"\n                },\n                partSize: function(id) {\n                    return 2000000;\n                },\n                // only relevant for traditional endpoints, only required when concurrent.enabled === true\n                success: {\n                    endpoint: null,\n\n                    headers: function(id) {\n                        return null;\n                    },\n\n                    jsonPayload: false,\n\n                    method: \"POST\",\n\n                    params: function(id) {\n                        return null;\n                    },\n\n                    resetOnStatus: []\n                }\n            },\n\n            resume: {\n                enabled: false,\n                recordsExpireIn: 7, //days\n                paramNames: {\n                    resuming: \"qqresume\"\n                },\n                customKeys: function(fileId) {\n                    return [];\n                }\n            },\n\n            formatFileName: function(fileOrBlobName) {\n                return fileOrBlobName;\n            },\n\n            text: {\n                defaultResponseError: \"Upload failure reason unknown\",\n                fileInputTitle: \"file input\",\n                sizeSymbols: [\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"]\n            },\n\n            deleteFile: {\n                enabled: false,\n                method: \"DELETE\",\n                endpoint: \"/server/upload\",\n                customHeaders: {},\n                params: {}\n            },\n\n            cors: {\n                expected: false,\n                sendCredentials: false,\n                allowXdr: false\n            },\n\n            blobs: {\n                defaultName: \"misc_data\"\n            },\n\n            paste: {\n                targetElement: null,\n                defaultName: \"pasted_image\"\n            },\n\n            camera: {\n                ios: false,\n\n                // if ios is true: button is null means target the default button, otherwise target the button specified\n                button: null\n            },\n\n            // This refers to additional upload buttons to be handled by Fine Uploader.\n            // Each element is an object, containing `element` as the only required\n            // property.  The `element` must be a container that will ultimately\n            // contain an invisible `<input type=\"file\">` created by Fine Uploader.\n            // Optional properties of each object include `multiple`, `validation`,\n            // and `folders`.\n            extraButtons: [],\n\n            // Depends on the session module.  Used to query the server for an initial file list\n            // during initialization and optionally after a `reset`.\n            session: {\n                endpoint: null,\n                params: {},\n                customHeaders: {},\n                refreshOnReset: true\n            },\n\n            // Send parameters associated with an existing form along with the files\n            form: {\n                // Element ID, HTMLElement, or null\n                element: \"qq-form\",\n\n                // Overrides the base `autoUpload`, unless `element` is null.\n                autoUpload: false,\n\n                // true = upload files on form submission (and squelch submit event)\n                interceptSubmit: true\n            },\n\n            // scale images client side, upload a new file for each scaled version\n            scaling: {\n                customResizer: null,\n\n                // send the original file as well\n                sendOriginal: true,\n\n                // fox orientation for scaled images\n                orient: true,\n\n                // If null, scaled image type will match reference image type.  This value will be referred to\n                // for any size record that does not specific a type.\n                defaultType: null,\n\n                defaultQuality: 80,\n\n                failureText: \"Failed to scale\",\n\n                includeExif: false,\n\n                // metadata about each requested scaled version\n                sizes: []\n            },\n\n            workarounds: {\n                iosEmptyVideos: true,\n                ios8SafariUploads: true,\n                ios8BrowserCrash: false\n            }\n        };\n\n        // Replace any default options with user defined ones\n        qq.extend(this._options, o, true);\n\n        this._buttons = [];\n        this._extraButtonSpecs = {};\n        this._buttonIdsForFileIds = [];\n\n        this._wrapCallbacks();\n        this._disposeSupport =  new qq.DisposeSupport();\n\n        this._storedIds = [];\n        this._autoRetries = [];\n        this._retryTimeouts = [];\n        this._preventRetries = [];\n        this._thumbnailUrls = [];\n\n        this._netUploadedOrQueued = 0;\n        this._netUploaded = 0;\n        this._uploadData = this._createUploadDataTracker();\n\n        this._initFormSupportAndParams();\n\n        this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n        this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n\n        this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n\n        this._endpointStore = this._createStore(this._options.request.endpoint);\n        this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n\n        this._handler = this._createUploadHandler();\n\n        this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n\n        if (this._options.button) {\n            this._defaultButtonId = this._createUploadButton({\n                element: this._options.button,\n                title: this._options.text.fileInputTitle\n            }).getButtonId();\n        }\n\n        this._generateExtraButtonSpecs();\n\n        this._handleCameraAccess();\n\n        if (this._options.paste.targetElement) {\n            if (qq.PasteSupport) {\n                this._pasteHandler = this._createPasteHandler();\n            }\n            else {\n                this.log(\"Paste support module not found\", \"error\");\n            }\n        }\n\n        this._options.warnBeforeUnload && this._preventLeaveInProgress();\n\n        this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n        this._refreshSessionData();\n\n        this._succeededSinceLastAllComplete = [];\n        this._failedSinceLastAllComplete = [];\n\n        this._scaler = (qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this))) || {};\n        if (this._scaler.enabled) {\n            this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n        }\n\n        if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n            this._totalProgress = new qq.TotalProgress(\n                qq.bind(this._onTotalProgress, this),\n\n                function(id) {\n                    var entry = self._uploadData.retrieve({id: id});\n                    return (entry && entry.size) || 0;\n                }\n            );\n        }\n\n        this._currentItemLimit = this._options.validation.itemLimit;\n\n        this._customResumeDataStore = this._createStore();\n    };\n\n    // Define the private & public API methods.\n    qq.FineUploaderBasic.prototype = qq.basePublicApi;\n    qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n}());\n","/*globals qq, XDomainRequest*/\n/** Generic class for sending non-upload ajax requests and handling the associated responses **/\nqq.AjaxRequester = function(o) {\n    \"use strict\";\n\n    var log, shouldParamsBeInQueryString,\n        queue = [],\n        requestData = {},\n        options = {\n            acceptHeader: null,\n            validMethods: [\"PATCH\", \"POST\", \"PUT\"],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [200, 202, 204],\n                PATCH: [200, 201, 202, 203, 204],\n                POST: [200, 201, 202, 203, 204],\n                PUT: [200, 201, 202, 203, 204],\n                GET: [200]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n\n    qq.extend(options, o);\n    log = options.log;\n\n    if (qq.indexOf(options.validMethods, options.method) < 0) {\n        throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n    }\n\n    // [Simple methods](http://www.w3.org/TR/cors/#simple-method)\n    // are defined by the W3C in the CORS spec as a list of methods that, in part,\n    // make a CORS request eligible to be exempt from preflighting.\n    function isSimpleMethod() {\n        return qq.indexOf([\"GET\", \"POST\", \"HEAD\"], options.method) >= 0;\n    }\n\n    // [Simple headers](http://www.w3.org/TR/cors/#simple-header)\n    // are defined by the W3C in the CORS spec as a list of headers that, in part,\n    // make a CORS request eligible to be exempt from preflighting.\n    function containsNonSimpleHeaders(headers) {\n        var containsNonSimple = false;\n\n        qq.each(containsNonSimple, function(idx, header) {\n            if (qq.indexOf([\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\"], header) < 0) {\n                containsNonSimple = true;\n                return false;\n            }\n        });\n\n        return containsNonSimple;\n    }\n\n    function isXdr(xhr) {\n        //The `withCredentials` test is a commonly accepted way to determine if XHR supports CORS.\n        return options.cors.expected && xhr.withCredentials === undefined;\n    }\n\n    // Returns either a new `XMLHttpRequest` or `XDomainRequest` instance.\n    function getCorsAjaxTransport() {\n        var xhrOrXdr;\n\n        if (window.XMLHttpRequest || window.ActiveXObject) {\n            xhrOrXdr = qq.createXhrInstance();\n\n            if (xhrOrXdr.withCredentials === undefined) {\n                xhrOrXdr = new XDomainRequest();\n                // Workaround for XDR bug in IE9 - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment\n                xhrOrXdr.onload = function() {};\n                xhrOrXdr.onerror = function() {};\n                xhrOrXdr.ontimeout = function() {};\n                xhrOrXdr.onprogress = function() {};\n            }\n        }\n\n        return xhrOrXdr;\n    }\n\n    // Returns either a new XHR/XDR instance, or an existing one for the associated `File` or `Blob`.\n    function getXhrOrXdr(id, suppliedXhr) {\n        var xhrOrXdr = requestData[id] && requestData[id].xhr;\n\n        if (!xhrOrXdr) {\n            if (suppliedXhr) {\n                xhrOrXdr = suppliedXhr;\n            }\n            else {\n                if (options.cors.expected) {\n                    xhrOrXdr = getCorsAjaxTransport();\n                }\n                else {\n                    xhrOrXdr = qq.createXhrInstance();\n                }\n            }\n\n            requestData[id].xhr = xhrOrXdr;\n        }\n\n        return xhrOrXdr;\n    }\n\n    // Removes element from queue, sends next request\n    function dequeue(id) {\n        var i = qq.indexOf(queue, id),\n            max = options.maxConnections,\n            nextId;\n\n        delete requestData[id];\n        queue.splice(i, 1);\n\n        if (queue.length >= max && i < max) {\n            nextId = queue[max - 1];\n            sendRequest(nextId);\n        }\n    }\n\n    function onComplete(id, xdrError) {\n        var xhr = getXhrOrXdr(id),\n            method = options.method,\n            isError = xdrError === true;\n\n        dequeue(id);\n\n        if (isError) {\n            log(method + \" request for \" + id + \" has failed\", \"error\");\n        }\n        else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n            isError = true;\n            log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n        }\n\n        options.onComplete(id, xhr, isError);\n    }\n\n    function getParams(id) {\n        var onDemandParams = requestData[id].additionalParams,\n            mandatedParams = options.mandatedParams,\n            params;\n\n        if (options.paramsStore.get) {\n            params = options.paramsStore.get(id);\n        }\n\n        if (onDemandParams) {\n            qq.each(onDemandParams, function(name, val) {\n                params = params || {};\n                params[name] = val;\n            });\n        }\n\n        if (mandatedParams) {\n            qq.each(mandatedParams, function(name, val) {\n                params = params || {};\n                params[name] = val;\n            });\n        }\n\n        return params;\n    }\n\n    function sendRequest(id, optXhr) {\n        var xhr = getXhrOrXdr(id, optXhr),\n            method = options.method,\n            params = getParams(id),\n            payload = requestData[id].payload,\n            url;\n\n        options.onSend(id);\n\n        url = createUrl(id, params, requestData[id].additionalQueryParams);\n\n        // XDR and XHR status detection APIs differ a bit.\n        if (isXdr(xhr)) {\n            xhr.onload = getXdrLoadHandler(id);\n            xhr.onerror = getXdrErrorHandler(id);\n        }\n        else {\n            xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n        }\n\n        registerForUploadProgress(id);\n\n        // The last parameter is assumed to be ignored if we are actually using `XDomainRequest`.\n        xhr.open(method, url, true);\n\n        // Instruct the transport to send cookies along with the CORS request,\n        // unless we are using `XDomainRequest`, which is not capable of this.\n        if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n            xhr.withCredentials = true;\n        }\n\n        setHeaders(id);\n\n        log(\"Sending \" + method + \" request for \" + id);\n\n        if (payload) {\n            xhr.send(payload);\n        }\n        else if (shouldParamsBeInQueryString || !params) {\n            xhr.send();\n        }\n        else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n            xhr.send(qq.obj2url(params, \"\"));\n        }\n        else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n            xhr.send(JSON.stringify(params));\n        }\n        else {\n            xhr.send(params);\n        }\n\n        return xhr;\n    }\n\n    function createUrl(id, params, additionalQueryParams) {\n        var endpoint = options.endpointStore.get(id),\n            addToPath = requestData[id].addToPath;\n\n        /*jshint -W116,-W041 */\n        if (addToPath != undefined) {\n            endpoint += \"/\" + addToPath;\n        }\n\n        if (shouldParamsBeInQueryString && params) {\n            endpoint = qq.obj2url(params, endpoint);\n        }\n\n        if (additionalQueryParams) {\n            endpoint = qq.obj2url(additionalQueryParams, endpoint);\n        }\n\n        return endpoint;\n    }\n\n    // Invoked by the UA to indicate a number of possible states that describe\n    // a live `XMLHttpRequest` transport.\n    function getXhrReadyStateChangeHandler(id) {\n        return function() {\n            if (getXhrOrXdr(id).readyState === 4) {\n                onComplete(id);\n            }\n        };\n    }\n\n    function registerForUploadProgress(id) {\n        var onProgress = options.onProgress;\n\n        if (onProgress) {\n            getXhrOrXdr(id).upload.onprogress = function(e) {\n                if (e.lengthComputable) {\n                    onProgress(id, e.loaded, e.total);\n                }\n            };\n        }\n    }\n\n    // This will be called by IE to indicate **success** for an associated\n    // `XDomainRequest` transported request.\n    function getXdrLoadHandler(id) {\n        return function() {\n            onComplete(id);\n        };\n    }\n\n    // This will be called by IE to indicate **failure** for an associated\n    // `XDomainRequest` transported request.\n    function getXdrErrorHandler(id) {\n        return function() {\n            onComplete(id, true);\n        };\n    }\n\n    function setHeaders(id) {\n        var xhr = getXhrOrXdr(id),\n            customHeaders = options.customHeaders,\n            onDemandHeaders = requestData[id].additionalHeaders || {},\n            method = options.method,\n            allHeaders = {};\n\n        // If XDomainRequest is being used, we can't set headers, so just ignore this block.\n        if (!isXdr(xhr)) {\n            options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n\n            // Only attempt to add X-Requested-With & Cache-Control if permitted\n            if (options.allowXRequestedWithAndCacheControl) {\n                // Do not add X-Requested-With & Cache-Control if this is a cross-origin request\n                // OR the cross-origin request contains a non-simple method or header.\n                // This is done to ensure a preflight is not triggered exclusively based on the\n                // addition of these 2 non-simple headers.\n                if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                    xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                    xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                }\n            }\n\n            if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                xhr.setRequestHeader(\"Content-Type\", options.contentType);\n            }\n\n            qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n            qq.extend(allHeaders, onDemandHeaders);\n\n            qq.each(allHeaders, function(name, val) {\n                xhr.setRequestHeader(name, val);\n            });\n        }\n    }\n\n    function isResponseSuccessful(responseCode) {\n        return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n    }\n\n    function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n        requestData[id] = {\n            addToPath: addToPath,\n            additionalParams: additionalParams,\n            additionalQueryParams: additionalQueryParams,\n            additionalHeaders: additionalHeaders,\n            payload: payload\n        };\n\n        var len = queue.push(id);\n\n        // if too many active connections, wait...\n        if (len <= options.maxConnections) {\n            return sendRequest(id, optXhr);\n        }\n    }\n\n    shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n\n    qq.extend(this, {\n        // Start the process of sending the request.  The ID refers to the file associated with the request.\n        initTransport: function(id) {\n            var path, params, headers, payload, cacheBuster, additionalQueryParams;\n\n            return {\n                // Optionally specify the end of the endpoint path for the request.\n                withPath: function(appendToPath) {\n                    path = appendToPath;\n                    return this;\n                },\n\n                // Optionally specify additional parameters to send along with the request.\n                // These will be added to the query string for GET/DELETE requests or the payload\n                // for POST/PUT requests.  The Content-Type of the request will be used to determine\n                // how these parameters should be formatted as well.\n                withParams: function(additionalParams) {\n                    params = additionalParams;\n                    return this;\n                },\n\n                withQueryParams: function(_additionalQueryParams_) {\n                    additionalQueryParams = _additionalQueryParams_;\n                    return this;\n                },\n\n                // Optionally specify additional headers to send along with the request.\n                withHeaders: function(additionalHeaders) {\n                    headers = additionalHeaders;\n                    return this;\n                },\n\n                // Optionally specify a payload/body for the request.\n                withPayload: function(thePayload) {\n                    payload = thePayload;\n                    return this;\n                },\n\n                // Appends a cache buster (timestamp) to the request URL as a query parameter (only if GET or DELETE)\n                withCacheBuster: function() {\n                    cacheBuster = true;\n                    return this;\n                },\n\n                // Send the constructed request.\n                send: function(optXhr) {\n                    if (cacheBuster && qq.indexOf([\"GET\", \"DELETE\"], options.method) >= 0) {\n                        params.qqtimestamp = new Date().getTime();\n                    }\n\n                    return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                }\n            };\n        },\n\n        canceled: function(id) {\n            dequeue(id);\n        }\n    });\n};\n","/* globals qq */\n/**\n * Common upload handler functions.\n *\n * @constructor\n */\nqq.UploadHandler = function(spec) {\n    \"use strict\";\n\n    var proxy = spec.proxy,\n        fileState = {},\n        onCancel = proxy.onCancel,\n        getName = proxy.getName;\n\n    qq.extend(this, {\n        add: function(id, fileItem) {\n            fileState[id] = fileItem;\n            fileState[id].temp = {};\n        },\n\n        cancel: function(id) {\n            var self = this,\n                cancelFinalizationEffort = new qq.Promise(),\n                onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n\n            onCancelRetVal.then(function() {\n                if (self.isValid(id)) {\n                    fileState[id].canceled = true;\n                    self.expunge(id);\n                }\n                cancelFinalizationEffort.success();\n            });\n        },\n\n        expunge: function(id) {\n            delete fileState[id];\n        },\n\n        getThirdPartyFileId: function(id) {\n            return fileState[id].key;\n        },\n\n        isValid: function(id) {\n            return fileState[id] !== undefined;\n        },\n\n        reset: function() {\n            fileState = {};\n        },\n\n        _getFileState: function(id) {\n            return fileState[id];\n        },\n\n        _setThirdPartyFileId: function(id, thirdPartyFileId) {\n            fileState[id].key = thirdPartyFileId;\n        },\n\n        _wasCanceled: function(id) {\n            return !!fileState[id].canceled;\n        }\n    });\n};\n","/*globals qq*/\n/**\n * Base upload handler module.  Controls more specific handlers.\n *\n * @param o Options.  Passed along to the specific handler submodule as well.\n * @param namespace [optional] Namespace for the specific handler.\n */\nqq.UploadHandlerController = function(o, namespace) {\n    \"use strict\";\n\n    var controller = this,\n        chunkingPossible = false,\n        concurrentChunkingPossible = false,\n        chunking, preventRetryResponse, log, handler,\n\n    options = {\n        paramsStore: {},\n        maxConnections: 3, // maximum number of concurrent uploads\n        chunking: {\n            enabled: false,\n            multiple: {\n                enabled: false\n            }\n        },\n        log: function(str, level) {},\n        onProgress: function(id, fileName, loaded, total) {},\n        onComplete: function(id, fileName, response, xhr) {},\n        onCancel: function(id, fileName) {},\n        onUploadPrep: function(id) {}, // Called if non-trivial operations will be performed before onUpload\n        onUpload: function(id, fileName) {},\n        onUploadChunk: function(id, fileName, chunkData) {},\n        onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n        onAutoRetry: function(id, fileName, response, xhr) {},\n        onResume: function(id, fileName, chunkData, customResumeData) {},\n        onUuidChanged: function(id, newUuid) {},\n        getName: function(id) {},\n        setSize: function(id, newSize) {},\n        isQueued: function(id) {},\n        getIdsInProxyGroup: function(id) {},\n        getIdsInBatch: function(id) {},\n        isInProgress: function(id) {}\n    },\n\n    chunked = {\n        // Called when each chunk has uploaded successfully\n        done: function(id, chunkIdx, response, xhr) {\n            var chunkData = handler._getChunkData(id, chunkIdx);\n\n            handler._getFileState(id).attemptingResume = false;\n\n            delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n            handler._getFileState(id).loaded += chunkData.size;\n\n            options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n        },\n\n        // Called when all chunks have been successfully uploaded and we want to ask the handler to perform any\n        // logic associated with closing out the file, such as combining the chunks.\n        finalize: function(id) {\n            var size = options.getSize(id),\n                name = options.getName(id);\n\n            log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n            handler.finalizeChunks(id).then(\n                function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                },\n                function(response, xhr) {\n                    var normalizedResponse = upload.normalizeResponse(response, false);\n\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n\n                    if (\n                        normalizedResponse.reset ||\n                        (xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0)\n                    ) {\n                        chunked.reset(id);\n                    }\n\n                    if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n                        upload.cleanup(id, normalizedResponse, xhr);\n                    }\n                }\n            );\n        },\n\n        handleFailure: function(chunkIdx, id, response, xhr) {\n            var name = options.getName(id);\n\n            log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n\n            handler.clearCachedChunk(id, chunkIdx);\n\n            var responseToReport = upload.normalizeResponse(response, false),\n                inProgressIdx;\n\n            if (responseToReport.reset) {\n                chunked.reset(id);\n            }\n            else {\n                var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n\n                inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n                if (inProgressIdx >= 0) {\n                    handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                    handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                }\n            }\n\n            // We may have aborted all other in-progress chunks for this file due to a failure.\n            // If so, ignore the failures associated with those aborts.\n            if (!handler._getFileState(id).temp.ignoreFailure) {\n                // If this chunk has failed, we want to ignore all other failures of currently in-progress\n                // chunks since they will be explicitly aborted\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = true;\n\n                    log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                    qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                        log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                        ckXhr.abort();\n                        // Flag the transport, in case we are waiting for some other async operation\n                        // to complete before attempting to upload the chunk\n                        ckXhr._cancelled = true;\n                    });\n\n                    // We must indicate that all aborted chunks are no longer in progress\n                    handler.moveInProgressToRemaining(id);\n\n                    // Free up any connections used by these chunks, but don't allow any\n                    // other files to take up the connections (until we have exhausted all auto-retries)\n                    connectionManager.free(id, true);\n                }\n\n                if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                    // If one chunk fails, abort all of the others to avoid odd race conditions that occur\n                    // if a chunk succeeds immediately after one fails before we have determined if the upload\n                    // is a failure or not.\n                    upload.cleanup(id, responseToReport, xhr);\n                }\n            }\n        },\n\n        hasMoreParts: function(id) {\n            return !!handler._getFileState(id).chunking.remaining.length;\n        },\n\n        nextPart: function(id) {\n            var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n\n            if (nextIdx >= handler._getTotalChunks(id)) {\n                nextIdx = null;\n            }\n\n            return nextIdx;\n        },\n\n        reset: function(id) {\n            log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n\n            handler._maybeDeletePersistedChunkData(id);\n            handler.reevaluateChunking(id);\n            handler._getFileState(id).loaded = 0;\n            handler._getFileState(id).attemptingResume = false;\n        },\n\n        sendNext: function(id) {\n            var size = options.getSize(id),\n                name = options.getName(id),\n                chunkIdx = chunked.nextPart(id),\n                chunkData = handler._getChunkData(id, chunkIdx),\n                fileState = handler._getFileState(id),\n                resuming = fileState.attemptingResume,\n                inProgressChunks = fileState.chunking.inProgress || [];\n\n            if (fileState.loaded == null) {\n                fileState.loaded = 0;\n            }\n\n            // Don't follow-through with the resume attempt if the integrator returns false from onResume\n            if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n                chunked.reset(id);\n                chunkIdx = chunked.nextPart(id);\n                chunkData = handler._getChunkData(id, chunkIdx);\n                resuming = false;\n            }\n\n            // If all chunks have already uploaded successfully, we must be re-attempting the finalize step.\n            if (chunkIdx == null && inProgressChunks.length === 0) {\n                chunked.finalize(id);\n            }\n\n            // Send the next chunk\n            else {\n                inProgressChunks.push(chunkIdx);\n                handler._getFileState(id).chunking.inProgress = inProgressChunks;\n\n                if (concurrentChunkingPossible) {\n                    connectionManager.open(id, chunkIdx);\n                }\n\n                if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                    chunked.sendNext(id);\n                }\n\n                if (chunkData.blob.size === 0) {\n                    log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                    chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                }\n\n                var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n\n                onUploadChunkPromise.then(\n                    function(requestOverrides) {\n                        if (!options.isInProgress(id)) {\n                            log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n                        }\n                        else {\n                            log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n\n                            var uploadChunkData = {\n                                chunkIdx: chunkIdx,\n                                id: id,\n                                overrides: requestOverrides,\n                                resuming: resuming\n                            };\n\n                            handler.uploadChunk(uploadChunkData).then(\n                                // upload chunk success\n                                function success(response, xhr) {\n                                    log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n\n                                    handler.clearCachedChunk(id, chunkIdx);\n\n                                    var inProgressChunks = handler._getFileState(id).chunking.inProgress || [],\n                                        responseToReport = upload.normalizeResponse(response, true),\n                                        inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n\n                                    log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n\n                                    chunked.done(id, chunkIdx, responseToReport, xhr);\n\n                                    if (inProgressChunkIdx >= 0) {\n                                        inProgressChunks.splice(inProgressChunkIdx, 1);\n                                    }\n\n                                    handler._maybePersistChunkedState(id);\n\n                                    if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                        chunked.finalize(id);\n                                    }\n                                    else if (chunked.hasMoreParts(id)) {\n                                        chunked.sendNext(id);\n                                    }\n                                    else {\n                                        log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                                    }\n                                },\n\n                                // upload chunk failure\n                                function failure(response, xhr) {\n                                    chunked.handleFailure(chunkIdx, id, response, xhr);\n                                }\n                            )\n                                .done(function () {\n                                    handler.clearXhr(id, chunkIdx);\n                                });\n                        }\n                    },\n\n                    function(error) {\n                        chunked.handleFailure(chunkIdx, id, error, null);\n                    }\n                );\n            }\n        }\n    },\n\n    connectionManager = {\n        _open: [],\n        _openChunks: {},\n        _waiting: [],\n\n        available: function() {\n            var max = options.maxConnections,\n                openChunkEntriesCount = 0,\n                openChunksCount = 0;\n\n            qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                openChunkEntriesCount++;\n                openChunksCount += openChunkIndexes.length;\n            });\n\n            return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n        },\n\n        /**\n         * Removes element from queue, starts upload of next\n         */\n        free: function(id, dontAllowNext) {\n            var allowNext = !dontAllowNext,\n                waitingIndex = qq.indexOf(connectionManager._waiting, id),\n                connectionsIndex = qq.indexOf(connectionManager._open, id),\n                nextId;\n\n            delete connectionManager._openChunks[id];\n\n            if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                delete handler._getFileState(id).file;\n            }\n\n            // If this file was not consuming a connection, it was just waiting, so remove it from the waiting array\n            if (waitingIndex >= 0) {\n                connectionManager._waiting.splice(waitingIndex, 1);\n            }\n            // If this file was consuming a connection, allow the next file to be uploaded\n            else if (allowNext && connectionsIndex >= 0) {\n                connectionManager._open.splice(connectionsIndex, 1);\n\n                nextId = connectionManager._waiting.shift();\n                if (nextId >= 0) {\n                    connectionManager._open.push(nextId);\n                    upload.start(nextId);\n                }\n            }\n        },\n\n        getWaitingOrConnected: function() {\n            var waitingOrConnected = [];\n\n            // Chunked files may have multiple connections open per chunk (if concurrent chunking is enabled)\n            // We need to grab the file ID of any file that has at least one chunk consuming a connection.\n            qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                if (chunks && chunks.length) {\n                    waitingOrConnected.push(parseInt(fileId));\n                }\n            });\n\n            // For non-chunked files, only one connection will be consumed per file.\n            // This is where we aggregate those file IDs.\n            qq.each(connectionManager._open, function(idx, fileId) {\n                if (!connectionManager._openChunks[fileId]) {\n                    waitingOrConnected.push(parseInt(fileId));\n                }\n            });\n\n            // There may be files waiting for a connection.\n            waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n\n            return waitingOrConnected;\n        },\n\n        isUsingConnection: function(id) {\n            return qq.indexOf(connectionManager._open, id) >= 0;\n        },\n\n        open: function(id, chunkIdx) {\n            if (chunkIdx == null) {\n                connectionManager._waiting.push(id);\n            }\n\n            if (connectionManager.available()) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.pop();\n                    connectionManager._open.push(id);\n                }\n                else {\n                    (function() {\n                        var openChunksEntry = connectionManager._openChunks[id] || [];\n                        openChunksEntry.push(chunkIdx);\n                        connectionManager._openChunks[id] = openChunksEntry;\n                    }());\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n        reset: function() {\n            connectionManager._waiting = [];\n            connectionManager._open = [];\n        }\n    },\n\n    simple = {\n        send: function(id, name) {\n            var fileState = handler._getFileState(id);\n\n            if (!fileState) {\n                log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n                return;\n            }\n\n            fileState.loaded = 0;\n\n            log(\"Sending simple upload request for \" + id);\n            handler.uploadFile(id).then(\n                function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n\n                    var responseToReport = upload.normalizeResponse(response, true),\n                        size = options.getSize(id);\n\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                },\n\n                function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n\n                    var responseToReport = upload.normalizeResponse(response, false);\n\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                }\n            );\n        }\n    },\n\n    upload = {\n        cancel: function(id) {\n            log(\"Cancelling \" + id);\n            options.paramsStore.remove(id);\n            connectionManager.free(id);\n        },\n\n        cleanup: function(id, response, optXhr) {\n            var name = options.getName(id);\n\n            options.onComplete(id, name, response, optXhr);\n\n            if (handler._getFileState(id)) {\n                handler._clearXhrs && handler._clearXhrs(id);\n            }\n\n            connectionManager.free(id);\n        },\n\n        // Returns a qq.BlobProxy, or an actual File/Blob if no proxy is involved, or undefined\n        // if none of these are available for the ID\n        getProxyOrBlob: function(id) {\n            return (handler.getProxy && handler.getProxy(id)) ||\n                (handler.getFile && handler.getFile(id));\n        },\n\n        initHandler: function() {\n            var handlerType = namespace ? qq[namespace] : qq.traditional,\n                handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n\n            handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](\n                options,\n                {\n                    getCustomResumeData: options.getCustomResumeData,\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged,\n                    onFinalizing: function(id) {\n                        options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n                    }\n                }\n            );\n\n            if (handler._removeExpiredChunkingRecords) {\n                handler._removeExpiredChunkingRecords();\n            }\n        },\n\n        isDeferredEligibleForUpload: function(id) {\n            return options.isQueued(id);\n        },\n\n        // For Blobs that are part of a group of generated images, along with a reference image,\n        // this will ensure the blobs in the group are uploaded in the order they were triggered,\n        // even if some async processing must be completed on one or more Blobs first.\n        maybeDefer: function(id, blob) {\n            // If we don't have a file/blob yet & no file/blob exists for this item, request it,\n            // and then submit the upload to the specific handler once the blob is available.\n            // ASSUMPTION: This condition will only ever be true if XHR uploading is supported.\n            if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n\n                // Blob creation may take some time, so the caller may want to update the\n                // UI to indicate that an operation is in progress, even before the actual\n                // upload begins and an onUpload callback is invoked.\n                options.onUploadPrep(id);\n\n                log(\"Attempting to generate a blob on-demand for \" + id);\n                blob.create().then(function(generatedBlob) {\n                    log(\"Generated an on-demand blob for \" + id);\n\n                    // Update record associated with this file by providing the generated Blob\n                    handler.updateBlob(id, generatedBlob);\n\n                    // Propagate the size for this generated Blob\n                    options.setSize(id, generatedBlob.size);\n\n                    // Order handler to recalculate chunking possibility, if applicable\n                    handler.reevaluateChunking(id);\n\n                    upload.maybeSendDeferredFiles(id);\n                },\n\n                // Blob could not be generated.  Fail the upload & attempt to prevent retries.  Also bubble error message.\n                function(errorMessage) {\n                    var errorResponse = {};\n\n                    if (errorMessage) {\n                        errorResponse.error = errorMessage;\n                    }\n\n                    log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n\n                    options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                    upload.maybeSendDeferredFiles(id);\n                    connectionManager.free(id);\n                });\n            }\n            else {\n                return upload.maybeSendDeferredFiles(id);\n            }\n\n            return false;\n        },\n\n        // Upload any grouped blobs, in the proper order, that are ready to be uploaded\n        maybeSendDeferredFiles: function(id) {\n            var idsInGroup = options.getIdsInProxyGroup(id),\n                uploadedThisId = false;\n\n            if (idsInGroup && idsInGroup.length) {\n                log(\"Maybe ready to upload proxy group file \" + id);\n\n                qq.each(idsInGroup, function(idx, idInGroup) {\n                    if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                        uploadedThisId = idInGroup === id;\n                        upload.now(idInGroup);\n                    }\n                    else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                        return false;\n                    }\n                });\n            }\n            else {\n                uploadedThisId = true;\n                upload.now(id);\n            }\n\n            return uploadedThisId;\n        },\n\n        maybeNewUuid: function(id, response) {\n            if (response.newUuid !== undefined) {\n                options.onUuidChanged(id, response.newUuid);\n            }\n        },\n\n        // The response coming from handler implementations may be in various formats.\n        // Instead of hoping a promise nested 5 levels deep will always return an object\n        // as its first param, let's just normalize the response here.\n        normalizeResponse: function(originalResponse, successful) {\n            var response = originalResponse;\n\n            // The passed \"response\" param may not be a response at all.\n            // It could be a string, detailing the error, for example.\n            if (!qq.isObject(originalResponse)) {\n                response = {};\n\n                if (qq.isString(originalResponse) && !successful) {\n                    response.error = originalResponse;\n                }\n            }\n\n            response.success = successful;\n\n            return response;\n        },\n\n        now: function(id) {\n            var name = options.getName(id);\n\n            if (!controller.isValid(id)) {\n                throw new qq.Error(id + \" is not a valid file ID to upload!\");\n            }\n\n            options.onUpload(id, name).then(\n                function(response) {\n                    if (response && response.pause) {\n                        options.setStatus(id, qq.status.PAUSED);\n                        handler.pause(id);\n                        connectionManager.free(id);\n                    }\n                    else {\n                        if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                            chunked.sendNext(id);\n                        }\n                        else {\n                            simple.send(id, name);\n                        }\n                    }\n                },\n\n                function(error) {\n                    error = error || {};\n\n                    log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n\n                    if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n                        var response = upload.normalizeResponse(error.responseJSON, false);\n                        upload.cleanup(id, response);\n                    }\n                }\n            );\n        },\n\n        start: function(id) {\n            var blobToUpload = upload.getProxyOrBlob(id);\n\n            if (blobToUpload) {\n                return upload.maybeDefer(id, blobToUpload);\n            }\n            else {\n                upload.now(id);\n                return true;\n            }\n        }\n    };\n\n    qq.extend(this, {\n        /**\n         * Adds file or file input to the queue\n         **/\n        add: function(id, file) {\n            handler.add.apply(this, arguments);\n        },\n\n        /**\n         * Sends the file identified by id\n         */\n        upload: function(id) {\n            if (connectionManager.open(id)) {\n                return upload.start(id);\n            }\n            return false;\n        },\n\n        retry: function(id) {\n            // On retry, if concurrent chunking has been enabled, we may have aborted all other in-progress chunks\n            // for a file when encountering a failed chunk upload.  We then signaled the controller to ignore\n            // all failures associated with these aborts.  We are now retrying, so we don't want to ignore\n            // any more failures at this point.\n            if (concurrentChunkingPossible) {\n                handler._getFileState(id).temp.ignoreFailure = false;\n            }\n\n            // If we are attempting to retry a file that is already consuming a connection, this is likely an auto-retry.\n            // Just go ahead and ask the handler to upload again.\n            if (connectionManager.isUsingConnection(id)) {\n                return upload.start(id);\n            }\n\n            // If we are attempting to retry a file that is not currently consuming a connection,\n            // this is likely a manual retry attempt.  We will need to ensure a connection is available\n            // before the retry commences.\n            else {\n                return controller.upload(id);\n            }\n        },\n\n        /**\n         * Cancels file upload by id\n         */\n        cancel: function(id) {\n            var cancelRetVal = handler.cancel(id);\n\n            if (qq.isGenericPromise(cancelRetVal)) {\n                cancelRetVal.then(function() {\n                    upload.cancel(id);\n                });\n            }\n            else if (cancelRetVal !== false) {\n                upload.cancel(id);\n            }\n        },\n\n        /**\n         * Cancels all queued or in-progress uploads\n         */\n        cancelAll: function() {\n            var waitingOrConnected = connectionManager.getWaitingOrConnected(),\n                i;\n\n            // ensure files are cancelled in reverse order which they were added\n            // to avoid a flash of time where a queued file begins to upload before it is canceled\n            if (waitingOrConnected.length) {\n                for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                    controller.cancel(waitingOrConnected[i]);\n                }\n            }\n\n            connectionManager.reset();\n        },\n\n        // Returns a File, Blob, or the Blob/File for the reference/parent file if the targeted blob is a proxy.\n        // Undefined if no file record is available.\n        getFile: function(id) {\n            if (handler.getProxy && handler.getProxy(id)) {\n                return handler.getProxy(id).referenceBlob;\n            }\n\n            return handler.getFile && handler.getFile(id);\n        },\n\n        // Returns true if the Blob associated with the ID is related to a proxy s\n        isProxied: function(id) {\n            return !!(handler.getProxy && handler.getProxy(id));\n        },\n\n        getInput: function(id) {\n            if (handler.getInput) {\n                return handler.getInput(id);\n            }\n        },\n\n        reset: function() {\n            log(\"Resetting upload handler\");\n            controller.cancelAll();\n            connectionManager.reset();\n            handler.reset();\n        },\n\n        expunge: function(id) {\n            if (controller.isValid(id)) {\n                return handler.expunge(id);\n            }\n        },\n\n        /**\n         * Determine if the file exists.\n         */\n        isValid: function(id) {\n            return handler.isValid(id);\n        },\n\n        hasResumeRecord: function(id) {\n            var key = handler.isValid(id) &&\n                handler._getLocalStorageId &&\n                handler._getLocalStorageId(id);\n\n            if (key) {\n                return !!localStorage.getItem(key);\n            }\n\n            return false;\n        },\n\n        getResumableFilesData: function() {\n            if (handler.getResumableFilesData) {\n                return handler.getResumableFilesData();\n            }\n            return [];\n        },\n\n        /**\n         * This may or may not be implemented, depending on the handler.  For handlers where a third-party ID is\n         * available (such as the \"key\" for Amazon S3), this will return that value.  Otherwise, the return value\n         * will be undefined.\n         *\n         * @param id Internal file ID\n         * @returns {*} Some identifier used by a 3rd-party service involved in the upload process\n         */\n        getThirdPartyFileId: function(id) {\n            if (controller.isValid(id)) {\n                return handler.getThirdPartyFileId(id);\n            }\n        },\n\n        /**\n         * Attempts to pause the associated upload if the specific handler supports this and the file is \"valid\".\n         * @param id ID of the upload/file to pause\n         * @returns {boolean} true if the upload was paused\n         */\n        pause: function(id) {\n            if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                connectionManager.free(id);\n                handler.moveInProgressToRemaining(id);\n                return true;\n            }\n            return false;\n        },\n\n        isAttemptingResume: function(id) {\n            return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n        },\n\n        // True if the file is eligible for pause/resume.\n        isResumable: function(id) {\n            return !!handler.isResumable && handler.isResumable(id);\n        }\n    });\n\n    qq.extend(options, o);\n    log = options.log;\n    chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n    concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n\n    preventRetryResponse = (function() {\n        var response = {};\n\n        response[options.preventRetryParam] = true;\n\n        return response;\n    }());\n\n    upload.initHandler();\n};\n","/*globals qq */\n/*jshint -W117 */\nqq.WindowReceiveMessage = function(o) {\n    \"use strict\";\n\n    var options = {\n            log: function(message, level) {}\n        },\n        callbackWrapperDetachers = {};\n\n    qq.extend(options, o);\n\n    qq.extend(this, {\n        receiveMessage: function(id, callback) {\n            var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n\n            if (window.postMessage) {\n                callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n            }\n            else {\n                log(\"iframe message passing not supported in this browser!\", \"error\");\n            }\n        },\n\n        stopReceivingMessages: function(id) {\n            if (window.postMessage) {\n                var detacher = callbackWrapperDetachers[id];\n                if (detacher) {\n                    detacher();\n                }\n            }\n        }\n    });\n};\n","/* globals qq */\n/**\n * Common APIs exposed to creators of upload via form/iframe handlers.  This is reused and possibly overridden\n * in some cases by specific form upload handlers.\n *\n * @constructor\n */\nqq.FormUploadHandler = function(spec) {\n    \"use strict\";\n\n    var options = spec.options,\n        handler = this,\n        proxy = spec.proxy,\n        formHandlerInstanceId = qq.getUniqueId(),\n        onloadCallbacks = {},\n        detachLoadEvents = {},\n        postMessageCallbackTimers = {},\n        isCors = options.isCors,\n        inputName = options.inputName,\n        getUuid = proxy.getUuid,\n        log = proxy.log,\n        corsMessageReceiver = new qq.WindowReceiveMessage({log: log});\n\n    /**\n     * Remove any trace of the file from the handler.\n     *\n     * @param id ID of the associated file\n     */\n    function expungeFile(id) {\n        delete detachLoadEvents[id];\n\n        // If we are dealing with CORS, we might still be waiting for a response from a loaded iframe.\n        // In that case, terminate the timer waiting for a message from the loaded iframe\n        // and stop listening for any more messages coming from this iframe.\n        if (isCors) {\n            clearTimeout(postMessageCallbackTimers[id]);\n            delete postMessageCallbackTimers[id];\n            corsMessageReceiver.stopReceivingMessages(id);\n        }\n\n        var iframe = document.getElementById(handler._getIframeName(id));\n        if (iframe) {\n            // To cancel request set src to something else.  We use src=\"javascript:false;\"\n            // because it doesn't trigger ie6 prompt on https\n            /* jshint scripturl:true */\n            iframe.setAttribute(\"src\", \"javascript:false;\");\n\n            qq(iframe).remove();\n        }\n    }\n\n    /**\n     * @param iframeName `document`-unique Name of the associated iframe\n     * @returns {*} ID of the associated file\n     */\n    function getFileIdForIframeName(iframeName) {\n        return iframeName.split(\"_\")[0];\n    }\n\n    /**\n     * Generates an iframe to be used as a target for upload-related form submits.  This also adds the iframe\n     * to the current `document`.  Note that the iframe is hidden from view.\n     *\n     * @param name Name of the iframe.\n     * @returns {HTMLIFrameElement} The created iframe\n     */\n    function initIframeForUpload(name) {\n        var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n\n        iframe.setAttribute(\"id\", name);\n\n        iframe.style.display = \"none\";\n        document.body.appendChild(iframe);\n\n        return iframe;\n    }\n\n    /**\n     * If we are in CORS mode, we must listen for messages (containing the server response) from the associated\n     * iframe, since we cannot directly parse the content of the iframe due to cross-origin restrictions.\n     *\n     * @param iframe Listen for messages on this iframe.\n     * @param callback Invoke this callback with the message from the iframe.\n     */\n    function registerPostMessageCallback(iframe, callback) {\n        var iframeName = iframe.id,\n            fileId = getFileIdForIframeName(iframeName),\n            uuid = getUuid(fileId);\n\n        onloadCallbacks[uuid] = callback;\n\n        // When the iframe has loaded (after the server responds to an upload request)\n        // declare the attempt a failure if we don't receive a valid message shortly after the response comes in.\n        detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n            if (handler.getInput(fileId)) {\n                log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n\n                postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                    var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                    log(errorMessage, \"error\");\n                    callback({\n                        error: errorMessage\n                    });\n                }, 1000);\n            }\n        });\n\n        // Listen for messages coming from this iframe.  When a message has been received, cancel the timer\n        // that declares the upload a failure if a message is not received within a reasonable amount of time.\n        corsMessageReceiver.receiveMessage(iframeName, function(message) {\n            log(\"Received the following window message: '\" + message + \"'\");\n            var fileId = getFileIdForIframeName(iframeName),\n                response = handler._parseJsonResponse(message),\n                uuid = response.uuid,\n                onloadCallback;\n\n            if (uuid && onloadCallbacks[uuid]) {\n                log(\"Handling response for iframe name \" + iframeName);\n                clearTimeout(postMessageCallbackTimers[iframeName]);\n                delete postMessageCallbackTimers[iframeName];\n\n                handler._detachLoadEvent(iframeName);\n\n                onloadCallback = onloadCallbacks[uuid];\n\n                delete onloadCallbacks[uuid];\n                corsMessageReceiver.stopReceivingMessages(iframeName);\n                onloadCallback(response);\n            }\n            else if (!uuid) {\n                log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n            }\n        });\n    }\n\n    qq.extend(this, new qq.UploadHandler(spec));\n\n    qq.override(this, function(super_) {\n        return {\n            /**\n             * Adds File or Blob to the queue\n             **/\n            add: function(id, fileInput) {\n                super_.add(id, {input: fileInput});\n\n                fileInput.setAttribute(\"name\", inputName);\n\n                // remove file input from DOM\n                if (fileInput.parentNode) {\n                    qq(fileInput).remove();\n                }\n            },\n\n            expunge: function(id) {\n                expungeFile(id);\n                super_.expunge(id);\n            },\n\n            isValid: function(id) {\n                return super_.isValid(id) &&\n                    handler._getFileState(id).input !== undefined;\n            }\n        };\n    });\n\n    qq.extend(this, {\n        getInput: function(id) {\n            return handler._getFileState(id).input;\n        },\n\n        /**\n         * This function either delegates to a more specific message handler if CORS is involved,\n         * or simply registers a callback when the iframe has been loaded that invokes the passed callback\n         * after determining if the content of the iframe is accessible.\n         *\n         * @param iframe Associated iframe\n         * @param callback Callback to invoke after we have determined if the iframe content is accessible.\n         */\n        _attachLoadEvent: function(iframe, callback) {\n            /*jslint eqeq: true*/\n            var responseDescriptor;\n\n            if (isCors) {\n                registerPostMessageCallback(iframe, callback);\n            }\n            else {\n                detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                    log(\"Received response for \" + iframe.id);\n\n                    // when we remove iframe from dom\n                    // the request stops, but in IE load\n                    // event fires\n                    if (!iframe.parentNode) {\n                        return;\n                    }\n\n                    try {\n                        // fixing Opera 10.53\n                        if (iframe.contentDocument &&\n                            iframe.contentDocument.body &&\n                            iframe.contentDocument.body.innerHTML == \"false\") {\n                            // In Opera event is fired second time\n                            // when body.innerHTML changed from false\n                            // to server response approx. after 1 sec\n                            // when we upload file with iframe\n                            return;\n                        }\n                    }\n                    catch (error) {\n                        //IE may throw an \"access is denied\" error when attempting to access contentDocument on the iframe in some cases\n                        log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                        responseDescriptor = {success: false};\n                    }\n\n                    callback(responseDescriptor);\n                });\n            }\n        },\n\n        /**\n         * Creates an iframe with a specific document-unique name.\n         *\n         * @param id ID of the associated file\n         * @returns {HTMLIFrameElement}\n         */\n        _createIframe: function(id) {\n            var iframeName = handler._getIframeName(id);\n\n            return initIframeForUpload(iframeName);\n        },\n\n        /**\n         * Called when we are no longer interested in being notified when an iframe has loaded.\n         *\n         * @param id Associated file ID\n         */\n        _detachLoadEvent: function(id) {\n            if (detachLoadEvents[id] !== undefined) {\n                detachLoadEvents[id]();\n                delete detachLoadEvents[id];\n            }\n        },\n\n        /**\n         * @param fileId ID of the associated file\n         * @returns {string} The `document`-unique name of the iframe\n         */\n        _getIframeName: function(fileId) {\n            return fileId + \"_\" + formHandlerInstanceId;\n        },\n\n        /**\n         * Generates a form element and appends it to the `document`.  When the form is submitted, a specific iframe is targeted.\n         * The name of the iframe is passed in as a property of the spec parameter, and must be unique in the `document`.  Note\n         * that the form is hidden from view.\n         *\n         * @param spec An object containing various properties to be used when constructing the form.  Required properties are\n         * currently: `method`, `endpoint`, `params`, `paramsInBody`, and `targetName`.\n         * @returns {HTMLFormElement} The created form\n         */\n        _initFormForUpload: function(spec) {\n            var method = spec.method,\n                endpoint = spec.endpoint,\n                params = spec.params,\n                paramsInBody = spec.paramsInBody,\n                targetName = spec.targetName,\n                form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"),\n                url = endpoint;\n\n            if (paramsInBody) {\n                qq.obj2Inputs(params, form);\n            }\n            else {\n                url = qq.obj2url(params, endpoint);\n            }\n\n            form.setAttribute(\"action\", url);\n            form.setAttribute(\"target\", targetName);\n            form.style.display = \"none\";\n            document.body.appendChild(form);\n\n            return form;\n        },\n\n        /**\n         * @param innerHtmlOrMessage JSON message\n         * @returns {*} The parsed response, or an empty object if the response could not be parsed\n         */\n        _parseJsonResponse: function(innerHtmlOrMessage) {\n            var response = {};\n\n            try {\n                response = qq.parseJson(innerHtmlOrMessage);\n            }\n            catch (error) {\n                log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n            }\n\n            return response;\n        }\n    });\n};\n","/* globals qq */\n/**\n * Common API exposed to creators of XHR handlers.  This is reused and possibly overriding in some cases by specific\n * XHR upload handlers.\n *\n * @constructor\n */\nqq.XhrUploadHandler = function(spec) {\n    \"use strict\";\n\n    var handler = this,\n        namespace = spec.options.namespace,\n        proxy = spec.proxy,\n        chunking = spec.options.chunking,\n        getChunkSize = function(id) {\n            var fileState = handler._getFileState(id);\n\n            if (fileState.chunkSize) {\n                return fileState.chunkSize;\n            }\n\n            else {\n                var chunkSize = chunking.partSize;\n\n                if (qq.isFunction(chunkSize)) {\n                    chunkSize = chunkSize(id, getSize(id));\n                }\n\n                fileState.chunkSize = chunkSize;\n                return chunkSize;\n            }\n        },\n        resume = spec.options.resume,\n        chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking,\n        resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume,\n        getName = proxy.getName,\n        getSize = proxy.getSize,\n        getUuid = proxy.getUuid,\n        getEndpoint = proxy.getEndpoint,\n        getDataByUuid = proxy.getDataByUuid,\n        onUuidChanged = proxy.onUuidChanged,\n        onProgress = proxy.onProgress,\n        log = proxy.log,\n        getCustomResumeData = proxy.getCustomResumeData;\n\n    function abort(id) {\n        qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n            var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n\n            xhr.onreadystatechange = null;\n            xhr.upload.onprogress = null;\n            xhr.abort();\n            ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n        });\n    }\n\n    qq.extend(this, new qq.UploadHandler(spec));\n\n    qq.override(this, function(super_) {\n        return {\n            /**\n             * Adds File or Blob to the queue\n             **/\n            add: function(id, blobOrProxy) {\n                if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                    super_.add(id, {file: blobOrProxy});\n                }\n                else if (blobOrProxy instanceof qq.BlobProxy) {\n                    super_.add(id, {proxy: blobOrProxy});\n                }\n                else {\n                    throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                }\n\n                handler._initTempState(id);\n                resumeEnabled && handler._maybePrepareForResume(id);\n            },\n\n            expunge: function(id) {\n                abort(id);\n                handler._maybeDeletePersistedChunkData(id);\n                handler._clearXhrs(id);\n                super_.expunge(id);\n            }\n        };\n    });\n\n    qq.extend(this, {\n        // Clear the cached chunk `Blob` after we are done with it, just in case the `Blob` bytes are stored in memory.\n        clearCachedChunk: function(id, chunkIdx) {\n            var fileState = handler._getFileState(id);\n\n            if (fileState) {\n                delete fileState.temp.cachedChunks[chunkIdx];\n            }\n        },\n\n        clearXhr: function(id, chunkIdx) {\n            var tempState = handler._getFileState(id).temp;\n\n            if (tempState.xhrs) {\n                delete tempState.xhrs[chunkIdx];\n            }\n            if (tempState.ajaxRequesters) {\n                delete tempState.ajaxRequesters[chunkIdx];\n            }\n        },\n\n        // Called when all chunks have been successfully uploaded.  Expected promissory return type.\n        // This defines the default behavior if nothing further is required when all chunks have been uploaded.\n        finalizeChunks: function(id, responseParser) {\n            var lastChunkIdx = handler._getTotalChunks(id) - 1,\n                xhr = handler._getXhr(id, lastChunkIdx);\n\n            if (responseParser) {\n                return new qq.Promise().success(responseParser(xhr), xhr);\n            }\n\n            return new qq.Promise().success({}, xhr);\n        },\n\n        getFile: function(id) {\n            return handler.isValid(id) && handler._getFileState(id).file;\n        },\n\n        getProxy: function(id) {\n            return handler.isValid(id) && handler._getFileState(id).proxy;\n        },\n\n        /**\n         * @returns {Array} Array of objects containing properties useful to integrators\n         * when it is important to determine which files are potentially resumable.\n         */\n        getResumableFilesData: function() {\n            var resumableFilesData = [];\n\n            handler._iterateResumeRecords(function(key, uploadData) {\n                handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress,  uploadData.chunking.remaining);\n\n                var data = {\n                    name: uploadData.name,\n                    remaining: uploadData.chunking.remaining,\n                    size: uploadData.size,\n                    uuid: uploadData.uuid\n                };\n\n                if (uploadData.key) {\n                    data.key = uploadData.key;\n                }\n\n                if (uploadData.customResumeData) {\n                    data.customResumeData = uploadData.customResumeData;\n                }\n\n                resumableFilesData.push(data);\n            });\n\n            return resumableFilesData;\n        },\n\n        isAttemptingResume: function(id) {\n            return handler._getFileState(id).attemptingResume;\n        },\n\n        isResumable: function(id) {\n            return !!chunking && handler.isValid(id) &&\n                !handler._getFileState(id).notResumable;\n        },\n\n        moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n            var fileState = handler._getFileState(id) || {},\n                chunkingState =  fileState.chunking || {},\n                inProgress = optInProgress || chunkingState.inProgress,\n                remaining = optRemaining || chunkingState.remaining;\n\n            if (inProgress) {\n                log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                inProgress.reverse();\n                qq.each(inProgress, function(idx, chunkIdx) {\n                    remaining.unshift(chunkIdx);\n                });\n                inProgress.length = 0;\n            }\n        },\n\n        pause: function(id) {\n            if (handler.isValid(id)) {\n                log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                handler._getFileState(id).paused = true;\n                abort(id);\n                return true;\n            }\n        },\n\n        reevaluateChunking: function(id) {\n            if (chunking && handler.isValid(id)) {\n                var state = handler._getFileState(id),\n                    totalChunks,\n                    i;\n\n                delete state.chunking;\n\n                state.chunking = {};\n                totalChunks = handler._getTotalChunks(id);\n                if (totalChunks > 1 || chunking.mandatory) {\n                    state.chunking.enabled = true;\n                    state.chunking.parts = totalChunks;\n                    state.chunking.remaining = [];\n\n                    for (i = 0; i < totalChunks; i++) {\n                        state.chunking.remaining.push(i);\n                    }\n\n                    handler._initTempState(id);\n                }\n                else {\n                    state.chunking.enabled = false;\n                }\n            }\n        },\n\n        updateBlob: function(id, newBlob) {\n            if (handler.isValid(id)) {\n                handler._getFileState(id).file = newBlob;\n            }\n        },\n\n        _clearXhrs: function(id) {\n            var tempState = handler._getFileState(id).temp;\n\n            qq.each(tempState.ajaxRequesters, function(chunkId) {\n                delete tempState.ajaxRequesters[chunkId];\n            });\n\n            qq.each(tempState.xhrs, function(chunkId) {\n                delete tempState.xhrs[chunkId];\n            });\n        },\n\n        /**\n         * Creates an XHR instance for this file and stores it in the fileState.\n         *\n         * @param id File ID\n         * @param optChunkIdx The chunk index associated with this XHR, if applicable\n         * @returns {XMLHttpRequest}\n         */\n        _createXhr: function(id, optChunkIdx) {\n            return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n        },\n\n        _getAjaxRequester: function(id, optChunkIdx) {\n            var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n            return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n        },\n\n        _getChunkData: function(id, chunkIndex) {\n            var chunkSize = getChunkSize(id),\n                fileSize = getSize(id),\n                fileOrBlob = handler.getFile(id),\n                startBytes = chunkSize * chunkIndex,\n                endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize,\n                totalChunks = handler._getTotalChunks(id),\n                cachedChunks = this._getFileState(id).temp.cachedChunks,\n\n            // To work around a Webkit GC bug, we must keep each chunk `Blob` in scope until we are done with it.\n            // See https://github.com/FineUploader/fine-uploader/issues/937#issuecomment-41418760\n                blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n\n            cachedChunks[chunkIndex] = blob;\n\n            return {\n                part: chunkIndex,\n                start: startBytes,\n                end: endBytes,\n                count: totalChunks,\n                blob: blob,\n                size: endBytes - startBytes\n            };\n        },\n\n        _getChunkDataForCallback: function(chunkData) {\n            return {\n                partIndex: chunkData.part,\n                startByte: chunkData.start + 1,\n                endByte: chunkData.end,\n                totalParts: chunkData.count\n            };\n        },\n\n        /**\n         * @param id File ID\n         * @returns {string} Identifier for this item that may appear in the browser's local storage\n         */\n        _getLocalStorageId: function(id) {\n            var formatVersion = \"5.0\",\n                name = getName(id),\n                size = getSize(id),\n                chunkSize = getChunkSize(id),\n                endpoint = getEndpoint(id),\n                customKeys = resume.customKeys(id),\n                localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n\n            customKeys.forEach(function(key) {\n                localStorageId += \"-\" + key;\n            });\n\n            return localStorageId;\n        },\n\n        _getMimeType: function(id) {\n            return handler.getFile(id).type;\n        },\n\n        _getPersistableData: function(id) {\n            return handler._getFileState(id).chunking;\n        },\n\n        /**\n         * @param id ID of the associated file\n         * @returns {number} Number of parts this file can be divided into, or undefined if chunking is not supported in this UA\n         */\n        _getTotalChunks: function(id) {\n            if (chunking) {\n                var fileSize = getSize(id),\n                    chunkSize = getChunkSize(id);\n\n                return Math.ceil(fileSize / chunkSize);\n            }\n        },\n\n        _getXhr: function(id, optChunkIdx) {\n            var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n            return handler._getFileState(id).temp.xhrs[chunkIdx];\n        },\n\n        _getXhrs: function(id) {\n            return handler._getFileState(id).temp.xhrs;\n        },\n\n        // Iterates through all XHR handler-created resume records (in local storage),\n        // invoking the passed callback and passing in the key and value of each local storage record.\n        _iterateResumeRecords: function(callback) {\n            if (resumeEnabled) {\n                qq.each(localStorage, function(key, item) {\n                    if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                        var uploadData = JSON.parse(item);\n                        callback(key, uploadData);\n                    }\n                });\n            }\n        },\n\n        _initTempState: function(id) {\n            handler._getFileState(id).temp = {\n                ajaxRequesters: {},\n                chunkProgress: {},\n                xhrs: {},\n                cachedChunks: {}\n            };\n        },\n\n        _markNotResumable: function(id) {\n            handler._getFileState(id).notResumable = true;\n        },\n\n        // Removes a chunked upload record from local storage, if possible.\n        // Returns true if the item was removed, false otherwise.\n        _maybeDeletePersistedChunkData: function(id) {\n            var localStorageId;\n\n            if (resumeEnabled && handler.isResumable(id)) {\n                localStorageId = handler._getLocalStorageId(id);\n\n                if (localStorageId && localStorage.getItem(localStorageId)) {\n                    localStorage.removeItem(localStorageId);\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        // If this is a resumable upload, grab the relevant data from storage and items in memory that track this upload\n        // so we can pick up from where we left off.\n        _maybePrepareForResume: function(id) {\n            var state = handler._getFileState(id),\n                localStorageId, persistedData;\n\n            // Resume is enabled and possible and this is the first time we've tried to upload this file in this session,\n            // so prepare for a resume attempt.\n            if (resumeEnabled && state.key === undefined) {\n                localStorageId = handler._getLocalStorageId(id);\n                persistedData = localStorage.getItem(localStorageId);\n\n                // If we found this item in local storage, maybe we should resume it.\n                if (persistedData) {\n                    persistedData = JSON.parse(persistedData);\n\n                    // If we found a resume record but we have already handled this file in this session,\n                    // don't try to resume it & ensure we don't persist future check data\n                    if (getDataByUuid(persistedData.uuid)) {\n                        handler._markNotResumable(id);\n                    }\n                    else {\n                        log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n\n                        onUuidChanged(id, persistedData.uuid);\n\n                        state.key = persistedData.key;\n                        state.chunking = persistedData.chunking;\n                        state.loaded = persistedData.loaded;\n                        state.customResumeData = persistedData.customResumeData;\n                        state.attemptingResume = true;\n\n                        handler.moveInProgressToRemaining(id);\n                    }\n                }\n            }\n        },\n\n        // Persist any data needed to resume this upload in a new session.\n        _maybePersistChunkedState: function(id) {\n            var state = handler._getFileState(id),\n                localStorageId, persistedData;\n\n            // If local storage isn't supported by the browser, or if resume isn't enabled or possible, give up\n            if (resumeEnabled && handler.isResumable(id)) {\n                var customResumeData = getCustomResumeData(id);\n\n                localStorageId = handler._getLocalStorageId(id);\n\n                persistedData = {\n                    name: getName(id),\n                    size: getSize(id),\n                    uuid: getUuid(id),\n                    key: state.key,\n                    chunking: state.chunking,\n                    loaded: state.loaded,\n                    lastUpdated: Date.now(),\n                };\n\n                if (customResumeData) {\n                    persistedData.customResumeData = customResumeData;\n                }\n\n                try {\n                    localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                }\n                catch (error) {\n                    log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                }\n            }\n        },\n\n        _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n            var xhr = handler._getXhr(id, chunkIdx),\n                name = getName(id),\n                progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        }\n                        else {\n                            onProgress(id, name, (loaded >= fileSize ? fileSize - 1 : loaded), fileSize);\n                        }\n                    },\n\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress,\n                            totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded,\n                            loadedForRequest = loaded,\n                            totalForRequest = total,\n                            totalFileSize = getSize(id),\n                            estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize),\n                            totalLoadedForFile = totalSuccessfullyLoadedForFile;\n\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n\n            xhr.upload.onprogress = function(e) {\n                if (e.lengthComputable) {\n                    /* jshint eqnull: true */\n                    var type = chunkSize == null ? \"simple\" : \"chunked\";\n                    progressCalculator[type](e.loaded, e.total);\n                }\n            };\n        },\n\n        /**\n         * Registers an XHR transport instance created elsewhere.\n         *\n         * @param id ID of the associated file\n         * @param optChunkIdx The chunk index associated with this XHR, if applicable\n         * @param xhr XMLHttpRequest object instance\n         * @param optAjaxRequester `qq.AjaxRequester` associated with this request, if applicable.\n         * @returns {XMLHttpRequest}\n         */\n        _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n            var xhrsId = optChunkIdx == null ? -1 : optChunkIdx,\n                tempState = handler._getFileState(id).temp;\n\n            tempState.xhrs = tempState.xhrs || {};\n            tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n\n            tempState.xhrs[xhrsId] = xhr;\n\n            if (optAjaxRequester) {\n                tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n            }\n\n            return xhr;\n        },\n\n        // Deletes any local storage records that are \"expired\".\n        _removeExpiredChunkingRecords: function() {\n            var expirationDays = resume.recordsExpireIn;\n\n            handler._iterateResumeRecords(function(key, uploadData) {\n                var expirationDate = new Date(uploadData.lastUpdated);\n\n                // transform updated date into expiration date\n                expirationDate.setDate(expirationDate.getDate() + expirationDays);\n\n                if (expirationDate.getTime() <= Date.now()) {\n                    log(\"Removing expired resume record with key \" + key);\n                    localStorage.removeItem(key);\n                }\n            });\n        },\n\n        /**\n         * Determine if the associated file should be chunked.\n         *\n         * @param id ID of the associated file\n         * @returns {*} true if chunking is enabled, possible, and the file can be split into more than 1 part\n         */\n        _shouldChunkThisFile: function(id) {\n            var state = handler._getFileState(id);\n\n            // file may no longer be available if it was recently cancelled\n            if (state) {\n                if (!state.chunking) {\n                    handler.reevaluateChunking(id);\n                }\n\n                return state.chunking.enabled;\n            }\n        }\n    });\n};\n","/*globals qq, XMLHttpRequest*/\nqq.DeleteFileAjaxRequester = function(o) {\n    \"use strict\";\n\n    var requester,\n        options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {return {};},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n\n    qq.extend(options, o);\n\n    function getMandatedParams() {\n        if (options.method.toUpperCase() === \"POST\") {\n            return {\n                _method: \"DELETE\"\n            };\n        }\n\n        return {};\n    }\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n        acceptHeader: \"application/json\",\n        validMethods: [\"POST\", \"DELETE\"],\n        method: options.method,\n        endpointStore: options.endpointStore,\n        paramsStore: options.paramsStore,\n        mandatedParams: getMandatedParams(),\n        maxConnections: options.maxConnections,\n        customHeaders: function(id) {\n            return options.customHeaders.get(id);\n        },\n        log: options.log,\n        onSend: options.onDelete,\n        onComplete: options.onDeleteComplete,\n        cors: options.cors\n    }));\n\n    qq.extend(this, {\n        sendDelete: function(id, uuid, additionalMandatedParams) {\n            var additionalOptions = additionalMandatedParams || {};\n\n            options.log(\"Submitting delete file request for \" + id);\n\n            if (options.method === \"DELETE\") {\n                requester.initTransport(id)\n                    .withPath(uuid)\n                    .withParams(additionalOptions)\n                    .send();\n            }\n            else {\n                additionalOptions[options.uuidParamName] = uuid;\n                requester.initTransport(id)\n                    .withParams(additionalOptions)\n                    .send();\n            }\n        }\n    });\n};\n","/*global qq, define */\n/*jshint strict:false,bitwise:false,nonew:false,asi:true,-W064,-W116,-W089 */\n/**\n * Mega pixel image rendering library for iOS6+\n *\n * Fixes iOS6+'s image file rendering issue for large size image (over mega-pixel),\n * which causes unexpected subsampling when drawing it in canvas.\n * By using this library, you can safely render the image with proper stretching.\n *\n * Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>\n * Released under the MIT license\n *\n * Heavily modified by Widen for Fine Uploader\n */\n(function() {\n\n    /**\n     * Detect subsampling in loaded image.\n     * In iOS, larger images than 2M pixels may be subsampled in rendering.\n     */\n    function detectSubsampling(img) {\n        var iw = img.naturalWidth,\n            ih = img.naturalHeight,\n            canvas = document.createElement(\"canvas\"),\n            ctx;\n\n        if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image\n            canvas.width = canvas.height = 1;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, -iw + 1, 0);\n            // subsampled image becomes half smaller in rendering size.\n            // check alpha channel value to confirm image is covering edge pixel or not.\n            // if alpha value is 0 image is not covering, hence subsampled.\n            return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Detecting vertical squash in loaded image.\n     * Fixes a bug which squash image vertically while drawing into canvas for some images.\n     */\n    function detectVerticalSquash(img, iw, ih) {\n        var canvas = document.createElement(\"canvas\"),\n            sy = 0,\n            ey = ih,\n            py = ih,\n            ctx, data, alpha, ratio;\n\n        canvas.width = 1;\n        canvas.height = ih;\n        ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0);\n        data = ctx.getImageData(0, 0, 1, ih).data;\n\n        // search image edge pixel position in case it is squashed vertically.\n        while (py > sy) {\n            alpha = data[(py - 1) * 4 + 3];\n            if (alpha === 0) {\n                ey = py;\n            } else {\n                sy = py;\n            }\n            py = (ey + sy) >> 1;\n        }\n\n        ratio = (py / ih);\n        return (ratio === 0) ? 1 : ratio;\n    }\n\n    /**\n     * Rendering image element (with resizing) and get its data URL\n     */\n    function renderImageToDataURL(img, blob, options, doSquash) {\n        var canvas = document.createElement(\"canvas\"),\n            mime = options.mime || \"image/jpeg\",\n            promise = new qq.Promise();\n\n        renderImageToCanvas(img, blob, canvas, options, doSquash)\n            .then(function() {\n                promise.success(\n                    canvas.toDataURL(mime, options.quality || 0.8)\n                );\n            });\n\n        return promise;\n    }\n\n    function maybeCalculateDownsampledDimensions(spec) {\n        var maxPixels = 5241000; //iOS specific value\n\n        if (!qq.ios()) {\n            throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n        }\n\n        if (spec.origHeight * spec.origWidth > maxPixels) {\n            return {\n                newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n            };\n        }\n    }\n\n    /**\n     * Rendering image element (with resizing) into the canvas element\n     */\n    function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n        var iw = img.naturalWidth,\n            ih = img.naturalHeight,\n            width = options.width,\n            height = options.height,\n            ctx = canvas.getContext(\"2d\"),\n            promise = new qq.Promise(),\n            modifiedDimensions;\n\n        ctx.save();\n\n        if (options.resize) {\n            return renderImageToCanvasWithCustomResizer({\n                blob: blob,\n                canvas: canvas,\n                image: img,\n                imageHeight: ih,\n                imageWidth: iw,\n                orientation: options.orientation,\n                resize: options.resize,\n                targetHeight: height,\n                targetWidth: width\n            });\n        }\n\n        if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n            modifiedDimensions = maybeCalculateDownsampledDimensions({\n                origWidth: width,\n                origHeight: height\n            });\n\n            if (modifiedDimensions) {\n                qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\",\n                    width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight),\n                    \"warn\");\n\n                width = modifiedDimensions.newWidth;\n                height = modifiedDimensions.newHeight;\n            }\n        }\n\n        transformCoordinate(canvas, width, height, options.orientation);\n\n        // Fine Uploader specific: Save some CPU cycles if not using iOS\n        // Assumption: This logic is only needed to overcome iOS image sampling issues\n        if (qq.ios()) {\n            (function() {\n                if (detectSubsampling(img)) {\n                    iw /= 2;\n                    ih /= 2;\n                }\n\n                var d = 1024, // size of tiling canvas\n                    tmpCanvas = document.createElement(\"canvas\"),\n                    vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1,\n                    dw = Math.ceil(d * width / iw),\n                    dh = Math.ceil(d * height / ih / vertSquashRatio),\n                    sy = 0,\n                    dy = 0,\n                    tmpCtx, sx, dx;\n\n                tmpCanvas.width = tmpCanvas.height = d;\n                tmpCtx = tmpCanvas.getContext(\"2d\");\n\n                while (sy < ih) {\n                    sx = 0;\n                    dx = 0;\n                    while (sx < iw) {\n                        tmpCtx.clearRect(0, 0, d, d);\n                        tmpCtx.drawImage(img, -sx, -sy);\n                        ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                        sx += d;\n                        dx += dw;\n                    }\n                    sy += d;\n                    dy += dh;\n                }\n                ctx.restore();\n                tmpCanvas = tmpCtx = null;\n            }());\n        }\n        else {\n            ctx.drawImage(img, 0, 0, width, height);\n        }\n\n        canvas.qqImageRendered && canvas.qqImageRendered();\n        promise.success();\n\n        return promise;\n    }\n\n    function renderImageToCanvasWithCustomResizer(resizeInfo) {\n        var blob = resizeInfo.blob,\n            image = resizeInfo.image,\n            imageHeight = resizeInfo.imageHeight,\n            imageWidth = resizeInfo.imageWidth,\n            orientation = resizeInfo.orientation,\n            promise = new qq.Promise(),\n            resize = resizeInfo.resize,\n            sourceCanvas = document.createElement(\"canvas\"),\n            sourceCanvasContext = sourceCanvas.getContext(\"2d\"),\n            targetCanvas = resizeInfo.canvas,\n            targetHeight = resizeInfo.targetHeight,\n            targetWidth = resizeInfo.targetWidth;\n\n        transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n\n        targetCanvas.height = targetHeight;\n        targetCanvas.width = targetWidth;\n\n        sourceCanvasContext.drawImage(image, 0, 0);\n\n        resize({\n            blob: blob,\n            height: targetHeight,\n            image: image,\n            sourceCanvas: sourceCanvas,\n            targetCanvas: targetCanvas,\n            width: targetWidth\n        })\n            .then(\n                function success() {\n                    targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                    promise.success();\n                },\n                promise.failure\n            );\n\n        return promise;\n    }\n\n    /**\n     * Transform canvas coordination according to specified frame size and orientation\n     * Orientation value is from EXIF tag\n     */\n    function transformCoordinate(canvas, width, height, orientation) {\n        switch (orientation) {\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n            default:\n                canvas.width = width;\n                canvas.height = height;\n        }\n        var ctx = canvas.getContext(\"2d\");\n        switch (orientation) {\n            case 2:\n                // horizontal flip\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n            case 3:\n                // 180 rotate left\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n            case 4:\n                // vertical flip\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n            case 5:\n                // vertical flip + 90 rotate right\n                ctx.rotate(0.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n            case 6:\n                // 90 rotate right\n                ctx.rotate(0.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n            case 7:\n                // horizontal flip + 90 rotate right\n                ctx.rotate(0.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n            case 8:\n                // 90 rotate left\n                ctx.rotate(-0.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * MegaPixImage class\n     */\n    function MegaPixImage(srcImage, errorCallback) {\n        var self = this;\n\n        if (window.Blob && srcImage instanceof Blob) {\n            (function() {\n                var img = new Image(),\n                    URL = window.URL && window.URL.createObjectURL ? window.URL :\n                        window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (!URL) { throw Error(\"No createObjectURL function found to create blob url\"); }\n                img.src = URL.createObjectURL(srcImage);\n                self.blob = srcImage;\n                srcImage = img;\n            }());\n        }\n        if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n            srcImage.onload = function() {\n                var listeners = self.imageLoadListeners;\n                if (listeners) {\n                    self.imageLoadListeners = null;\n                    // IE11 doesn't reliably report actual image dimensions immediately after onload for small files,\n                    // so let's push this to the end of the UI thread queue.\n                    setTimeout(function() {\n                        for (var i = 0, len = listeners.length; i < len; i++) {\n                            listeners[i]();\n                        }\n                    }, 0);\n                }\n            };\n            srcImage.onerror = errorCallback;\n            this.imageLoadListeners = [];\n        }\n        this.srcImage = srcImage;\n    }\n\n    /**\n     * Rendering megapix image into specified target element\n     */\n    MegaPixImage.prototype.render = function(target, options) {\n        options = options || {};\n\n        var self = this,\n            imgWidth = this.srcImage.naturalWidth,\n            imgHeight = this.srcImage.naturalHeight,\n            width = options.width,\n            height = options.height,\n            maxWidth = options.maxWidth,\n            maxHeight = options.maxHeight,\n            doSquash = !this.blob || this.blob.type === \"image/jpeg\",\n            tagName = target.tagName.toLowerCase(),\n            opt;\n\n        if (this.imageLoadListeners) {\n            this.imageLoadListeners.push(function() { self.render(target, options); });\n            return;\n        }\n\n        if (width && !height) {\n            height = (imgHeight * width / imgWidth) << 0;\n        } else if (height && !width) {\n            width = (imgWidth * height / imgHeight) << 0;\n        } else {\n            width = imgWidth;\n            height = imgHeight;\n        }\n        if (maxWidth && width > maxWidth) {\n            width = maxWidth;\n            height = (imgHeight * width / imgWidth) << 0;\n        }\n        if (maxHeight && height > maxHeight) {\n            height = maxHeight;\n            width = (imgWidth * height / imgHeight) << 0;\n        }\n\n        opt = { width: width, height: height },\n        qq.each(options, function(optionsKey, optionsValue) {\n            opt[optionsKey] = optionsValue;\n        });\n\n        if (tagName === \"img\") {\n            (function() {\n                var oldTargetSrc = target.src;\n                renderImageToDataURL(self.srcImage, self.blob, opt, doSquash)\n                    .then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n            }());\n        } else if (tagName === \"canvas\") {\n            renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n        }\n        if (typeof this.onrender === \"function\") {\n            this.onrender(target);\n        }\n    };\n\n    qq.MegaPixImage = MegaPixImage;\n})();\n","/*globals qq */\n/**\n * Draws a thumbnail of a Blob/File/URL onto an <img> or <canvas>.\n *\n * @constructor\n */\nqq.ImageGenerator = function(log) {\n    \"use strict\";\n\n    function isImg(el) {\n        return el.tagName.toLowerCase() === \"img\";\n    }\n\n    function isCanvas(el) {\n        return el.tagName.toLowerCase() === \"canvas\";\n    }\n\n    function isImgCorsSupported() {\n        return new Image().crossOrigin !== undefined;\n    }\n\n    function isCanvasSupported() {\n        var canvas = document.createElement(\"canvas\");\n\n        return canvas.getContext && canvas.getContext(\"2d\");\n    }\n\n    // This is only meant to determine the MIME type of a renderable image file.\n    // It is used to ensure images drawn from a URL that have transparent backgrounds\n    // are rendered correctly, among other things.\n    function determineMimeOfFileName(nameWithPath) {\n        /*jshint -W015 */\n        var pathSegments = nameWithPath.split(\"/\"),\n            name = pathSegments[pathSegments.length - 1].split(\"?\")[0],\n            extension = qq.getExtension(name);\n\n        extension = extension && extension.toLowerCase();\n\n        switch (extension) {\n            case \"jpeg\":\n            case \"jpg\":\n                return \"image/jpeg\";\n            case \"png\":\n                return \"image/png\";\n            case \"bmp\":\n                return \"image/bmp\";\n            case \"gif\":\n                return \"image/gif\";\n            case \"tiff\":\n            case \"tif\":\n                return \"image/tiff\";\n        }\n    }\n\n    // This will likely not work correctly in IE8 and older.\n    // It's only used as part of a formula to determine\n    // if a canvas can be used to scale a server-hosted thumbnail.\n    // If canvas isn't supported by the UA (IE8 and older)\n    // this method should not even be called.\n    function isCrossOrigin(url) {\n        var targetAnchor = document.createElement(\"a\"),\n            targetProtocol, targetHostname, targetPort;\n\n        targetAnchor.href = url;\n\n        targetProtocol = targetAnchor.protocol;\n        targetPort = targetAnchor.port;\n        targetHostname = targetAnchor.hostname;\n\n        if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n            return true;\n        }\n\n        if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n            return true;\n        }\n\n        // IE doesn't take ports into consideration when determining if two endpoints are same origin.\n        if (targetPort !== window.location.port && !qq.ie()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function registerImgLoadListeners(img, promise) {\n        img.onload = function() {\n            img.onload = null;\n            img.onerror = null;\n            promise.success(img);\n        };\n\n        img.onerror = function() {\n            img.onload = null;\n            img.onerror = null;\n            log(\"Problem drawing thumbnail!\", \"error\");\n            promise.failure(img, \"Problem drawing thumbnail!\");\n        };\n    }\n\n    function registerCanvasDrawImageListener(canvas, promise) {\n        // The image is drawn on the canvas by a third-party library,\n        // and we want to know when this is completed.  Since the library\n        // may invoke drawImage many times in a loop, we need to be called\n        // back when the image is fully rendered.  So, we are expecting the\n        // code that draws this image to follow a convention that involves a\n        // function attached to the canvas instance be invoked when it is done.\n        canvas.qqImageRendered = function() {\n            promise.success(canvas);\n        };\n    }\n\n    // Fulfills a `qq.Promise` when an image has been drawn onto the target,\n    // whether that is a <canvas> or an <img>.  The attempt is considered a\n    // failure if the target is not an <img> or a <canvas>, or if the drawing\n    // attempt was not successful.\n    function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n        var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n\n        if (isImg(imgOrCanvas)) {\n            registerImgLoadListeners(imgOrCanvas, promise);\n        }\n        else if (isCanvas(imgOrCanvas)) {\n            registerCanvasDrawImageListener(imgOrCanvas, promise);\n        }\n        else {\n            promise.failure(imgOrCanvas);\n            log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n        }\n\n        return registered;\n    }\n\n    // Draw a preview iff the current UA can natively display it.\n    // Also rotate the image if necessary.\n    function draw(fileOrBlob, container, options) {\n        var drawPreview = new qq.Promise(),\n            identifier = new qq.Identify(fileOrBlob, log),\n            maxSize = options.maxSize,\n            // jshint eqnull:true\n            orient = options.orient == null ? true : options.orient,\n            megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n\n        identifier.isPreviewable().then(\n            function(mime) {\n                // If options explicitly specify that Orientation is not desired,\n                // replace the orient task with a dummy promise that \"succeeds\" immediately.\n                var dummyExif = {\n                        parse: function() {\n                            return new qq.Promise().success();\n                        }\n                    },\n                    exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif,\n                    mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(\n                        function(exif) {\n                            var orientation = exif && exif.Orientation;\n\n                            mpImg.render(container, {\n                                maxWidth: maxSize,\n                                maxHeight: maxSize,\n                                orientation: orientation,\n                                mime: mime,\n                                resize: options.customResizeFunction\n                            });\n                        },\n\n                        function(failureMsg) {\n                            log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n\n                            mpImg.render(container, {\n                                maxWidth: maxSize,\n                                maxHeight: maxSize,\n                                mime: mime,\n                                resize: options.customResizeFunction\n                            });\n                        }\n                    );\n                }\n            },\n\n            function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            }\n        );\n\n        return drawPreview;\n    }\n\n    function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n        var tempImg = new Image(),\n            tempImgRender = new qq.Promise();\n\n        registerThumbnailRenderedListener(tempImg, tempImgRender);\n\n        if (isCrossOrigin(url)) {\n            tempImg.crossOrigin = \"anonymous\";\n        }\n\n        tempImg.src = url;\n\n        tempImgRender.then(\n            function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            },\n\n            draw.failure\n        );\n    }\n\n    function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n        registerThumbnailRenderedListener(img, draw);\n        // NOTE: The fact that maxWidth/height is set on the thumbnail for scaled images\n        // that must drop back to CSS is known and exploited by the templating module.\n        // In this module, we pre-render \"waiting\" thumbs for all files immediately after they\n        // are submitted, and we must be sure to pass any style associated with the \"waiting\" preview.\n        qq(img).css({\n            maxWidth: maxSize + \"px\",\n            maxHeight: maxSize + \"px\"\n        });\n\n        img.src = url;\n    }\n\n    // Draw a (server-hosted) thumbnail given a URL.\n    // This will optionally scale the thumbnail as well.\n    // It attempts to use <canvas> to scale, but will fall back\n    // to max-width and max-height style properties if the UA\n    // doesn't support canvas or if the images is cross-domain and\n    // the UA doesn't support the crossorigin attribute on img tags,\n    // which is required to scale a cross-origin image using <canvas> &\n    // then export it back to an <img>.\n    function drawFromUrl(url, container, options) {\n        var draw = new qq.Promise(),\n            scale = options.scale,\n            maxSize = scale ? options.maxSize : null;\n\n        // container is an img, scaling needed\n        if (scale && isImg(container)) {\n            // Iff canvas is available in this UA, try to use it for scaling.\n            // Otherwise, fall back to CSS scaling\n            if (isCanvasSupported()) {\n                // Attempt to use <canvas> for image scaling,\n                // but we must fall back to scaling via CSS/styles\n                // if this is a cross-origin image and the UA doesn't support <img> CORS.\n                if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n                else {\n                    drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                }\n            }\n            else {\n                drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n            }\n        }\n        // container is a canvas, scaling optional\n        else if (isCanvas(container)) {\n            drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n        }\n        // container is an img & no scaling: just set the src attr to the passed url\n        else if (registerThumbnailRenderedListener(container, draw)) {\n            container.src = url;\n        }\n\n        return draw;\n    }\n\n    qq.extend(this, {\n        /**\n         * Generate a thumbnail.  Depending on the arguments, this may either result in\n         * a client-side rendering of an image (if a `Blob` is supplied) or a server-generated\n         * image that may optionally be scaled client-side using <canvas> or CSS/styles (as a fallback).\n         *\n         * @param fileBlobOrUrl a `File`, `Blob`, or a URL pointing to the image\n         * @param container <img> or <canvas> to contain the preview\n         * @param options possible properties include `maxSize` (int), `orient` (bool - default true), resize` (bool - default true), and `customResizeFunction`.\n         * @returns qq.Promise fulfilled when the preview has been drawn, or the attempt has failed\n         */\n        generate: function(fileBlobOrUrl, container, options) {\n            if (qq.isString(fileBlobOrUrl)) {\n                log(\"Attempting to update thumbnail based on server response.\");\n                return drawFromUrl(fileBlobOrUrl, container, options || {});\n            }\n            else {\n                log(\"Attempting to draw client-side image preview.\");\n                return draw(fileBlobOrUrl, container, options || {});\n            }\n        }\n    });\n\n    /*<testing>*/\n    this._testing = {};\n    this._testing.isImg = isImg;\n    this._testing.isCanvas = isCanvas;\n    this._testing.isCrossOrigin = isCrossOrigin;\n    this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    /*</testing>*/\n};\n","/*globals qq */\n/**\n * EXIF image data parser.  Currently only parses the Orientation tag value,\n * but this may be expanded to other tags in the future.\n *\n * @param fileOrBlob Attempt to parse EXIF data in this `Blob`\n * @constructor\n */\nqq.Exif = function(fileOrBlob, log) {\n    \"use strict\";\n\n    // Orientation is the only tag parsed here at this time.\n    var TAG_IDS = [274],\n        TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n\n    // Convert a little endian (hex string) to big endian (decimal).\n    function parseLittleEndian(hex) {\n        var result = 0,\n            pow = 0;\n\n        while (hex.length > 0) {\n            result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n            hex = hex.substring(2, hex.length);\n            pow += 8;\n        }\n\n        return result;\n    }\n\n    // Find the byte offset, of Application Segment 1 (EXIF).\n    // External callers need not supply any arguments.\n    function seekToApp1(offset, promise) {\n        var theOffset = offset,\n            thePromise = promise;\n        if (theOffset === undefined) {\n            theOffset = 2;\n            thePromise = new qq.Promise();\n        }\n\n        qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n            var match = /^ffe([0-9])/.exec(hex),\n                segmentLength;\n\n            if (match) {\n                if (match[1] !== \"1\") {\n                    segmentLength = parseInt(hex.slice(4, 8), 16);\n                    seekToApp1(theOffset + segmentLength + 2, thePromise);\n                }\n                else {\n                    thePromise.success(theOffset);\n                }\n            }\n            else {\n                thePromise.failure(\"No EXIF header to be found!\");\n            }\n        });\n\n        return thePromise;\n    }\n\n    // Find the byte offset of Application Segment 1 (EXIF) for valid JPEGs only.\n    function getApp1Offset() {\n        var promise = new qq.Promise();\n\n        qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n            if (hex.indexOf(\"ffd8\") !== 0) {\n                promise.failure(\"Not a valid JPEG!\");\n            }\n            else {\n                seekToApp1().then(function(offset) {\n                    promise.success(offset);\n                },\n                function(error) {\n                    promise.failure(error);\n                });\n            }\n        });\n\n        return promise;\n    }\n\n    // Determine the byte ordering of the EXIF header.\n    function isLittleEndian(app1Start) {\n        var promise = new qq.Promise();\n\n        qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n            promise.success(hex === \"4949\");\n        });\n\n        return promise;\n    }\n\n    // Determine the number of directory entries in the EXIF header.\n    function getDirEntryCount(app1Start, littleEndian) {\n        var promise = new qq.Promise();\n\n        qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n            if (littleEndian) {\n                return promise.success(parseLittleEndian(hex));\n            }\n            else {\n                promise.success(parseInt(hex, 16));\n            }\n        });\n\n        return promise;\n    }\n\n    // Get the IFD portion of the EXIF header as a hex string.\n    function getIfd(app1Start, dirEntries) {\n        var offset = app1Start + 20,\n            bytes = dirEntries * 12;\n\n        return qq.readBlobToHex(fileOrBlob, offset, bytes);\n    }\n\n    // Obtain an array of all directory entries (as hex strings) in the EXIF header.\n    function getDirEntries(ifdHex) {\n        var entries = [],\n            offset = 0;\n\n        while (offset + 24 <= ifdHex.length) {\n            entries.push(ifdHex.slice(offset, offset + 24));\n            offset += 24;\n        }\n\n        return entries;\n    }\n\n    // Obtain values for all relevant tags and return them.\n    function getTagValues(littleEndian, dirEntries) {\n        var TAG_VAL_OFFSET = 16,\n            tagsToFind = qq.extend([], TAG_IDS),\n            vals = {};\n\n        qq.each(dirEntries, function(idx, entry) {\n            var idHex = entry.slice(0, 4),\n                id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16),\n                tagsToFindIdx = tagsToFind.indexOf(id),\n                tagValHex, tagName, tagValLength;\n\n            if (tagsToFindIdx >= 0) {\n                tagName = TAG_INFO[id].name;\n                tagValLength = TAG_INFO[id].bytes;\n                tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + (tagValLength * 2));\n                vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n\n                tagsToFind.splice(tagsToFindIdx, 1);\n            }\n\n            if (tagsToFind.length === 0) {\n                return false;\n            }\n        });\n\n        return vals;\n    }\n\n    qq.extend(this, {\n        /**\n         * Attempt to parse the EXIF header for the `Blob` associated with this instance.\n         *\n         * @returns {qq.Promise} To be fulfilled when the parsing is complete.\n         * If successful, the parsed EXIF header as an object will be included.\n         */\n        parse: function() {\n            var parser = new qq.Promise(),\n                onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n\n            getApp1Offset().then(function(app1Offset) {\n                log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n\n                isLittleEndian(app1Offset).then(function(littleEndian) {\n\n                    log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n\n                    getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n\n                        log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n\n                        getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                            var dirEntries = getDirEntries(ifdHex),\n                                tagValues = getTagValues(littleEndian, dirEntries);\n\n                            log(\"Successfully parsed some EXIF tags\");\n\n                            parser.success(tagValues);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n            }, onParseFailure);\n\n            return parser;\n        }\n    });\n\n    /*<testing>*/\n    this._testing = {};\n    this._testing.parseLittleEndian = parseLittleEndian;\n    /*</testing>*/\n};\n","/*globals qq */\nqq.Identify = function(fileOrBlob, log) {\n    \"use strict\";\n\n    function isIdentifiable(magicBytes, questionableBytes) {\n        var identifiable = false,\n            magicBytesEntries = [].concat(magicBytes);\n\n        qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n            if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                identifiable = true;\n                return false;\n            }\n        });\n\n        return identifiable;\n    }\n\n    qq.extend(this, {\n        /**\n         * Determines if a Blob can be displayed natively in the current browser.  This is done by reading magic\n         * bytes in the beginning of the file, so this is an asynchronous operation.  Before we attempt to read the\n         * file, we will examine the blob's type attribute to save CPU cycles.\n         *\n         * @returns {qq.Promise} Promise that is fulfilled when identification is complete.\n         * If successful, the MIME string is passed to the success handler.\n         */\n        isPreviewable: function() {\n            var self = this,\n                identifier = new qq.Promise(),\n                previewable = false,\n                name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\n            log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n\n            log(\"First pass: check type attribute of blob object.\");\n\n            if (this.isPreviewableSync()) {\n                log(\"Second pass: check for magic bytes in file header.\");\n\n                qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                    qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                        if (isIdentifiable(bytes, hex)) {\n                            // Safari is the only supported browser that can deal with TIFFs natively,\n                            // so, if this is a TIFF and the UA isn't Safari, declare this file \"non-previewable\".\n                            if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                previewable = true;\n                                identifier.success(mime);\n                            }\n\n                            return false;\n                        }\n                    });\n\n                    log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n\n                    if (!previewable) {\n                        identifier.failure();\n                    }\n                },\n                function() {\n                    log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                    identifier.failure();\n                });\n            }\n            else {\n                identifier.failure();\n            }\n\n            return identifier;\n        },\n\n        /**\n         * Determines if a Blob can be displayed natively in the current browser.  This is done by checking the\n         * blob's type attribute.  This is a synchronous operation, useful for situations where an asynchronous operation\n         * would be challenging to support.  Note that the blob's type property is not as accurate as reading the\n         * file's magic bytes.\n         *\n         * @returns {Boolean} true if the blob can be rendered in the current browser\n         */\n        isPreviewableSync: function() {\n            var fileMime = fileOrBlob.type,\n                // Assumption: This will only ever be executed in browsers that support `Object.keys`.\n                isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0,\n                previewable = false,\n                name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\n            if (isRecognizedImage) {\n                if (fileMime === \"image/tiff\") {\n                    previewable = qq.supportedFeatures.tiffPreviews;\n                }\n                else {\n                    previewable = true;\n                }\n            }\n\n            !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n\n            return previewable;\n        }\n    });\n};\n\nqq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n    \"image/jpeg\": \"ffd8ff\",\n    \"image/gif\": \"474946\",\n    \"image/png\": \"89504e\",\n    \"image/bmp\": \"424d\",\n    \"image/tiff\": [\"49492a00\", \"4d4d002a\"]\n};\n","/*globals qq*/\n/**\n * Attempts to validate an image, wherever possible.\n *\n * @param blob File or Blob representing a user-selecting image.\n * @param log Uses this to post log messages to the console.\n * @constructor\n */\nqq.ImageValidation = function(blob, log) {\n    \"use strict\";\n\n    /**\n     * @param limits Object with possible image-related limits to enforce.\n     * @returns {boolean} true if at least one of the limits has a non-zero value\n     */\n    function hasNonZeroLimits(limits) {\n        var atLeastOne = false;\n\n        qq.each(limits, function(limit, value) {\n            if (value > 0) {\n                atLeastOne = true;\n                return false;\n            }\n        });\n\n        return atLeastOne;\n    }\n\n    /**\n     * @returns {qq.Promise} The promise is a failure if we can't obtain the width & height.\n     * Otherwise, `success` is called on the returned promise with an object containing\n     * `width` and `height` properties.\n     */\n    function getWidthHeight() {\n        var sizeDetermination = new qq.Promise();\n\n        new qq.Identify(blob, log).isPreviewable().then(function() {\n            var image = new Image(),\n                url = window.URL && window.URL.createObjectURL ? window.URL :\n                      window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL :\n                      null;\n\n            if (url) {\n                image.onerror = function() {\n                    log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                    sizeDetermination.failure();\n                };\n\n                image.onload = function() {\n                    sizeDetermination.success({\n                        width: this.width,\n                        height: this.height\n                    });\n                };\n\n                image.src = url.createObjectURL(blob);\n            }\n            else {\n                log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                sizeDetermination.failure();\n            }\n        }, sizeDetermination.failure);\n\n        return sizeDetermination;\n    }\n\n    /**\n     *\n     * @param limits Object with possible image-related limits to enforce.\n     * @param dimensions Object containing `width` & `height` properties for the image to test.\n     * @returns {String || undefined} The name of the failing limit.  Undefined if no failing limits.\n     */\n    function getFailingLimit(limits, dimensions) {\n        var failingLimit;\n\n        qq.each(limits, function(limitName, limitValue) {\n            if (limitValue > 0) {\n                var limitMatcher = /(max|min)(Width|Height)/.exec(limitName),\n                    dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1),\n                    actualValue = dimensions[dimensionPropName];\n\n                /*jshint -W015*/\n                switch (limitMatcher[1]) {\n                    case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                }\n            }\n        });\n\n        return failingLimit;\n    }\n\n    /**\n     * Validate the associated blob.\n     *\n     * @param limits\n     * @returns {qq.Promise} `success` is called on the promise is the image is valid or\n     * if the blob is not an image, or if the image is not verifiable.\n     * Otherwise, `failure` with the name of the failing limit.\n     */\n    this.validate = function(limits) {\n        var validationEffort = new qq.Promise();\n\n        log(\"Attempting to validate image.\");\n\n        if (hasNonZeroLimits(limits)) {\n            getWidthHeight().then(function(dimensions) {\n                var failingLimit = getFailingLimit(limits, dimensions);\n\n                if (failingLimit) {\n                    validationEffort.failure(failingLimit);\n                }\n                else {\n                    validationEffort.success();\n                }\n            }, validationEffort.success);\n        }\n        else {\n            validationEffort.success();\n        }\n\n        return validationEffort;\n    };\n};\n","/* globals qq */\n/**\n * Module used to control populating the initial list of files.\n *\n * @constructor\n */\nqq.Session = function(spec) {\n    \"use strict\";\n\n    var options = {\n        endpoint: null,\n        params: {},\n        customHeaders: {},\n        cors: {},\n        addFileRecord: function(sessionData) {},\n        log: function(message, level) {}\n    };\n\n    qq.extend(options, spec, true);\n\n    function isJsonResponseValid(response) {\n        if (qq.isArray(response)) {\n            return true;\n        }\n\n        options.log(\"Session response is not an array.\", \"error\");\n    }\n\n    function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n        var someItemsIgnored = false;\n\n        success = success && isJsonResponseValid(fileItems);\n\n        if (success) {\n            qq.each(fileItems, function(idx, fileItem) {\n                /* jshint eqnull:true */\n                if (fileItem.uuid == null) {\n                    someItemsIgnored = true;\n                    options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                }\n                else if (fileItem.name == null) {\n                    someItemsIgnored = true;\n                    options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                }\n                else {\n                    try {\n                        options.addFileRecord(fileItem);\n                        return true;\n                    }\n                    catch (err) {\n                        someItemsIgnored = true;\n                        options.log(err.message, \"error\");\n                    }\n                }\n\n                return false;\n            });\n        }\n\n        promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n    }\n\n    // Initiate a call to the server that will be used to populate the initial file list.\n    // Returns a `qq.Promise`.\n    this.refresh = function() {\n        /*jshint indent:false */\n        var refreshEffort = new qq.Promise(),\n            refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            },\n            requesterOptions = qq.extend({}, options),\n            requester = new qq.SessionAjaxRequester(\n                qq.extend(requesterOptions, {onComplete: refreshCompleteCallback})\n            );\n\n        requester.queryServer();\n\n        return refreshEffort;\n    };\n};\n","/*globals qq, XMLHttpRequest*/\n/**\n * Thin module used to send GET requests to the server, expecting information about session\n * data used to initialize an uploader instance.\n *\n * @param spec Various options used to influence the associated request.\n * @constructor\n */\nqq.SessionAjaxRequester = function(spec) {\n    \"use strict\";\n\n    var requester,\n        options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n\n    qq.extend(options, spec);\n\n    function onComplete(id, xhrOrXdr, isError) {\n        var response = null;\n\n        /* jshint eqnull:true */\n        if (xhrOrXdr.responseText != null) {\n            try {\n                response = qq.parseJson(xhrOrXdr.responseText);\n            }\n            catch (err) {\n                options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                isError = true;\n            }\n        }\n\n        options.onComplete(response, !isError, xhrOrXdr);\n    }\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n        acceptHeader: \"application/json\",\n        validMethods: [\"GET\"],\n        method: \"GET\",\n        endpointStore: {\n            get: function() {\n                return options.endpoint;\n            }\n        },\n        customHeaders: options.customHeaders,\n        log: options.log,\n        onComplete: onComplete,\n        cors: options.cors\n    }));\n\n    qq.extend(this, {\n        queryServer: function() {\n            var params = qq.extend({}, options.params);\n\n            options.log(\"Session query request.\");\n\n            requester.initTransport(\"sessionRefresh\")\n                .withParams(params)\n                .withCacheBuster()\n                .send();\n        }\n    });\n};\n","/* globals qq, ExifRestorer */\n/**\n * Controls generation of scaled images based on a reference image encapsulated in a `File` or `Blob`.\n * Scaled images are generated and converted to blobs on-demand.\n * Multiple scaled images per reference image with varying sizes and other properties are supported.\n *\n * @param spec Information about the scaled images to generate.\n * @param log Logger instance\n * @constructor\n */\nqq.Scaler = function(spec, log) {\n    \"use strict\";\n\n    var self = this,\n        customResizeFunction = spec.customResizer,\n        includeOriginal = spec.sendOriginal,\n        orient = spec.orient,\n        defaultType = spec.defaultType,\n        defaultQuality = spec.defaultQuality / 100,\n        failedToScaleText = spec.failureText,\n        includeExif = spec.includeExif,\n        sizes = this._getSortedSizes(spec.sizes);\n\n    // Revealed API for instances of this module\n    qq.extend(this, {\n        // If no targeted sizes have been declared or if this browser doesn't support\n        // client-side image preview generation, there is no scaling to do.\n        enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n\n        getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n            var self = this,\n                records = [],\n                originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData,\n                identifier = new qq.Identify(originalBlob, log);\n\n            // If the reference file cannot be rendered natively, we can't create scaled versions.\n            if (identifier.isPreviewableSync()) {\n                // Create records for each scaled version & add them to the records array, smallest first.\n                qq.each(sizes, function(idx, sizeRecord) {\n                    var outputType = self._determineOutputType({\n                        defaultType: defaultType,\n                        requestedType: sizeRecord.type,\n                        refType: originalBlob.type\n                    });\n\n                    records.push({\n                        uuid: qq.getUniqueId(),\n                        name: self._getName(originalFileName, {\n                            name: sizeRecord.name,\n                            type: outputType,\n                            refType: originalBlob.type\n                        }),\n                        blob: new qq.BlobProxy(originalBlob,\n                        qq.bind(self._generateScaledImage, self, {\n                            customResizeFunction: customResizeFunction,\n                            maxSize: sizeRecord.maxSize,\n                            orient: orient,\n                            type: outputType,\n                            quality: defaultQuality,\n                            failedText: failedToScaleText,\n                            includeExif: includeExif,\n                            log: log\n                        }))\n                    });\n                });\n\n                records.push({\n                    uuid: originalFileUuid,\n                    name: originalFileName,\n                    size: originalBlob.size,\n                    blob: includeOriginal ? originalBlob : null\n                });\n            }\n            else {\n                records.push({\n                    uuid: originalFileUuid,\n                    name: originalFileName,\n                    size: originalBlob.size,\n                    blob: originalBlob\n                });\n            }\n\n            return records;\n        },\n\n        handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n            var self = this,\n                buttonId = file.qqButtonId || (file.blob && file.blob.qqButtonId),\n                scaledIds = [],\n                originalId = null,\n                addFileToHandler = api.addFileToHandler,\n                uploadData = api.uploadData,\n                paramsStore = api.paramsStore,\n                proxyGroupId = qq.getUniqueId();\n\n            qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                var blobSize = record.size,\n                    id;\n\n                if (record.blob instanceof qq.BlobProxy) {\n                    blobSize = -1;\n                }\n\n                id = uploadData.addFile({\n                    uuid: record.uuid,\n                    name: record.name,\n                    size: blobSize,\n                    batchId: batchId,\n                    proxyGroupId: proxyGroupId\n                });\n\n                if (record.blob instanceof qq.BlobProxy) {\n                    scaledIds.push(id);\n                }\n                else {\n                    originalId = id;\n                }\n\n                if (record.blob) {\n                    addFileToHandler(id, record.blob);\n                    fileList.push({id: id, file: record.blob});\n                }\n                else {\n                    uploadData.setStatus(id, qq.status.REJECTED);\n                }\n            });\n\n            // If we are potentially uploading an original file and some scaled versions,\n            // ensure the scaled versions include reference's to the parent's UUID and size\n            // in their associated upload requests.\n            if (originalId !== null) {\n                qq.each(scaledIds, function(idx, scaledId) {\n                    var params = {\n                        qqparentuuid: uploadData.retrieve({id: originalId}).uuid,\n                        qqparentsize: uploadData.retrieve({id: originalId}).size\n                    };\n\n                    // Make sure the UUID for each scaled image is sent with the upload request,\n                    // to be consistent (since we may need to ensure it is sent for the original file as well).\n                    params[uuidParamName] = uploadData.retrieve({id: scaledId}).uuid;\n\n                    uploadData.setParentId(scaledId, originalId);\n                    paramsStore.addReadOnly(scaledId, params);\n                });\n\n                // If any scaled images are tied to this parent image, be SURE we send its UUID as an upload request\n                // parameter as well.\n                if (scaledIds.length) {\n                    (function() {\n                        var param = {};\n                        param[uuidParamName] = uploadData.retrieve({id: originalId}).uuid;\n                        paramsStore.addReadOnly(originalId, param);\n                    }());\n                }\n            }\n        }\n    });\n};\n\nqq.extend(qq.Scaler.prototype, {\n    scaleImage: function(id, specs, api) {\n        \"use strict\";\n\n        if (!qq.supportedFeatures.scaling) {\n            throw new qq.Error(\"Scaling is not supported in this browser!\");\n        }\n\n        var scalingEffort = new qq.Promise(),\n            log = api.log,\n            file = api.getFile(id),\n            uploadData = api.uploadData.retrieve({id: id}),\n            name = uploadData && uploadData.name,\n            uuid = uploadData && uploadData.uuid,\n            scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [{name: \"\", maxSize: specs.maxSize}]\n            },\n            scaler = new qq.Scaler(scalingOptions, log);\n\n        if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n            scalingEffort.failure();\n\n            log(\"Could not generate requested scaled image for \" + id + \".  \" +\n                \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n        }\n        else {\n            (qq.bind(function() {\n                // Assumption: There will never be more than one record\n                var record = scaler.getFileRecords(uuid, name, file)[0];\n\n                if (record && record.blob instanceof qq.BlobProxy) {\n                    record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                }\n                else {\n                    log(id + \" is not a scalable image!\", \"error\");\n                    scalingEffort.failure();\n                }\n            }, this)());\n        }\n\n        return scalingEffort;\n    },\n\n    // NOTE: We cannot reliably determine at this time if the UA supports a specific MIME type for the target format.\n    // image/jpeg and image/png are the only safe choices at this time.\n    _determineOutputType: function(spec) {\n        \"use strict\";\n\n        var requestedType = spec.requestedType,\n            defaultType = spec.defaultType,\n            referenceType = spec.refType;\n\n        // If a default type and requested type have not been specified, this should be a\n        // JPEG if the original type is a JPEG, otherwise, a PNG.\n        if (!defaultType && !requestedType) {\n            if (referenceType !== \"image/jpeg\") {\n                return \"image/png\";\n            }\n            return referenceType;\n        }\n\n        // A specified default type is used when a requested type is not specified.\n        if (!requestedType) {\n            return defaultType;\n        }\n\n        // If requested type is specified, use it, as long as this recognized type is supported by the current UA\n        if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n            if (requestedType === \"image/tiff\") {\n                return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n            }\n\n            return requestedType;\n        }\n\n        return defaultType;\n    },\n\n    // Get a file name for a generated scaled file record, based on the provided scaled image description\n    _getName: function(originalName, scaledVersionProperties) {\n        \"use strict\";\n\n        var startOfExt = originalName.lastIndexOf(\".\"),\n            versionType = scaledVersionProperties.type || \"image/png\",\n            referenceType = scaledVersionProperties.refType,\n            scaledName = \"\",\n            scaledExt = qq.getExtension(originalName),\n            nameAppendage = \"\";\n\n        if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n            nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n        }\n\n        if (startOfExt >= 0) {\n            scaledName = originalName.substr(0, startOfExt);\n\n            if (referenceType !== versionType) {\n                scaledExt = versionType.split(\"/\")[1];\n            }\n\n            scaledName += nameAppendage + \".\" + scaledExt;\n        }\n        else {\n            scaledName = originalName + nameAppendage;\n        }\n\n        return scaledName;\n    },\n\n    // We want the smallest scaled file to be uploaded first\n    _getSortedSizes: function(sizes) {\n        \"use strict\";\n\n        sizes = qq.extend([], sizes);\n\n        return sizes.sort(function(a, b) {\n            if (a.maxSize > b.maxSize) {\n                return 1;\n            }\n            if (a.maxSize < b.maxSize) {\n                return -1;\n            }\n            return 0;\n        });\n    },\n\n    _generateScaledImage: function(spec, sourceFile) {\n        \"use strict\";\n\n        var self = this,\n            customResizeFunction = spec.customResizeFunction,\n            log = spec.log,\n            maxSize = spec.maxSize,\n            orient = spec.orient,\n            type = spec.type,\n            quality = spec.quality,\n            failedText = spec.failedText,\n            includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\",\n            scalingEffort = new qq.Promise(),\n            imageGenerator = new qq.ImageGenerator(log),\n            canvas = document.createElement(\"canvas\");\n\n        log(\"Attempting to generate scaled version for \" + sourceFile.name);\n\n        imageGenerator.generate(sourceFile, canvas, {maxSize: maxSize, orient: orient, customResizeFunction: customResizeFunction}).then(function() {\n            var scaledImageDataUri = canvas.toDataURL(type, quality),\n                signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n\n            if (includeExif) {\n                self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                    scaledImageDataUri = scaledImageDataUriWithExif;\n                    signalSuccess();\n                },\n                function() {\n                    log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                    signalSuccess();\n                });\n            }\n            else {\n                signalSuccess();\n            }\n        }, function() {\n            log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n            scalingEffort.failure(failedText);\n        });\n\n        return scalingEffort;\n    },\n\n    // Attempt to insert the original image's EXIF header into a scaled version.\n    _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n        \"use strict\";\n\n        var reader = new FileReader(),\n            insertionEffort = new qq.Promise(),\n            originalImageDataUri = \"\";\n\n        reader.onload = function() {\n            originalImageDataUri = reader.result;\n            insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n        };\n\n        reader.onerror = function() {\n            log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n            insertionEffort.failure();\n        };\n\n        reader.readAsDataURL(originalImage);\n\n        return insertionEffort;\n    },\n\n    _dataUriToBlob: function(dataUri) {\n        \"use strict\";\n\n        var byteString, mimeString, arrayBuffer, intArray;\n\n        // convert base64 to raw binary data held in a string\n        if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n            byteString = atob(dataUri.split(\",\")[1]);\n        }\n        else {\n            byteString = decodeURI(dataUri.split(\",\")[1]);\n        }\n\n        // extract the MIME\n        mimeString = dataUri.split(\",\")[0]\n            .split(\":\")[1]\n            .split(\";\")[0];\n\n        // write the bytes of the binary string to an ArrayBuffer\n        arrayBuffer = new ArrayBuffer(byteString.length);\n        intArray = new Uint8Array(arrayBuffer);\n        qq.each(byteString, function(idx, character) {\n            intArray[idx] = character.charCodeAt(0);\n        });\n\n        return this._createBlob(arrayBuffer, mimeString);\n    },\n\n    _createBlob: function(data, mime) {\n        \"use strict\";\n\n        var BlobBuilder = window.BlobBuilder ||\n                window.WebKitBlobBuilder ||\n                window.MozBlobBuilder ||\n                window.MSBlobBuilder,\n            blobBuilder = BlobBuilder && new BlobBuilder();\n\n        if (blobBuilder) {\n            blobBuilder.append(data);\n            return blobBuilder.getBlob(mime);\n        }\n        else {\n            return new Blob([data], {type: mime});\n        }\n    }\n});\n","//Based on MinifyJpeg\n//http://elicon.blog57.fc2.com/blog-entry-206.html\n\nqq.ExifRestorer = (function()\n{\n   \n\tvar ExifRestorer = {};\n\t \n    ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" +\n                         \"QRSTUVWXYZabcdef\" +\n                         \"ghijklmnopqrstuv\" +\n                         \"wxyz0123456789+/\" +\n                         \"=\";\n\n    ExifRestorer.encode64 = function(input)\n    {\n        var output = \"\",\n            chr1, chr2, chr3 = \"\",\n            enc1, enc2, enc3, enc4 = \"\",\n            i = 0;\n\n        do {\n            chr1 = input[i++];\n            chr2 = input[i++];\n            chr3 = input[i++];\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n               enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n               enc4 = 64;\n            }\n\n            output = output +\n               this.KEY_STR.charAt(enc1) +\n               this.KEY_STR.charAt(enc2) +\n               this.KEY_STR.charAt(enc3) +\n               this.KEY_STR.charAt(enc4);\n            chr1 = chr2 = chr3 = \"\";\n            enc1 = enc2 = enc3 = enc4 = \"\";\n        } while (i < input.length);\n\n        return output;\n    };\n    \n    ExifRestorer.restore = function(origFileBase64, resizedFileBase64)\n    {\n        var expectedBase64Header = \"data:image/jpeg;base64,\";\n\n        if (!origFileBase64.match(expectedBase64Header))\n        {\n        \treturn resizedFileBase64;\n        }       \n        \n        var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n        var segments = this.slice2Segments(rawImage);\n                \n        var image = this.exifManipulation(resizedFileBase64, segments);\n        \n        return expectedBase64Header + this.encode64(image);\n        \n    };\n\n\n    ExifRestorer.exifManipulation = function(resizedFileBase64, segments)\n    {\n            var exifArray = this.getExifArray(segments),\n                newImageArray = this.insertExif(resizedFileBase64, exifArray),\n                aBuffer = new Uint8Array(newImageArray);\n\n            return aBuffer;\n    };\n\n\n    ExifRestorer.getExifArray = function(segments)\n    {\n            var seg;\n            for (var x = 0; x < segments.length; x++)\n            {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) //(ff e1)\n                {\n                    return seg;\n                }\n            }\n            return [];\n    };\n\n\n    ExifRestorer.insertExif = function(resizedFileBase64, exifArray)\n    {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"),\n                buf = this.decode64(imageData),\n                separatePoint = buf.indexOf(255,3),\n                mae = buf.slice(0, separatePoint),\n                ato = buf.slice(separatePoint),\n                array = mae;\n\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n           return array;\n    };\n\n\n    \n    ExifRestorer.slice2Segments = function(rawImageArray)\n    {\n        var head = 0,\n            segments = [];\n\n        while (1)\n        {\n            if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218){break;}\n            if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216)\n            {\n                head += 2;\n            }\n            else\n            {\n                var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],\n                    endPoint = head + length + 2,\n                    seg = rawImageArray.slice(head, endPoint);\n                segments.push(seg);\n                head = endPoint;\n            }\n            if (head > rawImageArray.length){break;}\n        }\n\n        return segments;\n    };\n\n\n    \n    ExifRestorer.decode64 = function(input) \n    {\n        var output = \"\",\n            chr1, chr2, chr3 = \"\",\n            enc1, enc2, enc3, enc4 = \"\",\n            i = 0,\n            buf = [];\n\n        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n        var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n        if (base64test.exec(input)) {\n            throw new Error(\"There were invalid base64 characters in the input text.  \" +\n                \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n        }\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n        do {\n            enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n            enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n            enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n            enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            buf.push(chr1);\n\n            if (enc3 != 64) {\n               buf.push(chr2);\n            }\n            if (enc4 != 64) {\n               buf.push(chr3);\n            }\n\n            chr1 = chr2 = chr3 = \"\";\n            enc1 = enc2 = enc3 = enc4 = \"\";\n\n        } while (i < input.length);\n\n        return buf;\n    };\n\n    \n    return ExifRestorer;\n})();\n","/* globals qq */\n/**\n * Keeps a running tally of total upload progress for a batch of files.\n *\n * @param callback Invoked when total progress changes, passing calculated total loaded & total size values.\n * @param getSize Function that returns the size of a file given its ID\n * @constructor\n */\nqq.TotalProgress = function(callback, getSize) {\n    \"use strict\";\n\n    var perFileProgress = {},\n        totalLoaded = 0,\n        totalSize = 0,\n\n        lastLoadedSent = -1,\n        lastTotalSent = -1,\n        callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        },\n\n        /**\n         * @param failed Array of file IDs that have failed\n         * @param retryable Array of file IDs that are retryable\n         * @returns true if none of the failed files are eligible for retry\n         */\n        noRetryableFiles = function(failed, retryable) {\n            var none = true;\n\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n\n            return none;\n        },\n\n        onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        },\n\n        onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        },\n\n        onNew = function(id) {\n            var size = getSize(id);\n\n            // We might not know the size yet, such as for blob proxies\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {loaded: 0, total: size};\n            }\n        },\n\n        /**\n         * Invokes the callback with the current total progress of all files in the batch.  Called whenever it may\n         * be appropriate to re-calculate and disseminate this data.\n         *\n         * @param id ID of a file that has changed in some important way\n         * @param newLoaded New loaded value for this file.  -1 if this value should no longer be part of calculations\n         * @param newTotal New total size of the file.  -1 if this value should no longer be part of calculations\n         */\n        updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0,\n                oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            }\n            else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n\n            callbackProxy(totalLoaded, totalSize);\n        };\n\n    qq.extend(this, {\n        // Called when a batch of files has completed uploading.\n        onAllComplete: onAllComplete,\n\n        // Called when the status of a file has changed.\n        onStatusChange: function(id, oldStatus, newStatus) {\n            if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                onCancel(id);\n            }\n            else if (newStatus === qq.status.SUBMITTING) {\n                onNew(id);\n            }\n        },\n\n        // Called whenever the upload progress of an individual file has changed.\n        onIndividualProgress: function(id, loaded, total) {\n            updateTotalProgress(id, loaded, total);\n            perFileProgress[id] = {loaded: loaded, total: total};\n        },\n\n        // Called whenever the total size of a file has changed, such as when the size of a generated blob is known.\n        onNewSize: function(id) {\n            onNew(id);\n        },\n\n        reset: function() {\n            perFileProgress = {};\n            totalLoaded = 0;\n            totalSize = 0;\n        }\n    });\n};\n","/*globals qq*/\nqq.PasteSupport = function(o) {\n    \"use strict\";\n\n    var options, detachPasteHandler;\n\n    options = {\n        targetElement: null,\n        callbacks: {\n            log: function(message, level) {},\n            pasteReceived: function(blob) {}\n        }\n    };\n\n    function isImage(item) {\n        return item.type &&\n            item.type.indexOf(\"image/\") === 0;\n    }\n\n    function registerPasteHandler() {\n        detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n            var clipboardData = event.clipboardData;\n\n            if (clipboardData) {\n                qq.each(clipboardData.items, function(idx, item) {\n                    if (isImage(item)) {\n                        var blob = item.getAsFile();\n                        options.callbacks.pasteReceived(blob);\n                    }\n                });\n            }\n        });\n    }\n\n    function unregisterPasteHandler() {\n        if (detachPasteHandler) {\n            detachPasteHandler();\n        }\n    }\n\n    qq.extend(options, o);\n    registerPasteHandler();\n\n    qq.extend(this, {\n        reset: function() {\n            unregisterPasteHandler();\n        }\n    });\n};\n","/* globals qq */\n/**\n * Module that handles support for existing forms.\n *\n * @param options Options passed from the integrator-supplied options related to form support.\n * @param startUpload Callback to invoke when files \"stored\" should be uploaded.\n * @param log Proxy for the logger\n * @constructor\n */\nqq.FormSupport = function(options, startUpload, log) {\n    \"use strict\";\n    var self  = this,\n        interceptSubmit = options.interceptSubmit,\n        formEl = options.element,\n        autoUpload = options.autoUpload;\n\n    // Available on the public API associated with this module.\n    qq.extend(this, {\n        // To be used by the caller to determine if the endpoint will be determined by some processing\n        // that occurs in this module, such as if the form has an action attribute.\n        // Ignore if `attachToForm === false`.\n        newEndpoint: null,\n\n        // To be used by the caller to determine if auto uploading should be allowed.\n        // Ignore if `attachToForm === false`.\n        newAutoUpload: autoUpload,\n\n        // true if a form was detected and is being tracked by this module\n        attachedToForm: false,\n\n        // Returns an object with names and values for all valid form elements associated with the attached form.\n        getFormInputsAsObject: function() {\n            /* jshint eqnull:true */\n            if (formEl == null) {\n                return null;\n            }\n\n            return self._form2Obj(formEl);\n        }\n    });\n\n    // If the form contains an action attribute, this should be the new upload endpoint.\n    function determineNewEndpoint(formEl) {\n        if (formEl.getAttribute(\"action\")) {\n            self.newEndpoint = formEl.getAttribute(\"action\");\n        }\n    }\n\n    // Return true only if the form is valid, or if we cannot make this determination.\n    // If the form is invalid, ensure invalid field(s) are highlighted in the UI.\n    function validateForm(formEl, nativeSubmit) {\n        if (formEl.checkValidity && !formEl.checkValidity()) {\n            log(\"Form did not pass validation checks - will not upload.\", \"error\");\n            nativeSubmit();\n        }\n        else {\n            return true;\n        }\n    }\n\n    // Intercept form submit attempts, unless the integrator has told us not to do this.\n    function maybeUploadOnSubmit(formEl) {\n        var nativeSubmit = formEl.submit;\n\n        // Intercept and squelch submit events.\n        qq(formEl).attach(\"submit\", function(event) {\n            event = event || window.event;\n\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            else {\n                event.returnValue = false;\n            }\n\n            validateForm(formEl, nativeSubmit) && startUpload();\n        });\n\n        // The form's `submit()` function may be called instead (i.e. via jQuery.submit()).\n        // Intercept that too.\n        formEl.submit = function() {\n            validateForm(formEl, nativeSubmit) && startUpload();\n        };\n    }\n\n    // If the element value passed from the uploader is a string, assume it is an element ID - select it.\n    // The rest of the code in this module depends on this being an HTMLElement.\n    function determineFormEl(formEl) {\n        if (formEl) {\n            if (qq.isString(formEl)) {\n                formEl = document.getElementById(formEl);\n            }\n\n            if (formEl) {\n                log(\"Attaching to form element.\");\n                determineNewEndpoint(formEl);\n                interceptSubmit && maybeUploadOnSubmit(formEl);\n            }\n        }\n\n        return formEl;\n    }\n\n    formEl = determineFormEl(formEl);\n    this.attachedToForm = !!formEl;\n};\n\nqq.extend(qq.FormSupport.prototype, {\n    // Converts all relevant form fields to key/value pairs.  This is meant to mimic the data a browser will\n    // construct from a given form when the form is submitted.\n    _form2Obj: function(form) {\n        \"use strict\";\n        var obj = {},\n            notIrrelevantType = function(type) {\n                var irrelevantTypes = [\n                    \"button\",\n                    \"image\",\n                    \"reset\",\n                    \"submit\"\n                ];\n\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            },\n            radioOrCheckbox = function(type) {\n                return qq.indexOf([\"checkbox\", \"radio\"], type.toLowerCase()) >= 0;\n            },\n            ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            },\n            selectValue = function(select) {\n                var value = null;\n\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n\n                return value;\n            };\n\n        qq.each(form.elements, function(idx, el) {\n            if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") &&\n                notIrrelevantType(el.type) &&\n                !ignoreValue(el)) {\n\n                obj[el.name] = el.value;\n            }\n            else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                var value = selectValue(el);\n\n                if (value !== null) {\n                    obj[el.name] = value;\n                }\n            }\n        });\n\n        return obj;\n    }\n});\n","/*globals qq*/\n/**\n * Upload handler used that assumes the current user agent does not have any support for the\n * File API, and, therefore, makes use of iframes and forms to submit the files directly to\n * a generic server.\n *\n * @param options Options passed from the base handler\n * @param proxy Callbacks & methods used to query for or push out data/changes\n */\nqq.traditional = qq.traditional || {};\nqq.traditional.FormUploadHandler = function(options, proxy) {\n    \"use strict\";\n\n    var handler = this,\n        getName = proxy.getName,\n        getUuid = proxy.getUuid,\n        log = proxy.log;\n\n    /**\n     * Returns json object received by iframe from server.\n     */\n    function getIframeContentJson(id, iframe) {\n        /*jshint evil: true*/\n\n        var response, doc, innerHtml;\n\n        //IE may throw an \"access is denied\" error when attempting to access contentDocument on the iframe in some cases\n        try {\n            // iframe.contentWindow.document - for IE<7\n            doc = iframe.contentDocument || iframe.contentWindow.document;\n            innerHtml = doc.body.innerHTML;\n\n            log(\"converting iframe's innerHTML to JSON\");\n            log(\"innerHTML = \" + innerHtml);\n            //plain text response may be wrapped in <pre> tag\n            if (innerHtml && innerHtml.match(/^<pre/i)) {\n                innerHtml = doc.body.firstChild.firstChild.nodeValue;\n            }\n\n            response = handler._parseJsonResponse(innerHtml);\n        }\n        catch (error) {\n            log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n            response = {success: false};\n        }\n\n        return response;\n    }\n\n    /**\n     * Creates form, that will be submitted to iframe\n     */\n    function createForm(id, iframe) {\n        var params = options.paramsStore.get(id),\n            method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\",\n            endpoint = options.endpointStore.get(id),\n            name = getName(id);\n\n        params[options.uuidName] = getUuid(id);\n        params[options.filenameParam] = name;\n\n        return handler._initFormForUpload({\n            method: method,\n            endpoint: endpoint,\n            params: params,\n            paramsInBody: options.paramsInBody,\n            targetName: iframe.name\n        });\n    }\n\n    this.uploadFile = function(id) {\n        var input = handler.getInput(id),\n            iframe = handler._createIframe(id),\n            promise = new qq.Promise(),\n            form;\n\n        form = createForm(id, iframe);\n        form.appendChild(input);\n\n        handler._attachLoadEvent(iframe, function(responseFromMessage) {\n            log(\"iframe loaded\");\n\n            var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n\n            handler._detachLoadEvent(id);\n\n            //we can't remove an iframe if the iframe doesn't belong to the same domain\n            if (!options.cors.expected) {\n                qq(iframe).remove();\n            }\n\n            if (response.success) {\n                promise.success(response);\n            }\n            else {\n                promise.failure(response);\n            }\n        });\n\n        log(\"Sending upload request for \" + id);\n        form.submit();\n        qq(form).remove();\n\n        return promise;\n    };\n\n    qq.extend(this, new qq.FormUploadHandler({\n        options: {\n            isCors: options.cors.expected,\n            inputName: options.inputName\n        },\n\n        proxy: {\n            onCancel: options.onCancel,\n            getName: getName,\n            getUuid: getUuid,\n            log: log\n        }\n    }));\n};\n","/*globals qq*/\n/**\n * Upload handler used to upload to traditional endpoints.  It depends on File API support, and, therefore,\n * makes use of `XMLHttpRequest` level 2 to upload `File`s and `Blob`s to a generic server.\n *\n * @param spec Options passed from the base handler\n * @param proxy Callbacks & methods used to query for or push out data/changes\n */\nqq.traditional = qq.traditional || {};\nqq.traditional.XhrUploadHandler = function(spec, proxy) {\n    \"use strict\";\n\n    var handler = this,\n        getName = proxy.getName,\n        getSize = proxy.getSize,\n        getUuid = proxy.getUuid,\n        log = proxy.log,\n        multipart = spec.forceMultipart || spec.paramsInBody,\n\n        addChunkingSpecificParams = function(id, params, chunkData) {\n            var size = getSize(id),\n                name = getName(id);\n\n            if (!spec.omitDefaultParams) {\n                params[spec.chunking.paramNames.partIndex] = chunkData.part;\n                params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n                params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n                params[spec.chunking.paramNames.totalParts] = chunkData.count;\n                params[spec.totalFileSizeName] = size;\n            }\n\n            /**\n             * When a Blob is sent in a multipart request, the filename value in the content-disposition header is either \"blob\"\n             * or an empty string.  So, we will need to include the actual file name as a param in this case.\n             */\n            if (multipart && !spec.omitDefaultParams) {\n                params[spec.filenameParam] = name;\n            }\n        },\n\n        allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n            cors: spec.cors,\n            endpoint: spec.chunking.success.endpoint,\n            headers: spec.chunking.success.headers,\n            jsonPayload: spec.chunking.success.jsonPayload,\n            log: log,\n            method: spec.chunking.success.method,\n            params: spec.chunking.success.params\n        }),\n\n        createReadyStateChangedHandler = function(id, xhr) {\n            var promise = new qq.Promise();\n\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    var result = onUploadOrChunkComplete(id, xhr);\n\n                    if (result.success) {\n                        promise.success(result.response, xhr);\n                    }\n                    else {\n                        promise.failure(result.response, xhr);\n                    }\n                }\n            };\n\n            return promise;\n        },\n\n        getChunksCompleteParams = function(id) {\n            var params = spec.paramsStore.get(id),\n                name = getName(id),\n                size = getSize(id);\n\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            params[spec.totalFileSizeName] = size;\n            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n\n            return params;\n        },\n\n        isErrorUploadResponse = function(xhr, response) {\n            return qq.indexOf([200, 201, 202, 203, 204], xhr.status) < 0 ||\n                (spec.requireSuccessJson && !response.success) ||\n                response.reset;\n        },\n\n        onUploadOrChunkComplete = function(id, xhr) {\n            var response;\n\n            log(\"xhr - server response received for \" + id);\n            log(\"responseText = \" + xhr.responseText);\n\n            response = parseResponse(true, xhr);\n\n            return {\n                success: !isErrorUploadResponse(xhr, response),\n                response: response\n            };\n        },\n\n        // If this is an upload response, we require a JSON payload, otherwise, it is optional.\n        parseResponse = function(upload, xhr) {\n            var response = {};\n\n            try {\n                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                response = qq.parseJson(xhr.responseText);\n            }\n            catch (error) {\n                upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n            }\n\n            return response;\n        },\n\n        sendChunksCompleteRequest = function(id) {\n            var promise = new qq.Promise();\n\n            allChunksDoneRequester.complete(\n                    id,\n                    handler._createXhr(id),\n                    getChunksCompleteParams(id),\n                    spec.customHeaders.get(id)\n                )\n                .then(function(xhr) {\n                    promise.success(parseResponse(false, xhr), xhr);\n                }, function(xhr) {\n                    promise.failure(parseResponse(false, xhr), xhr);\n                });\n\n            return promise;\n        },\n\n        setParamsAndGetEntityToSend = function(entityToSendParams) {\n            var fileOrBlob = entityToSendParams.fileOrBlob;\n            var id = entityToSendParams.id;\n            var xhr = entityToSendParams.xhr;\n            var xhrOverrides = entityToSendParams.xhrOverrides || {};\n            var customParams = entityToSendParams.customParams || {};\n            var defaultParams = entityToSendParams.params || {};\n            var xhrOverrideParams = xhrOverrides.params || {};\n            var params;\n\n            var formData = multipart ? new FormData() : null,\n                method = xhrOverrides.method || spec.method,\n                endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id),\n                name = getName(id),\n                size = getSize(id);\n\n            if (spec.omitDefaultParams) {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n            }\n            else {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n                qq.extend(params, defaultParams);\n\n                params[spec.uuidName] = getUuid(id);\n                params[spec.filenameParam] = name;\n\n                if (multipart) {\n                    params[spec.totalFileSizeName] = size;\n                }\n                else if (!spec.paramsInBody) {\n                    params[spec.inputName] = name;\n                }\n            }\n\n            //build query string\n            if (!spec.paramsInBody) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n\n            xhr.open(method, endpoint, true);\n\n            if (spec.cors.expected && spec.cors.sendCredentials) {\n                xhr.withCredentials = true;\n            }\n\n            if (multipart) {\n                if (spec.paramsInBody) {\n                    qq.obj2FormData(params, formData);\n                }\n\n                formData.append(spec.inputName, fileOrBlob);\n                return formData;\n            }\n\n            return fileOrBlob;\n        },\n\n        setUploadHeaders = function(headersOptions) {\n            var headerOverrides = headersOptions.headerOverrides;\n            var id = headersOptions.id;\n            var xhr = headersOptions.xhr;\n\n            if (headerOverrides) {\n                qq.each(headerOverrides, function(headerName, headerValue) {\n                    xhr.setRequestHeader(headerName, headerValue);\n                });\n            }\n            else {\n                var extraHeaders = spec.customHeaders.get(id),\n                    fileOrBlob = handler.getFile(id);\n\n                xhr.setRequestHeader(\"Accept\", \"application/json\");\n                xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n\n                if (!multipart) {\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                    //NOTE: return mime type in xhr works on chrome 16.0.9 firefox 11.0a2\n                    xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n                }\n\n                qq.each(extraHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        };\n\n    qq.extend(this, {\n        uploadChunk: function(uploadChunkParams) {\n            var id = uploadChunkParams.id;\n            var chunkIdx = uploadChunkParams.chunkIdx;\n            var overrides = uploadChunkParams.overrides || {};\n            var resuming = uploadChunkParams.resuming;\n\n            var chunkData = handler._getChunkData(id, chunkIdx),\n                xhr = handler._createXhr(id, chunkIdx),\n                promise, toSend, customParams, params = {};\n\n            promise = createReadyStateChangedHandler(id, xhr);\n            handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n            customParams = spec.paramsStore.get(id);\n            addChunkingSpecificParams(id, params, chunkData);\n\n            if (resuming) {\n                params[spec.resume.paramNames.resuming] = true;\n            }\n\n            toSend = setParamsAndGetEntityToSend({\n                fileOrBlob: chunkData.blob,\n                id: id,\n                customParams: customParams,\n                params: params,\n                xhr: xhr,\n                xhrOverrides: overrides\n            });\n\n            setUploadHeaders({\n                headerOverrides: overrides.headers,\n                id: id,\n                xhr: xhr\n            });\n\n            xhr.send(toSend);\n\n            return promise;\n        },\n\n        uploadFile: function(id) {\n            var fileOrBlob = handler.getFile(id),\n                promise, xhr, customParams, toSend;\n\n            xhr = handler._createXhr(id);\n            handler._registerProgressHandler(id);\n            promise = createReadyStateChangedHandler(id, xhr);\n            customParams = spec.paramsStore.get(id);\n\n            toSend = setParamsAndGetEntityToSend({\n                fileOrBlob: fileOrBlob,\n                id: id,\n                customParams: customParams,\n                xhr: xhr\n            });\n\n            setUploadHeaders({\n                id: id,\n                xhr: xhr\n            });\n\n            xhr.send(toSend);\n\n            return promise;\n        }\n    });\n\n    qq.extend(this, new qq.XhrUploadHandler({\n        options: qq.extend({namespace: \"traditional\"}, spec),\n        proxy: qq.extend({getEndpoint: spec.endpointStore.get}, proxy)\n    }));\n\n    qq.override(this, function(super_) {\n        return {\n            finalizeChunks: function(id) {\n                proxy.onFinalizing(id);\n\n                if (spec.chunking.success.endpoint) {\n                    return sendChunksCompleteRequest(id);\n                }\n                else {\n                    return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n                }\n            }\n        };\n    });\n};\n","/*globals qq*/\n/**\n * Ajax requester used to send a POST to a traditional endpoint once all chunks for a specific file have uploaded\n * successfully.\n *\n * @param o Options from the caller - will override the defaults.\n * @constructor\n */\nqq.traditional.AllChunksDoneAjaxRequester = function(o) {\n    \"use strict\";\n\n    var requester,\n        options = {\n            cors: {\n                allowXdr: false,\n                expected: false,\n                sendCredentials: false\n            },\n            endpoint: null,\n            log: function(str, level) {},\n            method: \"POST\"\n        },\n        promises = {},\n        endpointHandler = {\n            get: function(id) {\n                if (qq.isFunction(options.endpoint)) {\n                    return options.endpoint(id);\n                }\n\n                return options.endpoint;\n            }\n        };\n\n    qq.extend(options, o);\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n        acceptHeader: \"application/json\",\n        contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n        validMethods: [options.method],\n        method: options.method,\n        endpointStore: endpointHandler,\n        allowXRequestedWithAndCacheControl: false,\n        cors: options.cors,\n        log: options.log,\n        onComplete: function(id, xhr, isError) {\n            var promise = promises[id];\n\n            delete promises[id];\n\n            if (isError) {\n                promise.failure(xhr);\n            }\n            else {\n                promise.success(xhr);\n            }\n        }\n    }));\n\n    qq.extend(this, {\n        complete: function(id, xhr, params, headers) {\n            var promise = new qq.Promise();\n\n            options.log(\"Submitting All Chunks Done request for \" + id);\n\n            promises[id] = promise;\n\n            requester.initTransport(id)\n                .withParams(options.params(id) || params)\n                .withHeaders(options.headers(id) || headers)\n                .send(xhr);\n\n            return promise;\n        }\n    });\n};\n"]},"metadata":{},"sourceType":"script"}